<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS 使用 iso 作为本地 yum 源</title>
    <url>/2018/01/14/CentOS%E4%BD%BF%E7%94%A8iso%E4%BD%9C%E4%B8%BA%E6%9C%AC%E5%9C%B0yum%E6%BA%90/</url>
    <content><![CDATA[<h2 id="用本地-iso-文件创建本地-yum-源"><a href="#用本地-iso-文件创建本地-yum-源" class="headerlink" title="用本地 iso 文件创建本地 yum 源"></a>用本地 iso 文件创建本地 yum 源</h2><ol>
<li>创建 iso 存放目录和挂载目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/iso</span><br><span class="line">mkdir /mnt/isorom</span><br></pre></td></tr></table></figure>
<li>将 iso 镜像文件上传到 `/mnt/iso` 文件夹下
</li>
<li>将 `/mnt/iso/` 下的 iso 文件挂载到 `/mnt/isorom` 目录
</li>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /mnt/iso</span><br><span class="line">mount -o loop /mnt/iso/CentOS-7-x86_64-DVD-1708.iso /mnt/isorom</span><br></pre></td></tr></table></figure>
<ol>
<li>修改 <code>*.repo</code> 文件</li>
</ol>
<p>如果 <code>/etc/yum.repos.d/</code> 下面有其它的 <code>*.repo</code> 文件，先创建个文件夹，将这些 <code>*.repo</code> 先转移到文件夹中，自己写一个 <code>local.repo</code> 的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/repobak</span><br><span class="line">mv /etc/yum.repos.d/* ~/repobak/</span><br><span class="line">vim /etc/yum.repos.d/local.repo</span><br></pre></td></tr></table></figure>
<p><code>local.repo</code> 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS7-DVD-ISO</span><br><span class="line"># 注：这里的 baseurl 就是你挂载的目录，在这里是 /mnt/isorom</span><br><span class="line">baseurl=file:///mnt/isorom</span><br><span class="line"># 注：这里的值 enabled 一定要为 1</span><br><span class="line">enabled=1</span><br><span class="line"># gpgckeck的值无所谓</span><br><span class="line">gpgckeck=0</span><br><span class="line"># 注：这个你cd /mnt/isorom/可以看到这个key，这里仅仅是个例子</span><br><span class="line">gpgkey=file:///mnt/isorom/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure>
<h2 id="清除-yum-缓存，建立缓存，开始正常使用-iso-源"><a href="#清除-yum-缓存，建立缓存，开始正常使用-iso-源" class="headerlink" title="清除 yum 缓存，建立缓存，开始正常使用 iso 源"></a>清除 yum 缓存，建立缓存，开始正常使用 iso 源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum install -y vim</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose 安装 Jenkins</title>
    <url>/2020/08/02/DockerCompose%E5%AE%89%E8%A3%85Jenkins/</url>
    <content><![CDATA[<h2 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h2><p>前往 <code>https://github.com/docker/compose/releases</code> 下载对应的 docker-compose 二进制可执行文件</p>
<p>将 docker-compose 移动至 <code>/usr/local/bin/</code> 目录下，并赋予可执行权限</p>
<h2 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jenkins/jenkins:lts</span><br><span class="line">nginx:1.16.1</span><br><span class="line">docker:19.03.12-dind</span><br></pre></td></tr></table></figure>
<h2 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h2><p>为了持久化 CI 数据，我们需要将 jenkins 部分目录挂载到宿主机保存，如在 <code>/data</code> 目录下创建如下目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/atompi-ci/jenkins</span><br><span class="line">chown -R 1000:1000 /data/atompi-ci/jenkins</span><br><span class="line">mkdir -p /data/atompi-ci/nginx/conf.d</span><br><span class="line">mkdir -p /data/atompi-ci/nginx/logs</span><br><span class="line">mkdir -p /data/atompi-ci/nginx/ssl</span><br><span class="line">mkdir -p /data/atompi-ci/docker/data</span><br><span class="line">mkdir -p /data/atompi-ci/docker/etc</span><br></pre></td></tr></table></figure>
<p><strong>PS: 由于 jenkins images 在 使用 Dockerfile 构建时，默认 UID 为 1000 ，所以在挂载 jenkins home 目录时需要将宿主机目录 UID 设置为 1000 ，或者修改 docker-compose.yml 将 jenkins 容器用户修改为 root ，这里使用了修改 docker-compose.yml 的方式，出于安全考虑，建议修改宿主机目录 UID ，如： <code>chown -R 1000:1000 /data/atompi-ci/jenkins</code></strong></p>
<h2 id="使用-docker-compose-部署-jenkins"><a href="#使用-docker-compose-部署-jenkins" class="headerlink" title="使用 docker-compose 部署 jenkins"></a>使用 docker-compose 部署 jenkins</h2><p>创建 <code>~/atompi-ci/</code> 目录并创建 <code>docker-compose.yml</code> 文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins:lts</span><br><span class="line">    environment:</span><br><span class="line">      - JAVA_OPTS=-Duser.timezone=Asia/Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/atompi-ci/jenkins:/var/jenkins_home</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:1.16.1</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/atompi-ci/nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">      - /data/atompi-ci/nginx/logs:/var/log/nginx</span><br><span class="line">      - /data/atompi-ci/nginx/ssl:/etc/nginx/ssl</span><br><span class="line">  docker:</span><br><span class="line">    image: docker:19.03.12-dind</span><br><span class="line">    privileged: true</span><br><span class="line">    environment:</span><br><span class="line">      - DOCKER_TLS_CERTDIR=</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/atompi-ci/docker/data:/var/lib/docker</span><br><span class="line">      - /data/atompi-ci/docker/etc:/etc/docker</span><br></pre></td></tr></table></figure>
<p>创建 <code>/data/atompi-ci/nginx/conf.d/jenkins.conf</code> 文件，该文件为 Jenkins 的 Nginx 反向代理配置文件，如果不需要同时安装 Nginx 可以跳过，并注释掉 <code>docker-compose.yml</code> 中的 nginx 部分，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_max_body_size 0;</span><br><span class="line">upstream jenkins &#123;</span><br><span class="line">  keepalive 32; # keepalive connections</span><br><span class="line">  server jenkins:8080; # jenkins ip and port</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ci.atompi.cc;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://jenkins;</span><br><span class="line">        proxy_redirect $scheme://ci.atompi.cc $scheme://ci.atompi.com:8888;</span><br><span class="line">        proxy_read_timeout 90;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行部署命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h2 id="配置-jenkins"><a href="#配置-jenkins" class="headerlink" title="配置 jenkins"></a>配置 jenkins</h2><p>初始化 jenkins</p>
<p>浏览器打开我们在 nginx 配置文件中设置的域名，如: <a href="http://ci.atompi.cc/">http://ci.atompi.cc</a></p>
<p>查看初始密码，在 jenkins 目录下 使用 docker-compose 命令查看 jenkins 日志，或者进入 jenkins 容器查看文件： <code>/var/jenkins_home/secrets/initialAdminPassword</code> （注意：初始化完成后，这个文件会消失）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看日志</span><br><span class="line"># docker-compose logs jenkins</span><br><span class="line"># 进入容器</span><br><span class="line"># docker-compose exec jenkins bash</span><br><span class="line"># cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>
<p>输入初始密码后进入插件安装界面，我们选择“安装推荐插件”。</p>
<p>去喝杯茶？</p>
<p>插件安装完成后，创建第一个管理员用户</p>
<p>选择保存并完成，之后进入确认 Jenkins URL 页面</p>
<p>初始化完成，开始使用 jenkins</p>
<p>进入 jenkins 首页</p>
<h2 id="安装-Gitee-Jenkins-Plugin"><a href="#安装-Gitee-Jenkins-Plugin" class="headerlink" title="安装 Gitee Jenkins Plugin"></a>安装 Gitee Jenkins Plugin</h2><ol>
<li>在线安装</li>
</ol>
<p>管理员登录 jenkins ，进入： 系统管理 –&gt; 管理插件 –&gt; 可选插件，在插件搜索栏输入“ Gitee ”，即可在下方可选列表中勾选“ Gitee ”。选择“下载待重启后安装”即可在重启 Jenkins 后完成安装。</p>
<ol>
<li>上传插件 hpi 文件安装</li>
</ol>
<p>从 <a href="https://gitee.com/oschina/Gitee-Jenkins-Plugin/releases">release</a> 列表中进入最新发行版，下载对应的 <code>gitee-&lt;version&gt;.hpi&lt;/version&gt;</code> 文件</p>
<p>进入：系统管理 –&gt; 管理插件 –&gt; 高级，在“上传插件”处上传 hpi 文件</p>
<ul>
<li><a href="https://gitee.com/oschina/Gitee-Jenkins-Plugin#%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE">Gitee Jenkins Plugin 使用文档</a></li>
</ul>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker给正在运行的容器映射宿主机端口</title>
    <url>/2018/01/17/Docker%E7%BB%99%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E6%98%A0%E5%B0%84%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="方式-1-：iptables-转发"><a href="#方式-1-：iptables-转发" class="headerlink" title="方式 1 ：iptables 转发"></a>方式 1 ：iptables 转发</h2><h3 id="获得容器-IP"><a href="#获得容器-IP" class="headerlink" title="获得容器 IP"></a>获得容器 IP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect &#x27;container_name&#x27; | grep &quot;\&quot;IPAddress\&quot;: \&quot;&quot;|head -1 | cut -d &quot;\&quot;&quot; -f 4</span><br></pre></td></tr></table></figure>
<h3 id="iptables-转发端口"><a href="#iptables-转发端口" class="headerlink" title="iptables 转发端口"></a>iptables 转发端口</h3><p>将容器的 <code>8000</code> 端口映射到 docker 主机的 <code>8001</code> 端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.2:8000</span><br></pre></td></tr></table></figure>
<h3 id="一步搞定"><a href="#一步搞定" class="headerlink" title="一步搞定"></a>一步搞定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination $(docker inspect &#x27;container_name&#x27; | grep &quot;\&quot;IPAddress\&quot;: \&quot;&quot;|head -1 | cut -d &quot;\&quot;&quot; -f 4):8000</span><br></pre></td></tr></table></figure>
<h2 id="方式-2-：-重新-build-镜像，-EXPOSE-端口，重新运行容器"><a href="#方式-2-：-重新-build-镜像，-EXPOSE-端口，重新运行容器" class="headerlink" title="方式 2 ： 重新 build 镜像， EXPOSE 端口，重新运行容器"></a>方式 2 ： 重新 build 镜像， EXPOSE 端口，重新运行容器</h2><p>新建一个空目录，编写 Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir image_name_version2</span><br><span class="line">cd image_name_version2</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure>
<p>Dockerfile 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM image_name:version</span><br><span class="line"></span><br><span class="line">EXPOSE 8000</span><br></pre></td></tr></table></figure>
<p>根据新的 Dockerfile 构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t image_name:version2 .</span><br></pre></td></tr></table></figure>
<p>基于新的镜像运行新的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 8001:8000 ...</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 修改用户名</title>
    <url>/2018/01/10/Linux%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D/</url>
    <content><![CDATA[<h2 id="usermod-修改用户名"><a href="#usermod-修改用户名" class="headerlink" title="usermod 修改用户名"></a>usermod 修改用户名</h2><p>退出当前用户，切换到 root 用户下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit # 不能直接使用 su 切换，这样源用户还会开启一个进程，</span><br></pre></td></tr></table></figure>
<h2 id="修改用户名-atompi-为-git"><a href="#修改用户名-atompi-为-git" class="headerlink" title="修改用户名 atompi 为 git"></a>修改用户名 atompi 为 git</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usermod -l git atompi</span><br></pre></td></tr></table></figure>
<h2 id="修改-home-目录"><a href="#修改-home-目录" class="headerlink" title="修改 home 目录"></a>修改 home 目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/passwd</span><br><span class="line"></span><br><span class="line"># 修改前：</span><br><span class="line">git:x:1000:1000:UbuntuServer,,,:/home/atompi:/bin/bash</span><br><span class="line"></span><br><span class="line">修改后：</span><br><span class="line">git:x:1000:1000:UbuntuServer,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure>
<h2 id="重命名原-home-目录"><a href="#重命名原-home-目录" class="headerlink" title="重命名原 home 目录"></a>重命名原 home 目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /home/atompi /home/git</span><br></pre></td></tr></table></figure>
<h2 id="修改-group"><a href="#修改-group" class="headerlink" title="修改 group"></a>修改 group</h2><p>此时 git 用户所在用户组仍然是 atompi ，通过修改 <code>/etc/group</code> 文件，修改用户组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/group</span><br><span class="line"></span><br><span class="line"># 修改前</span><br><span class="line">atompi:x:1000:</span><br><span class="line"></span><br><span class="line"># 修改后</span><br><span class="line">git:x:1000:</span><br></pre></td></tr></table></figure>
<h2 id="修改完成，验证、重新登录"><a href="#修改完成，验证、重新登录" class="headerlink" title="修改完成，验证、重新登录"></a>修改完成，验证、重新登录</h2><p>验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@frontend:~# id atompi</span><br><span class="line">id: ‘atompi’: no such user</span><br><span class="line">root@frontend:~# id git</span><br><span class="line">uid=1000(git) gid=1000(git) groups=1000(git),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),114(lpadmin),115(sambashare)</span><br></pre></td></tr></table></figure>
<p>退出重新登陆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux单网卡多IP配置</title>
    <url>/2018/01/15/Linux%E5%8D%95%E7%BD%91%E5%8D%A1%E5%A4%9AIP%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="临时生效"><a href="#临时生效" class="headerlink" title="临时生效"></a>临时生效</h2><ul>
<li>添加 IP 地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.1.1 netmask 255.255.255.0 up</span><br><span class="line"># netmask 可以写，也可以不写，不写，则是使用标准的子网掩码，默认情况下的，在使用 VLSM 的时候，这个 netmask 就显得很重要了。</span><br></pre></td></tr></table></figure>
<ul>
<li>添加默认网关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route add default gw 192.168.x.x</span><br></pre></td></tr></table></figure>
<h2 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h2><p>ifconfig 配置的 IP 地址，只是临时有效，如果系统重启，则失效，而永久生效，要写到配置文件里面。</p>
<p>在 RedHat &#x2F; CentOS 等系统，配置文件位于</p>
<p><code>/etc/sysysconfig/network-scripts/ifcfg-xxx</code></p>
<p>其中，ifcfg-xxx 为对应网卡的配置，如： ifcfg-eth0 使用 cat 查看一下安的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">DEVICE=eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">UUID=a912766c-5500-44c4-85da-09a38f1121c0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">HWADDR=00:0C:29:22:75:2A</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">NAME=&quot;System eth0&quot;</span><br></pre></td></tr></table></figure>
<p><code>DEVICE</code> 代表的是设备名称，比如 eth0</p>
<p><code>ONBOOT</code> 代表的是开机是否自动激活网卡，也就是说是否自动 up</p>
<p><code>BOOTPROTO</code> 代表的是地址类型，有 DHCP 动态获取 (dhcp) ，也可以指定静态地址 (static)</p>
<p><code>IPADDR</code> 代表的是静态地址的情况下，指定的 IP 地址是多少</p>
<p><code>NETMASK</code> 子网掩码</p>
<p><code>GATEWAY</code> 网关</p>
<p><code>HWADDR</code> 网卡的 MAC 地址 (可以指定，也可以不指定)</p>
<p>这几个是常用的，没有特殊情况(比如桥接：<code>bonding</code>)，写这几个就可以了，以下是一个配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.7.7</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.7.254</span><br></pre></td></tr></table></figure>
<p>PS：配置文件里， 等号 (&#x3D;) 前面的大写，后面的小写，若要使用 dhcp 动态获取 IP 地址，只需要将 <code>BOOTPROTO=dhcp</code> 再注释掉 <code>IPADDR</code> &#x2F; <code>NETMASK</code> &#x2F; <code>GATEWAY</code> 这三行，就可以了</p>
<p>另外，对于多网卡的配置，只需要复制配置文件，然后更改 <code>DEVICE=eth0:0</code> &#x2F; <code>DEVICE=eth0:1</code> 再写上相关的IP地址，即可以了，多 IP 的情况下，不要写多个网关</p>
<p>而对于 Debian &#x2F; Ubuntu 之类的 linux ，则网卡的配置文件要简单一些了，其配置文件位于：</p>
<p><code>/etc/network/interfaces</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto etho</span><br><span class="line">inface eth0 inet static</span><br><span class="line">      address 192.168.1.1</span><br><span class="line">      netmask 255.255.255.0</span><br><span class="line">      gateway 192.168.1.254</span><br><span class="line"></span><br><span class="line">auto eth0:0</span><br><span class="line">iface eth0:0 inet static</span><br><span class="line">      192.168.10.189</span><br><span class="line">      netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">auto eth0:1</span><br><span class="line">iface eth0:1 inet static</span><br><span class="line">      address 192.168.12.12</span><br><span class="line">      netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
<p>其中，<code>auto</code> 为自动启动网卡</p>
<p>iface 指定网卡设备，并指定类型，是动态还是静态，若要动态，则把 <code>static</code> 改为 <code>dhcp</code> 并注释掉 <code>address</code> &#x2F; <code>netmask</code> &#x2F; <code>gateway</code> 即可</p>
<p>至于 <code>address</code> 则是指定 IP 地址</p>
<p><code>netmask</code> 指定子网掩码</p>
<p><code>gateway</code> 指定网关</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS Ubuntu 离线源制作</title>
    <url>/2018/12/19/Linux%E7%A6%BB%E7%BA%BF%E6%BA%90%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="制作离线-yum-源"><a href="#制作离线-yum-源" class="headerlink" title="制作离线 yum 源"></a>制作离线 yum 源</h2><p><strong>在可以连接外网的服务器上操作</strong></p>
<h3 id="修改源为ustc"><a href="#修改源为ustc" class="headerlink" title="修改源为ustc"></a>修改源为ustc</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">sudo vim /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CentOS-Base.repo</span><br><span class="line">#</span><br><span class="line"># The mirror system uses the connecting IP address of the client and the</span><br><span class="line"># update status of each mirror to pick mirrors that are updated to and</span><br><span class="line"># geographically close to the client.  You should use this for CentOS updates</span><br><span class="line"># unless you are manually picking other mirrors.</span><br><span class="line">#</span><br><span class="line"># If the mirrorlist= does not work for you, as a fall back you can try the</span><br><span class="line"># remarked out baseurl= line instead.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;amp;arch=$basearch&amp;amp;repo=os</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos/$releasever/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#released updates</span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$releasever - Updates</span><br><span class="line"># mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;amp;arch=$basearch&amp;amp;repo=updates</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos/$releasever/updates/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that may be useful</span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$releasever - Extras</span><br><span class="line"># mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;amp;arch=$basearch&amp;amp;repo=extras</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos/$releasever/extras/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that extend functionality of existing packages</span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-$releasever - Plus</span><br><span class="line"># mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;amp;arch=$basearch&amp;amp;repo=centosplus</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos/$releasever/centosplus/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure>
<h3 id="创建yum源安装包目录"><a href="#创建yum源安装包目录" class="headerlink" title="创建yum源安装包目录"></a>创建yum源安装包目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/yumcaches</span><br></pre></td></tr></table></figure>
<h3 id="安装-createrepo-和-epel-release"><a href="#安装-createrepo-和-epel-release" class="headerlink" title="安装 createrepo 和 epel-release"></a>安装 createrepo 和 epel-release</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y createrepo</span><br><span class="line">sudo yum -y install epel-release</span><br></pre></td></tr></table></figure>
<h3 id="yumdownloader-下载相关repo包"><a href="#yumdownloader-下载相关repo包" class="headerlink" title="yumdownloader 下载相关repo包"></a>yumdownloader 下载相关repo包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp/repodir</span><br><span class="line">yumdownloader docker mysql mysql-devel java-1.8.0-openjdk python python-devel python-pip MySQL-python python-docker-py unzip iptables curl iproute ufw vim postfix --resolve</span><br></pre></td></tr></table></figure>
<h3 id="createrepo-创建索引"><a href="#createrepo-创建索引" class="headerlink" title="createrepo 创建索引"></a>createrepo 创建索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">createrepo -v /tmp/repodir/</span><br></pre></td></tr></table></figure>
<h2 id="制作离线apt源"><a href="#制作离线apt源" class="headerlink" title="制作离线apt源"></a>制作离线apt源</h2><p><strong>在可以连接外网的服务器上操作</strong></p>
<h3 id="修改源为阿里云"><a href="#修改源为阿里云" class="headerlink" title="修改源为阿里云"></a>修改源为阿里云</h3><p><code>vim /etc/apt/sources.list</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p><code>sudo apt-get update</code></p>
<h3 id="下载源安装包"><a href="#下载源安装包" class="headerlink" title="下载源安装包"></a>下载源安装包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y dpkg-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get -d install openjdk-8-jdk libltdl7 mysql-client python python-dev python-pip python-mysqldb unzip iptables curl iproute ufw vim python-apt postfix</span><br></pre></td></tr></table></figure>
<h3 id="copy-var-cache-apt-archives-到-home-atompi-localpacks-下"><a href="#copy-var-cache-apt-archives-到-home-atompi-localpacks-下" class="headerlink" title="copy &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;* 到 &#x2F;home&#x2F;atompi&#x2F;localpacks&#x2F; 下"></a>copy &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;* 到 &#x2F;home&#x2F;atompi&#x2F;localpacks&#x2F; 下</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/atompi/localpacks</span><br><span class="line"></span><br><span class="line">sudo cp -rf /var/cache/apt/archives/* /home/atompi/localpacks/</span><br></pre></td></tr></table></figure>
<h3 id="创建依赖索引"><a href="#创建依赖索引" class="headerlink" title="创建依赖索引"></a>创建依赖索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg-scanpackages localpacks /dev/null | gzip &amp;gt; /home/atompi/localpacks/Packages.gz</span><br></pre></td></tr></table></figure>
<h3 id="copy-到目标机器"><a href="#copy-到目标机器" class="headerlink" title="copy 到目标机器"></a>copy 到目标机器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r /home/atompi/localpacks atompi@192.168.1.131:/tmp/</span><br></pre></td></tr></table></figure>
<h3 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h3><p><code>sudo vi /etc/apt/sources.list</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb file:///tmp/ localpacks/</span><br></pre></td></tr></table></figure>
<p><code>sudo vi /etc/apt/apt.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APT &#123; Get &#123; AllowUnauthenticated &quot;1&quot;; &#125;; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<h2 id="制作-pip-源"><a href="#制作-pip-源" class="headerlink" title="制作 pip 源"></a>制作 pip 源</h2><p><strong>在可以连接外网的服务器上操作</strong></p>
<h3 id="安装python、python-dev、python-pip"><a href="#安装python、python-dev、python-pip" class="headerlink" title="安装python、python-dev、python-pip"></a>安装python、python-dev、python-pip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y python python-dev python-pip</span><br></pre></td></tr></table></figure>
<h3 id="pip-安装-pip2pi"><a href="#pip-安装-pip2pi" class="headerlink" title="pip 安装 pip2pi"></a>pip 安装 pip2pi</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pip2pi</span><br></pre></td></tr></table></figure>
<h3 id="制作一个-requirements-txt-文件"><a href="#制作一个-requirements-txt-文件" class="headerlink" title="制作一个 requirements.txt 文件"></a>制作一个 requirements.txt 文件</h3><p><code>vim /home/atompi/requirements.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-py</span><br></pre></td></tr></table></figure>
<h3 id="准备一个-packages-文件夹，作为存放本地源的路径"><a href="#准备一个-packages-文件夹，作为存放本地源的路径" class="headerlink" title="准备一个 packages 文件夹，作为存放本地源的路径"></a>准备一个 packages 文件夹，作为存放本地源的路径</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/atompi/pipackages</span><br></pre></td></tr></table></figure>
<h3 id="下载-pip-包"><a href="#下载-pip-包" class="headerlink" title="下载 pip 包"></a>下载 pip 包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip2pi /home/atompi/pipackages --no-use-wheel -r requirements.txt</span><br></pre></td></tr></table></figure>
<h3 id="复制-packages-目录和-requirements-txt-文件到不能连接外网的目标机器上"><a href="#复制-packages-目录和-requirements-txt-文件到不能连接外网的目标机器上" class="headerlink" title="复制 packages 目录和 requirements.txt 文件到不能连接外网的目标机器上"></a>复制 packages 目录和 requirements.txt 文件到不能连接外网的目标机器上</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r /home/atompi/pipackages atompi@192.168.1.131:/tmp/</span><br><span class="line">scp /home/atompi/requirements.txt atompi@192.168.1.131:/tmp/</span><br></pre></td></tr></table></figure>
<h3 id="开始离线安装"><a href="#开始离线安装" class="headerlink" title="开始离线安装"></a>开始离线安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --no-index --find-links=file:///tmp/pipackages/ -r /tmp/requirements.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最后，需要在gitlab容器中激活git用户</span><br><span class="line"></span><br><span class="line">passwd git</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL权限管理</title>
    <url>/2018/02/01/MySQL%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>以 root 用户登录 mysql ，创建 test 用户，并设置密码为 123456</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">create user test;</span><br><span class="line">update user set password=passworD(&quot;123456&quot;) where user=&#x27;test&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="赋予-test-用户相应权限"><a href="#赋予-test-用户相应权限" class="headerlink" title="赋予 test 用户相应权限"></a>赋予 test 用户相应权限</h2><ol>
<li>允许在某指定 ip 服务器操作</li>
</ol>
<p>所有权限，所有库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to test@&#x27;&lt;host&gt;&#x27; identified by &quot;123456&quot; with grant option;&lt;/host&gt;</span><br></pre></td></tr></table></figure>
<p>所有权限，指定库 testdb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all privileges on testdb.* to test@&#x27;&lt;host&gt;&#x27; identified by &quot;123456&quot; with grant option;&lt;/host&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>允许在任意服务器操作</li>
</ol>
<p>所有权限，所有库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to test@&#x27;localhost&#x27; identified by &quot;123456&quot; with grant option;</span><br><span class="line">grant all privileges on *.* to test@&#x27;%&#x27; identified by &quot;123456&quot; with grant option;</span><br></pre></td></tr></table></figure>
<p>所有权限，指定库 testdb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all privileges on testdb.* to test@&#x27;localhost&#x27; identified by &quot;123456&quot; with grant option;</span><br><span class="line">grant all privileges on testdb.* to test@&#x27;%&#x27; identified by &quot;123456&quot; with grant option;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all privileges 表示赋予除授权权限（ grant ）外所有权限</span><br><span class="line">with grant option 同时授予其给其他用户授权（ grant ）的权限， grant 语句末尾去掉 with grant option 即表示不授予其 grant 权限</span><br></pre></td></tr></table></figure>
<h2 id="权限表：（使用以上命令，在-grant-后指定以下权限，可实现-“用户-登录客户端-权限”-控制）"><a href="#权限表：（使用以上命令，在-grant-后指定以下权限，可实现-“用户-登录客户端-权限”-控制）" class="headerlink" title="权限表：（使用以上命令，在 grant 后指定以下权限，可实现 “用户-登录客户端-权限” 控制）"></a>权限表：（使用以上命令，在 grant 后指定以下权限，可实现 “用户-登录客户端-权限” 控制）</h2><p>|权限字段|作用域|权限详情<br>|——<br>|all privileges|服务器|除授权权限（ grant ）外所有权限<br>|USAGE|服务器|登录数据库权限<br>|CREATE|数据库、表或索引|创建数据库、表或索引权限<br>|DROP|数据库或表|删除数据库或表权限<br>|GRANT OPTION|服务器|赋予权限选项<br>|REFERENCES|数据库或表|将其它表的一个字段作为某一个表的外键约束<br>|ALTER|表|更改表，比如添加字段、索引等<br>|DELETE|表|删除数据权限<br>|INDEX|表|索引权限<br>|INSERT|表|插入权限<br>|SELECT|表|查询权限<br>|UPDATE|表|更新权限<br>|CREATE VIEW|视图|创建视图权限<br>|SHOW VIEW|视图|查看视图权限<br>|ALTER ROUTINE|存储过程|更改存储过程权限<br>|CREATE ROUTINE|存储过程|创建存储过程权限<br>|EXECUTE|存储过程|执行存储过程权限<br>|FILE|服务器|服务器主机上的文件访问<br>|CREATE TEMPORARY TABLES|服务器|创建临时表权限<br>|LOCK TABLES|服务器|锁表权限<br>|CREATE USER|服务器|创建用户权限<br>|PROCESS|服务器|查看进程权限<br>|RELOAD|服务器|执行flush-hosts, flush-logs, flush-privileges, flush-status, flush-tables, flush-threads, refresh, reload等命令的权限<br>|REPLICATION CLIENT|服务器|复制权限（客户端）<br>|REPLICATION SLAVE|服务器|复制权限（备用结点）<br>|SHOW DATABASES|服务器|查看数据库权限<br>|SHUTDOWN|服务器|关闭数据库权限<br>|SUPER|服务器|执行kill线程权限</p>
<h2 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看当前用户</span><br><span class="line">show grants;</span><br><span class="line"></span><br><span class="line"># 查看指定用户（某用户某远程地址）</span><br><span class="line">show grants for &#x27;test&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="回收权限（某用户某远程地址）"><a href="#回收权限（某用户某远程地址）" class="headerlink" title="回收权限（某用户某远程地址）"></a>回收权限（某用户某远程地址）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke delete on *.* from &#x27;test&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="刷新权限表"><a href="#刷新权限表" class="headerlink" title="刷新权限表"></a>刷新权限表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在执行以上权限更新命令后需要刷新权限表：</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h2 id="用户重命名"><a href="#用户重命名" class="headerlink" title="用户重命名"></a>用户重命名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename user &#x27;test&#x27;@&#x27;%&#x27; to &#x27;test2&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DBA</tag>
      </tags>
  </entry>
  <entry>
    <title>XtraBackup在线数据库不停机热备</title>
    <url>/2018/01/30/XtraBackup%E5%9C%A8%E7%BA%BF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%81%9C%E6%9C%BA%E7%83%AD%E5%A4%87/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>转载一下主从同步和XtraBackup的简介：</p>
<h2 id="MySQL主从同步原理"><a href="#MySQL主从同步原理" class="headerlink" title="MySQL主从同步原理"></a>MySQL主从同步原理</h2><p>MySQL主从同步是在MySQL主从复制(Master-Slave Replication)基础上实现的，通过设置在Master MySQL上的binlog(使其处于打开状态)，Slave MySQL上通过一个I&#x2F;O线程从Master MySQL上读取binlog，然后传输到Slave MySQL的中继日志中，然后Slave MySQL的SQL线程从中继日志中读取中继日志，然后应用到Slave MySQL的数据库中。这样实现了主从数据同步功能。</p>
<h2 id="XtraBackup备份原理"><a href="#XtraBackup备份原理" class="headerlink" title="XtraBackup备份原理"></a>XtraBackup备份原理</h2><p>innobackupex在后台线程不断追踪InnoDB的日志文件，然后复制InnoDB的数据文件。数据文件复制完成之后，日志的复制线程也会结束。这样就得到了不在同一时间点的数据副本和开始备份以后的事务日志。完成上面的步骤之后，就可以使用InnoDB崩溃恢复代码执行事务日志（redo log），以达到数据的一致性。</p>
<p>备份分为两个过程：</p>
<blockquote>
</blockquote>
<ol>
- backup，备份阶段，追踪事务日志和复制数据文件（物理备份）。
- preparing，重放事务日志，使所有的数据处于同一个时间点，达到一致性状态。
</ol>


<h2 id="XtraBackup的优点"><a href="#XtraBackup的优点" class="headerlink" title="XtraBackup的优点"></a>XtraBackup的优点</h2><blockquote>
</blockquote>
<ol>
- 可以快速可靠的完成数据备份（复制数据文件和追踪事务日志）
- 数据备份过程中不会中断事务的处理（热备份）
- 节约磁盘空间和网络带宽
- 自动完成备份鉴定
- 因更快的恢复时间而提高在线时间
</ol>


<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="完整的步骤"><a href="#完整的步骤" class="headerlink" title="完整的步骤"></a>完整的步骤</h2><blockquote>
</blockquote>
<ol>
- 主、从服务器上都搭好MySQL服务，从服务器上MySQL版本大于等于主服务器，最好完全一致
- 在要做主从同步的服务器上分别安装XtraBackup
- 如果从服务器上有MySQL实例，停掉服务，备份删除数据库内容，保留数据库目录
- 配置主从服务器打开主从同步功能
- 主服务器上执行备份
- 传输备份文件到从服务器，并同步数据文件（apply-log）
- 从服务器上恢复备份
- 主服务器上授权同步帐号
- 从服务器上设置MASTER并开启同步
- 查看主从同步状态
</ol>


<p>完成，可以检查同步状态了！</p>
<h2 id="具体操作过程"><a href="#具体操作过程" class="headerlink" title="具体操作过程"></a>具体操作过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master host: 192.168.2.11</span><br><span class="line">slave host: 192.168.2.12</span><br></pre></td></tr></table></figure>
<h3 id="一、主从服务器上搭建MySQL服务，并检查MySQL版本：-略"><a href="#一、主从服务器上搭建MySQL服务，并检查MySQL版本：-略" class="headerlink" title="一、主从服务器上搭建MySQL服务，并检查MySQL版本：(略)"></a>一、主从服务器上搭建MySQL服务，并检查MySQL版本：(略)</h3><h3 id="二、主从服务器上分别安装XtraBackup，根据官方网站指导使用打包好的二进制，选择最新的稳定版2-4："><a href="#二、主从服务器上分别安装XtraBackup，根据官方网站指导使用打包好的二进制，选择最新的稳定版2-4：" class="headerlink" title="二、主从服务器上分别安装XtraBackup，根据官方网站指导使用打包好的二进制，选择最新的稳定版2.4："></a>二、主从服务器上分别安装XtraBackup，根据官方网站指导使用打包好的二进制，选择最新的稳定版2.4：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># master &amp;amp; slave</span><br><span class="line">&amp;gt; wget https://repo.percona.com/apt/percona-release_0.1-4.$(lsb_release -sc)_all.deb</span><br><span class="line">&amp;gt; sudo dpkg -i percona-release_0.1-4.$(lsb_release -sc)_all.deb</span><br><span class="line">&amp;gt; sudo apt-get update</span><br><span class="line">&amp;gt; sudo apt-get install percona-xtrabackup-24</span><br></pre></td></tr></table></figure>
<h3 id="三、停掉从服务器上MySQL服务，备份原有数据库，并删除原有数据库内容：-可选，如果从服务器是新机器可以跳过"><a href="#三、停掉从服务器上MySQL服务，备份原有数据库，并删除原有数据库内容：-可选，如果从服务器是新机器可以跳过" class="headerlink" title="三、停掉从服务器上MySQL服务，备份原有数据库，并删除原有数据库内容：(可选，如果从服务器是新机器可以跳过)"></a>三、停掉从服务器上MySQL服务，备份原有数据库，并删除原有数据库内容：(可选，如果从服务器是新机器可以跳过)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;gt; mysqldump -u$USER -p$PASSWORD --routines --default-character-set=utf8 --locak-all-tables --add-drop-database -A dball.sql</span><br><span class="line">&amp;gt; sudo pkill mysql</span><br><span class="line">&amp;gt; sudo cd /data/mysql</span><br><span class="line"># 下面这句千万别打错了，后果会很严重</span><br><span class="line">&amp;gt; sudo rm -rf *</span><br></pre></td></tr></table></figure>
<h3 id="四、配置MySQL打开主从同步功能"><a href="#四、配置MySQL打开主从同步功能" class="headerlink" title="四、配置MySQL打开主从同步功能"></a>四、配置MySQL打开主从同步功能</h3><p>主服务器上编辑<code>/etc/mysql/my.conf</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 注意主从之间的server-id不能相同</span><br><span class="line">server-id=1</span><br><span class="line">log_bin=/var/log/mysql/mysql-bin.log</span><br></pre></td></tr></table></figure>
<h4 id="master-my-cnf"><a href="#master-my-cnf" class="headerlink" title="master my.cnf"></a>master my.cnf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># The MySQL database server configuration file.</span><br><span class="line">#</span><br><span class="line"># You can copy this to one of:</span><br><span class="line"># - &quot;/etc/mysql/my.cnf&quot; to set global options,</span><br><span class="line"># - &quot;~/.my.cnf&quot; to set user-specific options.</span><br><span class="line">#</span><br><span class="line"># One can use all long options that the program supports.</span><br><span class="line"># Run program with --help to get a list of available options and with</span><br><span class="line"># --print-defaults to see which it would actually understand and use.</span><br><span class="line">#</span><br><span class="line"># For explanations see</span><br><span class="line"># http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span><br><span class="line"></span><br><span class="line"># This will be passed to all mysql clients</span><br><span class="line"># It has been reported that passwords should be enclosed with ticks/quotes</span><br><span class="line"># escpecially if they contain &quot;#&quot; chars...</span><br><span class="line"># Remember to edit /etc/mysql/debian.cnf when changing the socket location.</span><br><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">#user=zabbix</span><br><span class="line">#host=localhost</span><br><span class="line">#password=</span><br><span class="line"></span><br><span class="line"># Here is entries for some specific programs</span><br><span class="line"># The following values assume you have at least 32M ram</span><br><span class="line"></span><br><span class="line"># This was formally known as [safe_mysqld]. Both versions are currently parsed.</span><br><span class="line">[mysqld_safe]</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">nice=0</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># * Basic Settings</span><br><span class="line">#</span><br><span class="line">user=mysql</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">port=3306</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/data/mysql</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">#lc-messages-dir=/usr/share/mysql</span><br><span class="line">skip-external-locking</span><br><span class="line"></span><br><span class="line">max_connections=1000</span><br><span class="line"></span><br><span class="line">event_scheduler=ON</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line">#</span><br><span class="line"># Instead of skip-networking the default is now to listen only on</span><br><span class="line"># localhost which is more compatible and is not less secure.</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">#</span><br><span class="line"># * Fine Tuning</span><br><span class="line">#</span><br><span class="line">key_buffer=512M</span><br><span class="line">max_allowed_packet=64M</span><br><span class="line">thread_stack=192K</span><br><span class="line">thread_cache_size=24</span><br><span class="line"># This replaces the startup script and checks MyISAM tables if needed</span><br><span class="line"># the first time they are touched</span><br><span class="line">myisam-recover=BACKUP</span><br><span class="line">#max_connections        = 100</span><br><span class="line">#table_cache            = 64</span><br><span class="line">#thread_concurrency     = 10</span><br><span class="line">#</span><br><span class="line"># * Query Cache Configuration</span><br><span class="line">#</span><br><span class="line">query_cache_limit=16M</span><br><span class="line">query_cache_size=128M</span><br><span class="line">#</span><br><span class="line"># * Logging and Replication</span><br><span class="line">#</span><br><span class="line"># Both location gets rotated by the cronjob.</span><br><span class="line"># Be aware that this log type is a performance killer.</span><br><span class="line"># As of 5.1 you can enable the log at runtime!</span><br><span class="line">#general_log_file        = /var/log/mysql/mysql.log</span><br><span class="line">#general_log             = 1</span><br><span class="line">#</span><br><span class="line"># Error log - should be very few entries.</span><br><span class="line">#</span><br><span class="line">log_error=/var/log/mysql/error.log</span><br><span class="line">#</span><br><span class="line"># Here you can see queries with especially long duration</span><br><span class="line">#log_slow_queries    = /var/log/mysql/mysql-slow.log</span><br><span class="line">#long_query_time = 2</span><br><span class="line">#log-queries-not-using-indexes</span><br><span class="line">#</span><br><span class="line"># The following can be used as easy to replay backup logs or for replication.</span><br><span class="line"># note: if you are setting up a replication slave, see README.Debian about</span><br><span class="line">#       other settings you may need to change.</span><br><span class="line">#server-id        = 1</span><br><span class="line">#log_bin            = /var/log/mysql/mysql-bin.log</span><br><span class="line">expire_logs_days=10</span><br><span class="line">max_binlog_size=100M</span><br><span class="line">#binlog_do_db        = include_database_name</span><br><span class="line">#binlog_ignore_db    = include_database_name</span><br><span class="line">#</span><br><span class="line"># * InnoDB</span><br><span class="line">#</span><br><span class="line"># InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.</span><br><span class="line"># Read the manual for more InnoDB related options. There are many!</span><br><span class="line">#</span><br><span class="line"># * Security Features</span><br><span class="line">#</span><br><span class="line"># Read the manual, too, if you want chroot!</span><br><span class="line"># chroot = /var/lib/mysql/</span><br><span class="line">#</span><br><span class="line"># For generating SSL certificates I recommend the OpenSSL GUI &quot;tinyca&quot;.</span><br><span class="line">#</span><br><span class="line"># ssl-ca=/etc/mysql/cacert.pem</span><br><span class="line"># ssl-cert=/etc/mysql/server-cert.pem</span><br><span class="line"># ssl-key=/etc/mysql/server-key.pem</span><br><span class="line"></span><br><span class="line">innodb_file_per_table=1</span><br><span class="line">innodb_open_files=2048</span><br><span class="line"></span><br><span class="line">innodb_log_group_home_dir=/data/mysql</span><br><span class="line">innodb_buffer_pool_instances=24</span><br><span class="line">innodb_buffer_pool_size=24G</span><br><span class="line">innodb_additional_mem_pool_size=64M</span><br><span class="line">innodb_log_file_size=64M</span><br><span class="line">innodb_lock_wait_timeout=50</span><br><span class="line">innodb_flush_log_at_trx_commit=0</span><br><span class="line">### small swap / IO</span><br><span class="line">innodb_flush_method=O_DIRECT</span><br><span class="line">innodb_write_io_threads=16</span><br><span class="line">innodb_read_io_threads=16</span><br><span class="line">innodb_thread_concurrency=16</span><br><span class="line">innodb_log_files_in_group=3</span><br><span class="line">innodb_max_dirty_pages_pct=90</span><br><span class="line"></span><br><span class="line">skip-name-resolve</span><br><span class="line">slow_query_log</span><br><span class="line">long_query_time=0.1</span><br><span class="line"></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_format=mixed</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">#auto-increment-increment=2</span><br><span class="line">#auto-increment-offset=1</span><br><span class="line">server-id=1</span><br><span class="line">log_slave_updates=1</span><br><span class="line">read_only=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">quote-names</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">#no-auto-rehash    # faster start of mysql but no tab completition</span><br><span class="line"></span><br><span class="line">[isamchk]</span><br><span class="line">key_buffer=16M</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># * IMPORTANT: Additional settings that can override those from this file!</span><br><span class="line">#   The files must end with &#x27;.cnf&#x27;, otherwise they&#x27;ll be ignored.</span><br><span class="line">#</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure>
<p>如果主服务器上MySQL是已经上线的系统，需要重启一下（实测&#x2F;etc&#x2F;init.d&#x2F;mysql reload不起作用）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;gt; sudo pkill mysql</span><br><span class="line">&amp;gt; cd /usr/local/mysql</span><br><span class="line">&amp;gt; sudo bin/mysqld_safe --user=mysql --datadir=/data/mysql --pid-file=/var/run/mysqld/mysqld.pid &amp;amp;</span><br></pre></td></tr></table></figure>
<p>从服务器上编辑&#x2F;etc&#x2F;mysql&#x2F;my.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 注意主从之间的server-id不能相同</span><br><span class="line">server-id=2</span><br><span class="line"># 最好设置从服务器为只读</span><br><span class="line"># 注意：即使这里设置了只读，使用具有super权限的用户登录，也还是可以做写操作的</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>
<h4 id="slave-my-cnf"><a href="#slave-my-cnf" class="headerlink" title="slave my.cnf"></a>slave my.cnf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># The MySQL database server configuration file.</span><br><span class="line">#</span><br><span class="line"># You can copy this to one of:</span><br><span class="line"># - &quot;/etc/mysql/my.cnf&quot; to set global options,</span><br><span class="line"># - &quot;~/.my.cnf&quot; to set user-specific options.</span><br><span class="line">#</span><br><span class="line"># One can use all long options that the program supports.</span><br><span class="line"># Run program with --help to get a list of available options and with</span><br><span class="line"># --print-defaults to see which it would actually understand and use.</span><br><span class="line">#</span><br><span class="line"># For explanations see</span><br><span class="line"># http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span><br><span class="line"></span><br><span class="line"># This will be passed to all mysql clients</span><br><span class="line"># It has been reported that passwords should be enclosed with ticks/quotes</span><br><span class="line"># escpecially if they contain &quot;#&quot; chars...</span><br><span class="line"># Remember to edit /etc/mysql/debian.cnf when changing the socket location.</span><br><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">#user=zabbix</span><br><span class="line">#host=localhost</span><br><span class="line">#password=</span><br><span class="line"></span><br><span class="line"># Here is entries for some specific programs</span><br><span class="line"># The following values assume you have at least 32M ram</span><br><span class="line"></span><br><span class="line"># This was formally known as [safe_mysqld]. Both versions are currently parsed.</span><br><span class="line">[mysqld_safe]</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">nice=0</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># * Basic Settings</span><br><span class="line">#</span><br><span class="line">user=mysql</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">port=3306</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/data/mysql</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">#lc-messages-dir=/usr/share/mysql</span><br><span class="line">skip-external-locking</span><br><span class="line"></span><br><span class="line">max_connections=1000</span><br><span class="line"></span><br><span class="line">event_scheduler=ON</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line">#</span><br><span class="line"># Instead of skip-networking the default is now to listen only on</span><br><span class="line"># localhost which is more compatible and is not less secure.</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">#</span><br><span class="line"># * Fine Tuning</span><br><span class="line">#</span><br><span class="line">key_buffer=512M</span><br><span class="line">max_allowed_packet=64M</span><br><span class="line">thread_stack=192K</span><br><span class="line">thread_cache_size=24</span><br><span class="line"># This replaces the startup script and checks MyISAM tables if needed</span><br><span class="line"># the first time they are touched</span><br><span class="line">myisam-recover=BACKUP</span><br><span class="line">#max_connections        = 100</span><br><span class="line">#table_cache            = 64</span><br><span class="line">#thread_concurrency     = 10</span><br><span class="line">#</span><br><span class="line"># * Query Cache Configuration</span><br><span class="line">#</span><br><span class="line">query_cache_limit=16M</span><br><span class="line">query_cache_size=128M</span><br><span class="line">#</span><br><span class="line"># * Logging and Replication</span><br><span class="line">#</span><br><span class="line"># Both location gets rotated by the cronjob.</span><br><span class="line"># Be aware that this log type is a performance killer.</span><br><span class="line"># As of 5.1 you can enable the log at runtime!</span><br><span class="line">#general_log_file        = /var/log/mysql/mysql.log</span><br><span class="line">#general_log             = 1</span><br><span class="line">#</span><br><span class="line"># Error log - should be very few entries.</span><br><span class="line">#</span><br><span class="line">log_error=/var/log/mysql/error.log</span><br><span class="line">#</span><br><span class="line"># Here you can see queries with especially long duration</span><br><span class="line">#log_slow_queries    = /var/log/mysql/mysql-slow.log</span><br><span class="line">#long_query_time = 2</span><br><span class="line">#log-queries-not-using-indexes</span><br><span class="line">#</span><br><span class="line"># The following can be used as easy to replay backup logs or for replication.</span><br><span class="line"># note: if you are setting up a replication slave, see README.Debian about</span><br><span class="line">#       other settings you may need to change.</span><br><span class="line">#server-id        = 1</span><br><span class="line">#log_bin            = /var/log/mysql/mysql-bin.log</span><br><span class="line">expire_logs_days=10</span><br><span class="line">max_binlog_size=100M</span><br><span class="line">#binlog_do_db        = include_database_name</span><br><span class="line">#binlog_ignore_db    = include_database_name</span><br><span class="line">#</span><br><span class="line"># * InnoDB</span><br><span class="line">#</span><br><span class="line"># InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.</span><br><span class="line"># Read the manual for more InnoDB related options. There are many!</span><br><span class="line">#</span><br><span class="line"># * Security Features</span><br><span class="line">#</span><br><span class="line"># Read the manual, too, if you want chroot!</span><br><span class="line"># chroot = /var/lib/mysql/</span><br><span class="line">#</span><br><span class="line"># For generating SSL certificates I recommend the OpenSSL GUI &quot;tinyca&quot;.</span><br><span class="line">#</span><br><span class="line"># ssl-ca=/etc/mysql/cacert.pem</span><br><span class="line"># ssl-cert=/etc/mysql/server-cert.pem</span><br><span class="line"># ssl-key=/etc/mysql/server-key.pem</span><br><span class="line"></span><br><span class="line">innodb_file_per_table=1</span><br><span class="line">innodb_open_files=2048</span><br><span class="line"></span><br><span class="line">innodb_log_group_home_dir=/data/mysql</span><br><span class="line">innodb_buffer_pool_instances=24</span><br><span class="line">innodb_buffer_pool_size=24G</span><br><span class="line">innodb_additional_mem_pool_size=64M</span><br><span class="line">innodb_log_file_size=64M</span><br><span class="line">innodb_lock_wait_timeout=50</span><br><span class="line">innodb_flush_log_at_trx_commit=0</span><br><span class="line">### small swap / IO</span><br><span class="line">innodb_flush_method=O_DIRECT</span><br><span class="line">innodb_write_io_threads=16</span><br><span class="line">innodb_read_io_threads=16</span><br><span class="line">innodb_thread_concurrency=16</span><br><span class="line">innodb_log_files_in_group=3</span><br><span class="line">innodb_max_dirty_pages_pct=90</span><br><span class="line"></span><br><span class="line">skip-name-resolve</span><br><span class="line">slow_query_log</span><br><span class="line">long_query_time=0.1</span><br><span class="line"></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_format=mixed</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">#auto-increment-increment=2</span><br><span class="line">#auto-increment-offset=1</span><br><span class="line">server-id=2</span><br><span class="line">log_slave_updates=1</span><br><span class="line">read_only=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">quote-names</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">#no-auto-rehash    # faster start of mysql but no tab completition</span><br><span class="line"></span><br><span class="line">[isamchk]</span><br><span class="line">key_buffer=16M</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># * IMPORTANT: Additional settings that can override those from this file!</span><br><span class="line">#   The files must end with &#x27;.cnf&#x27;, otherwise they&#x27;ll be ignored.</span><br><span class="line">#</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure>
<p>查询主从服务器状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;gt; mysql -uroot -p -e &quot;show global variables like &#x27;server_id&#x27;;&quot;</span><br><span class="line">    +---------------+-------+</span><br><span class="line">    | Variable_name | Value |</span><br><span class="line">    +---------------+-------+</span><br><span class="line">    | server_id     | 1     |</span><br><span class="line">    +---------------+-------+</span><br><span class="line"></span><br><span class="line">&amp;gt; mysql -uroot -p -e &quot;show global variables like &#x27;log_bin&#x27;;&quot;</span><br><span class="line">    +---------------+-------+</span><br><span class="line">    | Variable_name | Value |</span><br><span class="line">    +---------------+-------+</span><br><span class="line">    | log_bin       | ON    |</span><br><span class="line">    +---------------+-------+</span><br></pre></td></tr></table></figure>
<h3 id="五、主服务器上执行备份操作"><a href="#五、主服务器上执行备份操作" class="headerlink" title="五、主服务器上执行备份操作"></a>五、主服务器上执行备份操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;gt; sudo innobackupex --defaults-file=/etc/mysql/my.cnf --user=root --password=$PASSWORD --parallel=4 /tmp/mybackup</span><br></pre></td></tr></table></figure>
<p>命令输出的最后几行通常类似这样：</p>
<p>innobackupex: Backup created in directory ‘&#x2F;tmp&#x2F;mybackup&#x2F;2017-05-12_17-41-51’<br/>innobackupex: MySQL binlog position: filename ‘mysql-bin.000003’, position 1946<br/>111225 00:00:53 innobackupex: completed OK!</p>
<p>命令执行完在<code>/tmp/mybackup</code>目录下生成的<code>2017-05-12_17-41-51</code>目录，里面存储的是备份的数据，下一步要传输到从服务器上的即是这个文件夹。</p>
<p>输出中的<code>MySQL binlog position: filename &#39;mysql-bin.000003&#39;, position 1946</code>里面的两个数字，要记录以下，后面恢复到从服务器上的时候要用到。</p>
<h3 id="六、传输并同步备份数据"><a href="#六、传输并同步备份数据" class="headerlink" title="六、传输并同步备份数据"></a>六、传输并同步备份数据</h3><p>读取备份数据需要ROOT权限，下面的命令需要使用sudo执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;gt; sudo scp -r /tmp/mybackup git@192.168.2.12:/tmp/</span><br></pre></td></tr></table></figure>
<p>在从服务器上执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;gt; sudo innobackupex --apply-log /tmp/mybackup/2017-05-12</span><br></pre></td></tr></table></figure>
<h3 id="七、从服务器上恢复备份数据"><a href="#七、从服务器上恢复备份数据" class="headerlink" title="七、从服务器上恢复备份数据"></a>七、从服务器上恢复备份数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 恢复数据</span><br><span class="line">&amp;gt; sudo innobackupex --defaults-file=/etc/mysql/my.cnf --user=root --password=$PASSWORD --copy-back /tmp/mybackup/2017-05-12/</span><br><span class="line"># 需要恢复权限给mysql</span><br><span class="line">&amp;gt; sudo chown -R mysql:mysql /data/mysql</span><br><span class="line"># 启动MySQL</span><br><span class="line">&amp;gt; cd /usr/local/mysql</span><br><span class="line">&amp;gt; sudo bin/mysqld_safe --user=mysql --datadir=/data/mysql --pid-file=/var/run/mysqld/mysqld.pid &amp;amp;</span><br></pre></td></tr></table></figure>
<h3 id="八、主服务器上授权同步帐号"><a href="#八、主服务器上授权同步帐号" class="headerlink" title="八、主服务器上授权同步帐号"></a>八、主服务器上授权同步帐号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;gt; mysql -u$USER -p$PASSWORD</span><br><span class="line">&amp;gt; create user slave@&#x27;192.168.2.12&#x27; identified by &#x27;password&#x27;;</span><br><span class="line">&amp;gt; grant replication slave on *.* to &#x27;slave&#x27;@&#x27;192.168.2.12&#x27; identified by &#x27;password&#x27;;</span><br><span class="line">&amp;gt; flush privileges;</span><br><span class="line">&amp;gt; select distinct concat(&#x27;User: &#x27;&#x27;&#x27;,user,&#x27;&#x27;&#x27;@&#x27;&#x27;&#x27;,host,&#x27;&#x27;&#x27;;&#x27;) as query from mysql.user;</span><br><span class="line">&amp;gt; exit</span><br></pre></td></tr></table></figure>
<p>倒数第二条语句查询当前数据库中的用户信息，检查slave是否在其中。</p>
<h3 id="九、配置从服务器开启同步"><a href="#九、配置从服务器开启同步" class="headerlink" title="九、配置从服务器开启同步"></a>九、配置从服务器开启同步</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u$USER -p$PASSWORD</span><br><span class="line">&amp;gt; change master to</span><br><span class="line">&amp;gt; master_host = &#x27;192.168.2.11&#x27;,</span><br><span class="line">&amp;gt; master_user = &#x27;slave&#x27;,</span><br><span class="line">&amp;gt; master_password = &#x27;password&#x27;,</span><br><span class="line">&amp;gt; master_port = 3306,</span><br><span class="line">&amp;gt; master_log_file = &#x27;mysql-bin.000003&#x27;,</span><br><span class="line">&amp;gt; master_log_pos = 1946;</span><br><span class="line">&amp;gt; start slave;</span><br></pre></td></tr></table></figure>
<h3 id="十、查看主从同步状态"><a href="#十、查看主从同步状态" class="headerlink" title="十、查看主从同步状态"></a>十、查看主从同步状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># master</span><br><span class="line">&amp;gt; mysql -u$USER -p -e &quot;show master status \G;&quot;</span><br><span class="line">&amp;gt; mysql -u$USER -p -e &quot;show processlist \G;&quot; | grep -i &#x27;master&#x27;</span><br><span class="line"># 第二条输出是否类似“State: Master has sent all binlog to slave; waiting for binlog to be updated”这样。</span><br><span class="line"></span><br><span class="line"># slave</span><br><span class="line">&amp;gt; mysql -u$USER -p -e &quot;show slave status \G;&quot;</span><br><span class="line"># 输出是否包含类似下面这样的语句:</span><br><span class="line">    Slave_IO_State: Waiting for master to send event</span><br><span class="line">    Slave_IO_Running: Yes</span><br><span class="line">    Slave_SQL_Running: Yes</span><br><span class="line">    Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it</span><br><span class="line"></span><br><span class="line">&amp;gt; mysql -u$USER -p -e &quot;show processlist \G;&quot; | egrep -i &#x27;(master|slave)&#x27;</span><br><span class="line"># 输出包含类似以下内容：</span><br><span class="line">    State: Waiting for master to send event</span><br><span class="line">    State: Slave has read all relay log; waiting for the slave I/O thread to update it</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DBA</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 各版本镜像列表</title>
    <url>/2018/07/29/kubernetes%E5%90%84%E7%89%88%E6%9C%AC%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>以下镜像列表由 kubeadm v1.11.1 导出，若使用预下载镜像离线部署的方式部署，请使用 kubeadm v1.11.1 版本</strong></p>
<p><strong>导出各版本镜像列表（需要科学上网）：</strong></p>
<p><code>kubeadm config images list --kubernetes-version=v1.11.1</code></p>
<h2 id="插件镜像"><a href="#插件镜像" class="headerlink" title="插件镜像"></a>插件镜像</h2><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quay.io/coreos/flannel:v0.10.0-amd64</span><br><span class="line">gcr.io/kubernetes-helm/tiller:v2.9.1</span><br><span class="line">k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3</span><br><span class="line">gcr.io/google_containers/heapster-amd64:v1.5.4</span><br><span class="line">gcr.io/google_containers/heapster-influxdb-amd64:v1.5.2</span><br><span class="line">gcr.io/google_containers/heapster-grafana-amd64:v5.0.4</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># flannel:v0.10.0-amd64 占位</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.9.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64:v1.8.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/heapster-amd64:v1.5.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/heapster-influxdb-amd64:v1.5.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/heapster-grafana-amd64:v5.0.4</span><br></pre></td></tr></table></figure>
<h2 id="核心镜像"><a href="#核心镜像" class="headerlink" title="核心镜像"></a>核心镜像</h2><h3 id="v1-10-0"><a href="#v1-10-0" class="headerlink" title="v1.10.0"></a>v1.10.0</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.0</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.0</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.0</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<h3 id="v1-10-1"><a href="#v1-10-1" class="headerlink" title="v1.10.1"></a>v1.10.1</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.1</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.1</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.1</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.1</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<h3 id="v1-10-2"><a href="#v1-10-2" class="headerlink" title="v1.10.2"></a>v1.10.2</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.2</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.2</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.2</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.2</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<h3 id="v1-10-3"><a href="#v1-10-3" class="headerlink" title="v1.10.3"></a>v1.10.3</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.3</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<h3 id="v1-10-4"><a href="#v1-10-4" class="headerlink" title="v1.10.4"></a>v1.10.4</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.4</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.4</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.4</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.4</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.4</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<h3 id="v1-10-5"><a href="#v1-10-5" class="headerlink" title="v1.10.5"></a>v1.10.5</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.5</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.5</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.5</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.5</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.5</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.5</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.5</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.5</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<h3 id="v1-10-6"><a href="#v1-10-6" class="headerlink" title="v1.10.6"></a>v1.10.6</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.6</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.6</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.6</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.6</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.6</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.6</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.6</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.6</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<h3 id="v1-11-0"><a href="#v1-11-0" class="headerlink" title="v1.11.0"></a>v1.11.0</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.11.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.11.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.11.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.11.0</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.2.18</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<h3 id="v1-11-1"><a href="#v1-11-1" class="headerlink" title="v1.11.1"></a>v1.11.1</h3><ul>
<li>官方镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>
<ul>
<li>阿里云镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.11.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.11.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.11.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.11.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.2.18</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.1.3</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>pip 使用国内镜像源安装依赖包</title>
    <url>/2018/01/04/pip%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85/</url>
    <content><![CDATA[<h2 id="全局配置目录"><a href="#全局配置目录" class="headerlink" title="全局配置目录"></a>全局配置目录</h2><p>在 linux 默认的路径是 : <code>$HOME/.pip/pip.conf</code></p>
<p>在 windows 默认的路径是 : <code>%HOME%\pip\pip.ini</code></p>
<h2 id="全局配置国内镜像源"><a href="#全局配置国内镜像源" class="headerlink" title="全局配置国内镜像源"></a>全局配置国内镜像源</h2><p>默认路径下并不存在配置文件，需要新建，然后在配置文件中写入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure>
<p>即可修改镜像源，等号之后的部分就是镜像源的地址。</p>
<h2 id="推荐的国内镜像源"><a href="#推荐的国内镜像源" class="headerlink" title="推荐的国内镜像源"></a>推荐的国内镜像源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">阿里云 : http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 : https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">豆瓣 : http://pypi.douban.com/simple/</span><br><span class="line">中国科学院 : http://pypi.mirrors.opencas.cn/simple/</span><br><span class="line">清华大学 : https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>
<h2 id="临时使用镜像源"><a href="#临时使用镜像源" class="headerlink" title="临时使用镜像源"></a>临时使用镜像源</h2><p>临时使用镜像源很简单，用-i指定就行了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo easy_install ansible -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class="line">sudo pip install ansible -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 Desktop 初始化</title>
    <url>/2018/03/05/ubuntu16.04-desktop%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>安装完 Ubuntu 16.04 Desktop 后执行以下命令，会让你得到一个干净、完整的开发环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 选择阿里云源</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade -y</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install shadowsocks-qt5 -y</span><br><span class="line">sudo apt install ssh</span><br><span class="line">sudo apt install python-pip</span><br><span class="line">sudo apt install curl</span><br><span class="line">sudo pip install genpac</span><br><span class="line">sudo apt install vim</span><br><span class="line">sudo apt-get install exfat-utils</span><br><span class="line"></span><br><span class="line">cd Documents/</span><br><span class="line">mkdir autoproxy</span><br><span class="line">cd autoproxy/</span><br><span class="line">vim ~/Documents/autoproxy/user-rules.txt</span><br><span class="line">vim ~/Documents/autoproxy/update.sh</span><br><span class="line"># 配置 shadowsocks-qt5</span><br><span class="line">cd ~/Documents/autoproxy/</span><br><span class="line">bash update.sh</span><br><span class="line"># 配置系统代理</span><br><span class="line"></span><br><span class="line">sudo apt-get install privoxy -y</span><br><span class="line">sudo mv /etc/privoxy/config /etc/privoxy/config.bak</span><br><span class="line">sudo vim /etc/privoxy/config</span><br><span class="line">sudo systemctl start privoxy</span><br><span class="line">sudo systemctl enable privoxy</span><br><span class="line">sudo vim /usr/local/bin/proxy</span><br><span class="line">sudo chmod +x /usr/local/bin/proxy</span><br><span class="line"></span><br><span class="line">sudo apt-get remove libreoffice*</span><br><span class="line">sudo apt-get remove unity-webapps-common</span><br><span class="line">sudo apt-get remove gnome-mahjongg gnome-sudoku gnome-mines</span><br><span class="line">sudo apt remove aisleriot</span><br><span class="line">sudo apt autoremove</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line">sudo dpkg -i google-chrome-stable_current_amd64.deb</span><br><span class="line"># 安装 jdk</span><br><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/local/jdk1.8.0_152/bin/java 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /usr/local/jdk1.8.0_152/bin/javac 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/jar jar /usr/local/jdk1.8.0_152/bin/jar 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/javah javah /usr/local/jdk1.8.0_152/bin/javah 300</span><br><span class="line">sudo update-alternatives --install /usr/bin/javap javap /usr/local/jdk1.8.0_152/bin/javap 300</span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line">sudo apt install zsh</span><br><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo proxy apt install git</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get -y install docker-ce</span><br><span class="line">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#x27;EOF&#x27;\n&#123;\n  &quot;registry-mirrors&quot;: [&quot;https://gfty7g09.mirror.aliyuncs.com&quot;]\n&#125;\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker</span><br><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class="line"></span><br><span class="line">docker run -d -p 1337:1337 --restart=always --name=idealicsrv idealicsrv:1.0.0</span><br><span class="line">sudo apt-get install -y cmake build-essential libreadline6-dev libncurses5-dev</span><br><span class="line"></span><br><span class="line">docker pull redis:3.2.11</span><br><span class="line">docker pull mysql:5.7.21</span><br><span class="line">docker run -d -p 3306:3306 --name=mysql -e MYSQL_ROOT_PASSWORD=atompi123 mysql:5.7.21 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">docker run -d -p 6379:6379 --name=redis redis:3.2.11</span><br><span class="line">sudo apt install libmysqlclient-dev</span><br><span class="line"></span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">sudo add-apt-repository &#x27;deb http://typora.io linux/&#x27;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install typora</span><br><span class="line">sudo add-apt-repository -r &#x27;deb http://typora.io linux/&#x27;</span><br><span class="line">sudo add-apt-repository -r &#x27;ppa:hzwhuang/ss-qt5&#x27;</span><br><span class="line"></span><br><span class="line">anaconda3/bin/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">anaconda3/bin/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">anaconda3/bin/conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<h2 id="Documents-autoproxy-user-rules-txt"><a href="#Documents-autoproxy-user-rules-txt" class="headerlink" title="~&#x2F;Documents&#x2F;autoproxy&#x2F;user-rules.txt"></a>~&#x2F;Documents&#x2F;autoproxy&#x2F;user-rules.txt</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! 用户自定义规则语法:</span><br><span class="line">!</span><br><span class="line">!   与gfwlist相同，使用AdBlock Plus过滤规则( http://adblockplus.org/en/filters )</span><br><span class="line">!</span><br><span class="line">!     1. 通配符支持，如 *.example.com/* 实际书写时可省略*为 .example.com/</span><br><span class="line">!     2. 正则表达式支持，以\开始和结束， 如 \[\w]+:\/\/example.com\\</span><br><span class="line">!     3. 例外规则 @@，如 @@*.example.com/* 满足@@后规则的地址不使用代理</span><br><span class="line">!     4. 匹配地址开始和结尾 |，如 |http://example.com、example.com|分别表示以http://example.com开始和以example.com结束的地址</span><br><span class="line">!     5. || 标记，如 ||example.com 则http://example.com、https://example.com、ftp://example.com等地址均满足条件</span><br><span class="line">!     6. 注释 ! 如 ! Comment</span><br><span class="line">!</span><br><span class="line">!   配置自定义规则时需谨慎，尽量避免与gfwlist产生冲突，或将一些本不需要代理的网址添加到代理列表</span><br><span class="line">!</span><br><span class="line">!   规则优先级从高到底为: user-rule &amp;gt; user-rule-from &amp;gt; gfwlist</span><br><span class="line">!</span><br><span class="line">! Tip:</span><br><span class="line">!   如果生成的是PAC文件，用户定义规则先于gfwlist规则被处理</span><br><span class="line">!   因此可以在这里添加例外或常用网址规则，或能减少在访问这些网址进行查询的时间, 如下面的例子</span><br><span class="line">!</span><br><span class="line">!   但其它格式如wingy, dnsmasq则无此必要, 例外规则将被忽略, 所有规则将被排序</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line">@@sina.com</span><br><span class="line">@@163.com</span><br><span class="line"></span><br><span class="line">twitter.com</span><br><span class="line">youtube.com</span><br><span class="line">||google.com</span><br><span class="line">||wikipedia.org</span><br></pre></td></tr></table></figure>
<h2 id="Documents-autoproxy-update-sh"><a href="#Documents-autoproxy-update-sh" class="headerlink" title="~&#x2F;Documents&#x2F;autoproxy&#x2F;update.sh"></a>~&#x2F;Documents&#x2F;autoproxy&#x2F;update.sh</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">genpac --pac-proxy &quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=&quot;autoproxy.pac&quot; --user-rule-from=&quot;user-rules.txt&quot;</span><br></pre></td></tr></table></figure>
<h2 id="etc-privoxy-config"><a href="#etc-privoxy-config" class="headerlink" title="&#x2F;etc&#x2F;privoxy&#x2F;config"></a>&#x2F;etc&#x2F;privoxy&#x2F;config</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 转发地址</span><br><span class="line">forward-socks5   /               127.0.0.1:1080 .</span><br><span class="line"># 监听地址</span><br><span class="line">listen-address  localhost:8118</span><br><span class="line"># local network do not use proxy</span><br><span class="line">forward         192.168.*.*/     .</span><br><span class="line">forward            10.*.*.*/     .</span><br><span class="line">forward           127.*.*.*/     .</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">http_proxy=http://127.0.0.1:8118 https_proxy=http://127.0.0.1:8118 $*</span><br></pre></td></tr></table></figure>
<h2 id="zshrc-alias"><a href="#zshrc-alias" class="headerlink" title="~&#x2F;.zshrc alias"></a>~&#x2F;.zshrc alias</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xinput set-prop $(xinput list|grep &quot;AT Translated Set 2 keyboard&quot;|awk &#x27;&#123;print $7&#125;&#x27;|cut -d &#x27;=&#x27; -f 2) &quot;Device Enabled&quot; 0</span><br><span class="line"></span><br><span class="line">alias mysql=&quot;docker run -it --rm mysql:5.7.21 mysql $@&quot;</span><br><span class="line">alias redis-cli=&quot;docker run -it --rm redis:3.2.11 redis-cli $@&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 CoreDNS 作为数据中心内网 DNS 服务器</title>
    <url>/2020/08/02/%E4%BD%BF%E7%94%A8CoreDNS%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E5%86%85%E7%BD%91DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="创建配置文件持久化目录，并复制配置文件"><a href="#创建配置文件持久化目录，并复制配置文件" class="headerlink" title="创建配置文件持久化目录，并复制配置文件"></a>创建配置文件持久化目录，并复制配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/coredns/zones</span><br><span class="line">cp hosts /data/coredns/</span><br><span class="line"># 以添加 zone atompi.cc 为例：</span><br><span class="line">mkdir -p /data/coredns/zones/atompi.cc</span><br><span class="line">cp db.atompi.cc /data/coredns/zones/atompi.cc/</span><br><span class="line">cp Corefile /data/coredns/</span><br></pre></td></tr></table></figure>
<p>各配置文件示例：</p>
<ul>
<li><code>Corefile</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.:53 &#123;</span><br><span class="line">    forward . 223.5.5.5 223.6.6.6</span><br><span class="line">    reload 10s</span><br><span class="line">    loop</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    cache 30</span><br><span class="line"></span><br><span class="line">    hosts /data/hosts &#123;</span><br><span class="line">        ttl 10</span><br><span class="line">        reload 10s</span><br><span class="line">        no_reverse</span><br><span class="line">        fallthrough</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">atompi.cc &#123;</span><br><span class="line">    forward . 223.5.5.5 223.6.6.6</span><br><span class="line">    loop</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    cache 30</span><br><span class="line"></span><br><span class="line">    auto &#123;</span><br><span class="line">        directory /data/zones/atompi.cc</span><br><span class="line">        reload 10s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hosts</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.1.2 www.test.com</span><br></pre></td></tr></table></figure>
<ul>
<li><code>db.atompi.cc</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$TTL 3600</span><br><span class="line">$ORIGIN atompi.cc.</span><br><span class="line"></span><br><span class="line">@ IN SOA ns1.atompi.cc. atompi.atompi.cc. (</span><br><span class="line">    2020072410 ; Serial</span><br><span class="line">    1H         ; Refresh</span><br><span class="line">    600        ; Retry</span><br><span class="line">    7D         ; Expire</span><br><span class="line">    600        ; Negative Cache TTL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">@ IN NS ns1</span><br><span class="line"></span><br><span class="line">ns1 IN A 192.168.1.2</span><br><span class="line"></span><br><span class="line">; Custome</span><br><span class="line">@                 IN A     192.168.1.2</span><br><span class="line">*                 IN CNAME @</span><br><span class="line">kube-apiserver    IN A     192.168.1.3</span><br><span class="line">kube-dashboard    IN A     192.168.1.4</span><br><span class="line">hub               IN A     192.168.1.5</span><br></pre></td></tr></table></figure>
<ul>
<li><code>docker-compose-host-network.yml</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  coredns:</span><br><span class="line">    image: coredns/coredns:1.7.0</span><br><span class="line">    command: -conf /data/Corefile</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/coredns:/data:ro</span><br><span class="line">    cap_drop:</span><br><span class="line">      - ALL</span><br><span class="line">    cap_add:</span><br><span class="line">      - NET_BIND_SERVICE</span><br><span class="line">    read_only: true</span><br><span class="line">    restart: on-failure</span><br><span class="line">    network_mode: host</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;json-file&quot;</span><br><span class="line">      options:</span><br><span class="line">        max-size: &quot;100m&quot;</span><br><span class="line">        max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>docker-compose.yml</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  coredns:</span><br><span class="line">    image: coredns/coredns:1.7.0</span><br><span class="line">    command: -conf /data/Corefile</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;53:53/udp&quot;</span><br><span class="line">      - &quot;53:53/tcp&quot;</span><br><span class="line">      - &quot;9153:9153/tcp&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /data/coredns:/data:ro</span><br><span class="line">    cap_drop:</span><br><span class="line">      - ALL</span><br><span class="line">    cap_add:</span><br><span class="line">      - NET_BIND_SERVICE</span><br><span class="line">    read_only: true</span><br><span class="line">    restart: on-failure</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;json-file&quot;</span><br><span class="line">      options:</span><br><span class="line">        max-size: &quot;100m&quot;</span><br><span class="line">        max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure>
<h2 id="使用-docker-compose-启动服务"><a href="#使用-docker-compose-启动服务" class="headerlink" title="使用 docker-compose 启动服务"></a>使用 docker-compose 启动服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"># host network 模式，解决 CentOS 下 bridge 网络无法被同节点其他容器连接</span><br><span class="line">docker-compose -f docker-compose-host-network.yml up -d</span><br></pre></td></tr></table></figure>
<h2 id="PS1-更新-RFC-1035-style-zone-文件记录"><a href="#PS1-更新-RFC-1035-style-zone-文件记录" class="headerlink" title="PS1: 更新 RFC 1035-style zone 文件记录"></a>PS1: 更新 RFC 1035-style zone 文件记录</h2><p>对于 <code>hosts</code> 文件的更新会在 3 秒内更新解析值</p>
<p>对于 <code>auto</code> 插件指定的 RFC 1035-style zone 文件的更新，<a href="https://coredns.io/plugins/auto/#syntax">官方文档</a>给出： <code>auto</code> 插件会在 <code>reload</code> 指定的时间重新读取 zone 文件，并且在 Serial 值更新是重新加载 zone 文件，只修改记录而不修改 Serial 值是无法应用更新的。</p>
<h2 id="PS2-zone-文件命名规则（必须遵从）"><a href="#PS2-zone-文件命名规则（必须遵从）" class="headerlink" title="PS2: zone 文件命名规则（必须遵从）"></a>PS2: zone 文件命名规则（必须遵从）</h2><p>CoreDNS 根据“域”来分发解析请求到指定配置，所以必须匹配指定的域才能获取到正确的解析。 <code>auto</code> 插件在读取 <code>directory</code> 指定的 zone 目录时会根据正则表达式解析 zone 文件名（详见<a href="https://coredns.io/plugins/auto/#syntax">官方说明</a>），默认规则为： <code>db\.(.*) &#123;1&#125;</code> i.e. 如果文件名为 <code>db.example.com</code> ， 那么解析到的域就是 <code>example.com</code> 。</p>
<p>同时 <code>Corefile</code> 文件中需要为每一个自定义域新建一组配置，如 <code>atompi.cc</code> 域：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atompi.cc &#123;</span><br><span class="line">    forward . 223.5.5.5 223.6.6.6</span><br><span class="line">    loop</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    cache 30</span><br><span class="line"></span><br><span class="line">    auto &#123;</span><br><span class="line">        directory /data/zones/atompi.cc</span><br><span class="line">        reload 10s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CoreDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 os / exec 在 Go 中执行高级命令</title>
    <url>/2019/11/30/%E4%BD%BF%E7%94%A8exec%E5%9C%A8Go%E4%B8%AD%E6%89%A7%E8%A1%8C%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>本文翻译自 <a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html">Advanced command execution in Go with os&#x2F;exec</a> 。</p>
<p>文中所有代码都可以在原作者开源项目 <a href="https://github.com/kjk/go-cookbook">go-cookbook</a> 的 <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec">advanced-exec</a> 目录中获取。</p>
<p>Go对执行外部程序具有出色的支持。让我们从头开始。</p>
<p>在我们的示例中，我们将运行 <code>ls -lah</code> 命令，因为它会产生输出。 Windows 上没有 <code>ls</code> ，因此您可以将其更改为其他命令，例如 <code>tasklist</code>。</p>
<h2 id="1-运行命令"><a href="#1-运行命令" class="headerlink" title="1. 运行命令"></a>1. 运行命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line">if runtime.GOOS == &quot;windows&quot; &#123;</span><br><span class="line">	cmd = exec.Command(&quot;tasklist&quot;)</span><br><span class="line">&#125;</span><br><span class="line">err := cmd.Run()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	log.Fatalf(&quot;cmd.Run() failed with %s\n&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/01-simple-exec-v1.go">advanced-exec&#x2F;01-simple-exec-v1.go</a></p>
<p>如果运行它，似乎什么也不会发生。不用担心，该命令实际上已被执行。如果我们在 <code>shell</code> 中运行 <code>ls -lah</code> ， <code>shell</code> 会将 <code>stdout</code> 和 <code>stderr</code> 输出到控制台，以便我们可以看到它。而我们在通过 Go 标准库函数执行程序时，默认情况下 <code>stdout</code> 和 <code>stderr</code> 被丢弃。</p>
<h2 id="2-运行命令并显示输出"><a href="#2-运行命令并显示输出" class="headerlink" title="2. 运行命令并显示输出"></a>2. 运行命令并显示输出</h2><p>为例看到输出，我们可以将正在执行的程序的输出（ <code>cmd.Stdout</code> 和 <code>cmd.Stderr</code> ）发送到 <code>os.Stdout</code> 和 <code>os.Stderr</code> ，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">err := cmd.Run()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	log.Fatalf(&quot;cmd.Run() failed with %s\n&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/01-simple-exec-v2.go">advanced-exec&#x2F;01-simple-exec-v2.go</a></p>
<p><code>cmd.Stdout</code> 和 <code>cmd.Stderr</code> 被声明为 <code>io.Writer</code> 接口，因此我们可以将它们设置为实现 <code>Write()</code> 方法的任何类型，例如 <code>os.File</code> 或内存中的缓冲区 <code>bytes.Buffer</code> 。<code>io.Reader</code> 和 <code>io.Writer</code> 是非常简单的但非常强大的且抽象的。</p>
<h2 id="3-运行命令并捕获输出"><a href="#3-运行命令并捕获输出" class="headerlink" title="3. 运行命令并捕获输出"></a>3. 运行命令并捕获输出</h2><p>上面的示例使我们可以看到输出，但是有时我们想要捕获输出并进行分析，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line">	out, err := cmd.CombinedOutput()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;cmd.Run() failed with %s\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;combined out:\n%s\n&quot;, string(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码 <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/01-simple-exec-v3.go">advanced-exec&#x2F;01-simple-exec-v3.go</a></p>
<p><code>CombinedOutput</code> 运行命令并返回包含 <code>stdout</code> 和 <code>stderr</code> 的返回值。</p>
<h3 id="3-1-CombinedOutput-的实现原理"><a href="#3-1-CombinedOutput-的实现原理" class="headerlink" title="3.1 CombinedOutput 的实现原理"></a>3.1 CombinedOutput 的实现原理</h3><p>Go 的好处在于它是开源的，因此我们可以窥视给定的功能是如何实现的，同时标准库中的大多数代码都很简单。以下是 <code>CombinedOutput</code> 的实现方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (c *Cmd) CombinedOutput() ([]byte, error) &#123;</span><br><span class="line">	if c.Stdout != nil &#123;</span><br><span class="line">		return nil, errors.New(&quot;exec: Stdout already set&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if c.Stderr != nil &#123;</span><br><span class="line">		return nil, errors.New(&quot;exec: Stderr already set&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	var b bytes.Buffer</span><br><span class="line">	c.Stdout = &amp;amp;b</span><br><span class="line">	c.Stderr = &amp;amp;b</span><br><span class="line">	err := c.Run()</span><br><span class="line">	return b.Bytes(), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这几乎和我们的第二个示例一样简单。我们没有将 <code>cmd.Stdout</code> 和 <code>cmd.Stderr</code> 设置为标准输出，而是将它们设置为单个内存缓冲区。程序完成后，我们将所有写入该缓冲区的内容返回。</p>
<p>因此，<strong>不要害怕细读标准库的代码。</strong></p>
<h2 id="4-分别捕获-stdout-和-stderr"><a href="#4-分别捕获-stdout-和-stderr" class="headerlink" title="4. 分别捕获 stdout 和 stderr"></a>4. 分别捕获 stdout 和 stderr</h2><p>如果要执行相同操作但又分别捕获 <code>stdout</code> 和 <code>stderr</code> ，该怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line">	var stdout, stderr bytes.Buffer</span><br><span class="line">	cmd.Stdout = &amp;amp;stdout</span><br><span class="line">	cmd.Stderr = &amp;amp;stderr</span><br><span class="line">	err := cmd.Run()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;cmd.Run() failed with %s\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	outStr, errStr := string(stdout.Bytes()), string(stderr.Bytes())</span><br><span class="line">	fmt.Printf(&quot;out:\n%s\nerr:\n%s\n&quot;, outStr, errStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/02-capture-stdout-stderr.go">advanced-exec&#x2F;02-capture-stdout-stderr.go</a></p>
<h2 id="5-捕获输出同时显示执行过程中的输出"><a href="#5-捕获输出同时显示执行过程中的输出" class="headerlink" title="5. 捕获输出同时显示执行过程中的输出"></a>5. 捕获输出同时显示执行过程中的输出</h2><p>对于有以下需求的程序：</p>
<ul>
<li>命令需要很长时间才能完成</li>
<li>除了捕获 <code>stdout</code> &#x2F; <code>stderr</code> 之外，还需要在控制台上看到它的执行过程。</li>
</ul>
<p>此时我们需要在捕获输出的同时捕获执行过程。这里涉及到的东西有点多，但并不难理解。</p>
<h3 id="5-1-捕获输出同时显示执行过程中的输出-1"><a href="#5-1-捕获输出同时显示执行过程中的输出-1" class="headerlink" title="5.1 捕获输出同时显示执行过程中的输出 #1"></a>5.1 捕获输出同时显示执行过程中的输出 #1</h3><p>首先，一个帮助程序功能可以从读取器复制到写入器，还可以捕获复制的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func copyAndCapture(w io.Writer, r io.Reader) ([]byte, error) &#123;</span><br><span class="line">	var out []byte</span><br><span class="line">	buf := make([]byte, 1024, 1024)</span><br><span class="line">	for &#123;</span><br><span class="line">		n, err := r.Read(buf[:])</span><br><span class="line">		if n &amp;gt; 0 &#123;</span><br><span class="line">			d := buf[:n]</span><br><span class="line">			out = append(out, d...)</span><br><span class="line">			_, err := w.Write(d)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				return out, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			// Read returns io.EOF at the end of file, which is not an error for us</span><br><span class="line">			if err == io.EOF &#123;</span><br><span class="line">				err = nil</span><br><span class="line">			&#125;</span><br><span class="line">			return out, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理 <code>Read</code> 中的错误非常微妙。 <code>io.EOF</code> 错误意味着我们已经读取了所有内容。这实际上不是错误，因此我们将 <code>io.EOF</code> 设置为 <code>nil</code> 。</p>
<p>最终代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line"></span><br><span class="line">	var stdout, stderr []byte</span><br><span class="line">	var errStdout, errStderr error</span><br><span class="line">	stdoutIn, _ := cmd.StdoutPipe()</span><br><span class="line">	stderrIn, _ := cmd.StderrPipe()</span><br><span class="line">	err := cmd.Start()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;cmd.Start() failed with &#x27;%s&#x27;\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// cmd.Wait() should be called only after we finish reading</span><br><span class="line">	// from stdoutIn and stderrIn.</span><br><span class="line">	// wg ensures that we finish</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		stdout, errStdout = copyAndCapture(os.Stdout, stdoutIn)</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	stderr, errStderr = copyAndCapture(os.Stderr, stderrIn)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	err = cmd.Wait()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;cmd.Run() failed with %s\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	if errStdout != nil || errStderr != nil &#123;</span><br><span class="line">		log.Fatal(&quot;failed to capture stdout or stderr\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	outStr, errStr := string(stdout), string(stderr)</span><br><span class="line">	fmt.Printf(&quot;\nout:\n%s\nerr:\n%s\n&quot;, outStr, errStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/03-live-progress-and-capture-v1.go">advanced-exec&#x2F;03-live-progress-and-capture-v1.go</a></p>
<p>我们有两个输出要复制。为避免序列化它们，我们将在 <code>goroutine</code> 中读取其中一个。</p>
<p>正如 <code>StdoutPipe</code> 的文档警告，在程序完成时 <code>Wait</code> 将关闭管道。如果我们还没有读完，可能会导致输出丢失。为防止这种情况，我们使用 <code>sync.WaitGroup</code> 来确保在调用 <code>cmd.Wait</code> 之前 <code>gorutine</code> 处理 <code>os.Stdout</code> 的操作完成了读取。</p>
<p>我鼓励你阅读 <code>cmd.StdoutPipe</code> 的实现。尽管代码很短，但是会让你感到惊讶。</p>
<h3 id="5-2-捕获输出同时显示执行过程中的输出-＃2"><a href="#5-2-捕获输出同时显示执行过程中的输出-＃2" class="headerlink" title="5.2 捕获输出同时显示执行过程中的输出 ＃2"></a>5.2 捕获输出同时显示执行过程中的输出 ＃2</h3><p>以前的解决方案有效，但 <code>copyAndCapture</code> 看起来像我们在重新实现 <code>io.Copy</code> 。由于 Go 使用了接口，因此我们可以重复使用 <code>io.Copy</code> 。</p>
<p>我们将编写实现 <code>io.Writer</code> 接口的 <code>CapturingPassThroughWriter</code> 结构。它将捕获写入其中的所有内容，并将其写入底层的 <code>io.Writer</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// CapturingPassThroughWriter is a writer that remembers</span><br><span class="line">// data written to it and passes it to w</span><br><span class="line">type CapturingPassThroughWriter struct &#123;</span><br><span class="line">	buf bytes.Buffer</span><br><span class="line">	w io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewCapturingPassThroughWriter creates new CapturingPassThroughWriter</span><br><span class="line">func NewCapturingPassThroughWriter(w io.Writer) *CapturingPassThroughWriter &#123;</span><br><span class="line">	return &amp;amp;CapturingPassThroughWriter&#123;</span><br><span class="line">		w: w,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *CapturingPassThroughWriter) Write(d []byte) (int, error) &#123;</span><br><span class="line">	w.buf.Write(d)</span><br><span class="line">	return w.w.Write(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Bytes returns bytes written to the writer</span><br><span class="line">func (w *CapturingPassThroughWriter) Bytes() []byte &#123;</span><br><span class="line">	return w.buf.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line"></span><br><span class="line">		var errStdout, errStderr error</span><br><span class="line">		stdoutIn, _ := cmd.StdoutPipe()</span><br><span class="line">		stderrIn, _ := cmd.StderrPipe()</span><br><span class="line">		stdout := NewCapturingPassThroughWriter(os.Stdout)</span><br><span class="line">		stderr := NewCapturingPassThroughWriter(os.Stderr)</span><br><span class="line">		err := cmd.Start()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatalf(&quot;cmd.Start() failed with &#x27;%s&#x27;\n&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		var wg sync.WaitGroup</span><br><span class="line">		wg.Add(1)</span><br><span class="line"></span><br><span class="line">		go func() &#123;</span><br><span class="line">			_, errStdout = io.Copy(stdout, stdoutIn)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		_, errStderr = io.Copy(stderr, stderrIn)</span><br><span class="line">		wg.Wait()</span><br><span class="line"></span><br><span class="line">	err = cmd.Wait()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;cmd.Run() failed with %s\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	if errStdout != nil || errStderr != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;failed to capture stdout or stderr\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	outStr, errStr := string(stdout.Bytes()), string(stderr.Bytes())</span><br><span class="line">	fmt.Printf(&quot;\nout:\n%s\nerr:\n%s\n&quot;, outStr, errStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/03-live-progress-and-capture-v2.go">advanced-exec&#x2F;03-live-progress-and-capture-v2.go</a></p>
<h3 id="5-3-捕获输出同时显示执行过程中的输出-＃3"><a href="#5-3-捕获输出同时显示执行过程中的输出-＃3" class="headerlink" title="5.3 捕获输出同时显示执行过程中的输出 ＃3"></a>5.3 捕获输出同时显示执行过程中的输出 ＃3</h3><p>事实上， Go 的标准库实现了 <a href="https://golang.org/pkg/io/#MultiWriter"><code>io.MultiWriter</code></a> ，它是 <code>CapturingPassThroughWriter</code> 的通用版本。让我们用它代替：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line"></span><br><span class="line">		var stdoutBuf, stderrBuf bytes.Buffer</span><br><span class="line">	stdoutIn, _ := cmd.StdoutPipe()</span><br><span class="line">	stderrIn, _ := cmd.StderrPipe()</span><br><span class="line"></span><br><span class="line">	var errStdout, errStderr error</span><br><span class="line">	stdout := io.MultiWriter(os.Stdout, &amp;amp;stdoutBuf)</span><br><span class="line">	stderr := io.MultiWriter(os.Stderr, &amp;amp;stderrBuf)</span><br><span class="line">	err := cmd.Start()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;cmd.Start() failed with &#x27;%s&#x27;\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		var wg sync.WaitGroup</span><br><span class="line">		wg.Add(1)</span><br><span class="line"></span><br><span class="line">		go func() &#123;</span><br><span class="line">			_, errStdout = io.Copy(stdout, stdoutIn)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		_, errStderr = io.Copy(stderr, stderrIn)</span><br><span class="line">		wg.Wait()</span><br><span class="line"></span><br><span class="line">	err = cmd.Wait()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;cmd.Run() failed with %s\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	if errStdout != nil || errStderr != nil &#123;</span><br><span class="line">		log.Fatal(&quot;failed to capture stdout or stderr\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	outStr, errStr := string(stdoutBuf.Bytes()), string(stderrBuf.Bytes())</span><br><span class="line">	fmt.Printf(&quot;\nout:\n%s\nerr:\n%s\n&quot;, outStr, errStr)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/03-live-progress-and-capture-v3.go">advanced-exec&#x2F;03-live-progress-and-capture-v3.go</a></p>
<p>能够自己编写代码是件好事，但更好地了解标准库则更好！</p>
<h2 id="6-写入程序的标准输入（-stdin-）"><a href="#6-写入程序的标准输入（-stdin-）" class="headerlink" title="6. 写入程序的标准输入（ stdin ）"></a>6. 写入程序的标准输入（ stdin ）</h2><p>我们知道如何读取程序的 <code>stdout</code> ，但我们也可以写入其 <code>stdin</code> 。</p>
<p>目前没有 Go 标准库可以执行 <code>bzip2</code> 压缩（标准库中仅提供解压缩功能）。我们可以通过以下方式使用 <code>bzip2</code> 进行压缩：（将数据写入临时文件）调用 <code>bzip2 -c $ &#123;file_in&#125;</code> 并捕获其 <code>stdout</code>。</p>
<p>如果我们不创建临时文件就更好了。大多数压缩程序接受数据以在 <code>stdin</code> 上进行压缩 &#x2F; 解压缩。要在命令行上执行此操作，我们将使用以下命令： <code>bzip2 -c &amp;lt;$ &#123;file_in&#125;&amp;gt; $ &#123;file_out&#125;</code> 。</p>
<p>下面就是使用 Go 实现这一操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// compress data using bzip2 without creating temporary files</span><br><span class="line">func bzipCompress(d []byte) ([]byte, error) &#123;</span><br><span class="line">	var out bytes.Buffer</span><br><span class="line">	// -c : compress</span><br><span class="line">	// -9 : select the highest level of compresion</span><br><span class="line">	cmd := exec.Command(&quot;bzip2&quot;, &quot;-c&quot;, &quot;-9&quot;)</span><br><span class="line">	cmd.Stdin = bytes.NewBuffer(d)</span><br><span class="line">	cmd.Stdout = &amp;amp;out</span><br><span class="line">	err := cmd.Run()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return out.Bytes(), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/06-feed-stdin.go">advanced-exec&#x2F;06-feed-stdin.go</a></p>
<p>我们还可以调用 <code>cmd.StdinPipe()</code> ，它返回 <code>io.WriteCloser</code> 。它比较复杂，但是可以更好地控制我们的代码量。</p>
<h2 id="7-改变执行程序的环境"><a href="#7-改变执行程序的环境" class="headerlink" title="7. 改变执行程序的环境"></a>7. 改变执行程序的环境</h2><p>有关 Go 中环境变量的注意事项：</p>
<ul>
<li><code>os.Environ()</code> 返回一个 <code>[]string</code> ，其中每个字符串的形式为 <code>FOO=bar</code> ，其中 <code>FOO</code> 是环境变量的名称， <code>bar</code> 是值</li>
<li><code>os.Getenv(&quot;FOO&quot;)</code> 返回环境变量 <code>FOO</code> 的值</li>
</ul>
<p>有时您需要修改执行程序的环境。 Go 通过设置 <code>exec.Cmd</code> 的 <code>Env</code> 成员来支持这一点。 <code>cmd.Env</code> 与 <code>os.Environ()</code> 的格式相同。如果未设置 <code>Env</code> ，则进程将继承调用进程的环境。</p>
<p>如果你不想从头开始构建一个全新的环境，而是传递当前流程环境的修改版本。可以使用以下添加新变量的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd := exec.Command(&quot;programToExecute&quot;)</span><br><span class="line"></span><br><span class="line">additionalEnv := &quot;FOO=bar&quot;</span><br><span class="line">newEnv := append(os.Environ(), additionalEnv))</span><br><span class="line">cmd.Env = newEnv</span><br><span class="line"></span><br><span class="line">out, err := cmd.CombinedOutput()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	log.Fatalf(&quot;cmd.Run() failed with %s\n&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s&quot;, out)</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/05-change-environment.go">advanced-exec&#x2F;05-change-environment.go</a></p>
<p>如果要删除环境或确保不设置两次相同的变量，那么就不这么简单了。幸好软件包 <a href="https://godoc.org/github.com/shurcooL/go/osutil#Environ"><code>shurcooL/go/osutil</code></a> 提供了一种操作环境变量的简便方法。</p>
<h2 id="8-提前检查要执行的程序是否可被执行"><a href="#8-提前检查要执行的程序是否可被执行" class="headerlink" title="8. 提前检查要执行的程序是否可被执行"></a>8. 提前检查要执行的程序是否可被执行</h2><p>想象一下，你编写了一个需要很长时间才能运行的程序。最后，你调用可执行文件 <code>foo</code> 执行基本任务，此时如果不存在 <code>foo</code> 可执行文件，则调用将失败，前功尽弃。</p>
<p>因此，最好在开始的时侯就检测到缺少可执行文件 <code>foo</code> ，并在出现描述性错误消息时尽早结束执行。可以使用 <code>exec.LookPath</code> 做到这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func checkLsExists() &#123;</span><br><span class="line">	path, err := exec.LookPath(&quot;ls&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Printf(&quot;didn&#x27;t find &#x27;ls&#x27; executable\n&quot;)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		fmt.Printf(&quot;&#x27;ls&#x27; executable is in &#x27;%s&#x27;\n&quot;, path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec/04-check-exe-exists.go">advanced-exec&#x2F;04-check-exe-exists.go</a></p>
<p>检查程序是否存在的另一种方法是尝试在无操作模式下执行它（例如，许多程序都支持 <code>--help</code> 选项）。</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>修改 docker 默认存储路径</title>
    <url>/2018/02/04/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="方法-1-、软链接"><a href="#方法-1-、软链接" class="headerlink" title="方法 1 、软链接"></a>方法 1 、软链接</h2><p>默认情况下 docker 的存放位置为： <code>/var/lib/docker</code></p>
<p>可以通过下面命令查看具体位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker info | grep &quot;Docker Root Dir&quot;</span><br></pre></td></tr></table></figure>
<p>解决这个问题，最直接的方法当然是挂载分区到这个目录，但是我的数据盘还有其他东西，这肯定不好管理，所以采用修改镜像和容器的存放路径的方式达到目的。</p>
<p>这个方法里将通过软连接来实现。</p>
<p>首先停掉 docker 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br><span class="line"># 或者</span><br><span class="line">sudo service docker stop</span><br></pre></td></tr></table></figure>
<p>然后移动整个  <code>/var/lib/docker</code> 目录到目的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mv /var/lib/docker /root/data/docker</span><br><span class="line">sudo ln -s /root/data/docker /var/lib/docker</span><br></pre></td></tr></table></figure>
<p>这时候启动 docker 时发现存储目录依旧是 <code>/var/lib/docker</code> ，但是实际上是存储在数据盘的，你可以在数据盘上看到容量变化。</p>
<h2 id="方法-2-、修改-docker-配置文件中镜像和容器的存放路径"><a href="#方法-2-、修改-docker-配置文件中镜像和容器的存放路径" class="headerlink" title="方法 2 、修改 docker 配置文件中镜像和容器的存放路径"></a>方法 2 、修改 docker 配置文件中镜像和容器的存放路径</h2><p>指定镜像和容器存放路径的参数是 <code>--graph=/var/lib/docker</code> ，我们只需要修改配置文件指定启动参数即可。</p>
<p>docker 的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致，在 Ubuntu 中的位置是： <code>/etc/default/docker</code> ，在 CentOS 中的位置是： <code>/etc/sysconfig/docker</code> 。</p>
<p>如果是 CentOS 7 则添加下面这行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS=&#x27;--graph=/root/data/docker --selinux-enabled -H fd://&#x27;</span><br></pre></td></tr></table></figure>
<p>如果是 Ubuntu 则添加下面这行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;-g /root/data/docker -H fd://&quot;</span><br></pre></td></tr></table></figure>
<p>最后重新启动， Docker 的路径就改成 <code>/root/data/docker</code> 了。</p>
<p>centos 7 下，也可以修改 <code>docker.service</code> 文件，使用 <code>-g</code> 参数指定存储位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --graph /root/data/docker</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># reload 配置文件</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 重启 docker</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>如果 docker 是 1.12 或以上的版本，可以修改（或新建）<code>daemon.json</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://7e61f7f9.m.daocloud.io&quot;],</span><br><span class="line">  &quot;graph&quot;: &quot;/root/data/docker&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重启 docker</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何向使用 Go 开发的开源项目贡献代码</title>
    <url>/2019/11/30/%E5%A6%82%E4%BD%95%E5%90%91%E4%BD%BF%E7%94%A8Go%E5%BC%80%E5%8F%91%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>当我们要向一个开源项目贡献代码时通常的步骤是：</p>
<li>fork 原项目到自己的账号上
</li>
<li>在本地将 fork 的项目下载下来，开发，编译测试
</li>
<li>本地检查没问题之后 push 到自己 fork 的仓库
</li>
<li>按原项目贡献代码规范检查自己的代码以符合规范（一些热门的/专业社区维护的项目一般都有一套贡献规范，如 Kubernetes 、 moby （原 Docker ） 、 Go）
</li>
<li>一切安排妥当后向原项目提交 PR 等待合并到原项目分支
</li>

<p>整个流程看起来十分简单，但这一套用在 Go 项目仿佛有点行不通了。</p>
<h2 id="1-遇到的问题"><a href="#1-遇到的问题" class="headerlink" title="1. 遇到的问题"></a>1. 遇到的问题</h2><p>我们在编写 Go 代码的时候通常会引用本项目或在其他项目的包，通常我们会使用远程地址指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    gitee.com/oscstudio/gitee-exporter/config</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这时如果我们发现依赖的代码包中存在缺陷，或者我们有一个很棒的想法想要合并到源项目中，因此我们需要修改源项目的代码。于是我们按照上面的流程走一遍。</p>
<p>这时候问题来了：如果我们 fork 了源项目，然后通过 <code>go get</code> 拉取我们 fork 的代码时，会收到如下错误输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) ➜  blackbox_exporter proxy go get github.com/atompi/blackbox_exporter</span><br><span class="line"># github.com/atompi/blackbox_exporter</span><br><span class="line">src/github.com/atompi/blackbox_exporter/main.go:119:19: cannot use registry (type *&quot;github.com/atompi/blackbox_exporter/vendor/github.com/prometheus/client_golang/prometheus&quot;.Registry) as type *&quot;github.com/prometheus/blackbox_exporter/vendor/github.com/prometheus/client_golang/prometheus&quot;.Registry in argument to prober</span><br><span class="line">(base) ➜  blackbox_exporter</span><br></pre></td></tr></table></figure>
<p>如果此时我们修改代码中引用这个包的部分的代码，我们会修改到一些不必要（甚至不允许）修改的代码，导致我们的代码即使编译通过也无法合并到源项目。</p>
<p>还有一个问题，即 <a href="https://en.wikipedia.org/wiki/Dependency_hell">Dependency hell</a> （依赖地狱）。依赖地狱是一个通俗的术语，用于体现使用了某些安装了依赖于其他特定版本的软件包的软件用户的沮丧心情。</p>
<p>Github 上不乏有这样的评论： <code>&quot;When I run [the tests] they always pass, but that is because they import the package from [the package path] and not my local fork.&quot;</code> 。即：当我运行或者测试时，它们始终会通过，但这只是因为它们是从包源路径而非从我本地 fork 的包导入的。</p>
<h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p>为了避免上面遇到的问题，我们需要换一种方式来修改“ fork ”的代码</p>
<p>首先，我们在 Gitee 或者 Github 上 fork 我们需要贡献代码的项目，然后我们使用 <code>go get</code> 拉取源项目而非我们 fork 的项目，这样我们的代码 import 部分都是正确且不需要做不必要的修改的。</p>
<p>然后， <code>go get</code> 会将项目的 git 仓库拉到本地的 <code>$GOPATH/src</code> 目录下， <code>git remote -v</code> 可以看到，远程地址为源项目的地址，此时我们可以通过 <code>git remote add fork xxxx</code> 命令添加我们 fork 的仓库地址，让当前 git 仓库拥有两个远程地址。</p>
<p>最后，我们修改并测试完成之后可以将修改后的代码推送到我们 fork 的远程地址，这样就可以安全的向源项目提交 PR 了。</p>
<p>以上为笔者在实践中总结的一种向使用 Go 开发的开源项目贡献代码的解决方案，该方案改动少，对代码没有入侵性，操作简单。如果读者有更好的方式，可以在评论中留言，大家一起探讨。</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速构建一个 Go 语言开发环境</title>
    <url>/2019/11/29/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><li>本文适用于 Linux 环境；
</li>
<li>本文主体只对 Go 编译环境做一些简单的配置，如：环境变量、目录规划。
</li>
<li>本文末尾会附带一些有用的工具，对 Go 学习和开发都有很大帮助。
</li>

<h2 id="开始构建-Go-编译环境"><a href="#开始构建-Go-编译环境" class="headerlink" title="开始构建 Go 编译环境"></a>开始构建 Go 编译环境</h2><ul>
<li>安装 C&#x2F;C++ 构建工具链（使用 CGO 特性）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Ubuntu</span><br><span class="line">sudo apt install build-essential</span><br><span class="line"># CentOS</span><br><span class="line">sudo yum groupinstall &quot;Development Tools&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>下载 Go 二进制包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/Downloads</span><br><span class="line">GO_VERSION=1.13.4 &amp;amp;&amp;amp; wget https://dl.google.com/go/go$GO_VERSION.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>解压 Go 二进制包并移动到 <code>/usr/local/go</code> 目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/Downloads</span><br><span class="line">GO_VERSION=1.13.4 &amp;amp;&amp;amp; tar -zxf go$GO_VERSION.linux-amd64.tar.gz</span><br><span class="line">sudo mv go /usr/local/</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一些必要和不必要但建议创建并指定的目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /data/goworkdir/&#123;go,go-build&#125;</span><br><span class="line">sudo chown -R $USER:$USER /data/goworkdir</span><br></pre></td></tr></table></figure>
<ul>
<li>修改环境变量</li>
</ul>
<p>只对当前用户生效：</p>
<p>对于 <code>bash</code> 用户，在 <code>$HOME/bashrc</code> 末尾新增以下内容；对于 <code>zsh</code> 用户，在 <code>$HOME/.zshrc</code> 末尾新增以下内容</p>
<p>对所有用户生效：</p>
<p>对于 Ubuntu 发行版， <code>bash</code> 用户在 <code>/etc/bash.bashrc</code> 末尾新增以下内容；<code>zsh</code> 用户，在 <code>/etc/zsh/zshrc</code> 末尾新增以下内容</p>
<p>对于 CentOS 发行版， <code>bash</code> 用户在 <code>/etc/profile</code> 末尾新增以下内容；<code>zsh</code> 用户，在 <code>/etc/zsh/zshrc</code> 末尾新增以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/data/goworkdir/go</span><br><span class="line">export GOCACHE=/data/goworkdir/go-build</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure>
<p>环境变量修改完成后退出当前用户重新登陆后生效，验证： <code>go env</code> 可输出 Go 环境信息</p>
<h2 id="一些有用的工具"><a href="#一些有用的工具" class="headerlink" title="一些有用的工具"></a>一些有用的工具</h2><ol>
<li>zeal —— 离线 API 文档神器</li>
</ol>
<p>下载地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://zealdocs.org/</span><br></pre></td></tr></table></figure>
<p>zeal 自带的 API 文档依赖于 <a href="https://kapeli.com/dash">Dash</a> 项目，包含了众多的 API 文档和权威指南（包含 Go ），如果不够可以从下面的地址中获取更多社区维护的第三方 API 文档和 cheatsheets</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cheatsheets</span><br><span class="line">https://zeal-cheatsheets.herokuapp.com/</span><br><span class="line"># Docsets</span><br><span class="line">https://zealusercontributions.herokuapp.com/</span><br></pre></td></tr></table></figure>
<p>如果还觉得不够（确实不够，没有 GoDoc ），这时候需要我们自己构建 Docset 导入了，这里只介绍 GoDoc 的构建，其他 Docset 的构建方式可以在<a href="https://kapeli.com/docsets">这里</a>找到。</p>
<p>构建 GoDoc 使用 <a href="https://github.com/wuudjac/godocdash">godocdash</a> 项目完成，原理大概是使用 <code>godoc</code> 工具在本地生成 GoDoc 然后通过暴露的 url 爬取内容并生成支持 Dash 格式的 docset 。</p>
<ul>
<li>构建流程：</li>
</ul>
<p>下载 Go 二进制包中不包含 godoc 工具，需要我们自行安装。</p>
<p>创建一个目录用来存放所有的 go 项目，如笔者使用 GoLand 开发，所有的 go 项目全部存放在 <code>/home/atompi/workdir/GolandProjects/</code> 目录下，下面我们把它简称为 <code>projectsDir</code></p>
<p>在 <code>projectsDir</code> 下创建一个 <code>godoc</code> 文件夹（注意与项目名同名，但这不是源码文件）用来存放与该项目相关的所有文件（建议今后不管是个人创建的还是引用社区的项目都按这种格式统一管理）。</p>
<p>进入 <code>projectsDir/godoc</code> 目录下载 <code>godoc</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br><span class="line">go get golang.org/x/tools/cmd/godoc</span><br></pre></td></tr></table></figure>
<p>为 <code>godocd</code> 可执行文件创建软链接，以便在命令行直接使用 <code>godoc</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># go get 命令会在 projectsDir/godoc 目录下创建 bin 目录存放编译好的可执行文件</span><br><span class="line">sudo ln -s /home/atompi/workdir/GolandProjects/godoc/bin/godoc /usr/local/bin/</span><br></pre></td></tr></table></figure>
<p>在 <code>projectsDir</code> 下创建一个 <code>godocdash</code> 文件夹</p>
<p>进入 <code>projectsDir/godocdash</code> 目录下载 <code>godocdash</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br><span class="line">go get github.com/wuudjac/godocdash</span><br></pre></td></tr></table></figure>
<p>为 <code>godocdash</code> 可执行文件创建软链接，以便在命令行直接使用 <code>godocdash</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/atompi/workdir/GolandProjects/godocdash/bin/godocdash /usr/local/bin/</span><br></pre></td></tr></table></figure>
<p>创建 <code>projectsDir/godocmaker</code> 目录，用来存放待构建 GoDoc 的项目源码和构建出来的 Docset</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/atompi/workdir/GolandProjects/godocmaker</span><br></pre></td></tr></table></figure>
<p>下载待构建 GoDoc 的项目源码，以 <code>github.com/prometheus/client_golang</code> 为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/atompi/workdir/GolandProjects/godocmaker</span><br><span class="line">export GOPATH=`pwd`</span><br><span class="line"># 只下载，不编译</span><br><span class="line">go get -d github.com/prometheus/client_golang</span><br></pre></td></tr></table></figure>
<p>构建 Docset ，在 <code>projectsDir/godocmaker</code> 目录下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">godocdash</span><br></pre></td></tr></table></figure>
<p>把构建出来的 Docset 移动到 zeal Docset 目录（ ~&#x2F;.local&#x2F;share&#x2F;Zeal&#x2F;Zeal&#x2F;docsets&#x2F; ），重启 zeal 后就可以离线查看 GoDoc 了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv GoDoc.docset ~/.local/share/Zeal/Zeal/docsets/</span><br></pre></td></tr></table></figure>
<ol>
<li>tour —— Go 学习神器</li>
</ol>
<p><a href="https://tour.go-zh.org/">tour 中文版</a> 是 Go 编程语言指南（ <a href="https://tour.golang.org/">A Tour of Go</a> ）的中文社区维护版本，是学习 Go 语言（入门）最好的途径。 tour 工具可以开启一个 web 页面，以实例的方式介绍 Go 编程语言，用户可以在页面上直接编写简单的 Go 代码并实时执行获取执行结果。 tour 通过共有云的方式提供一个公共的入口，只要你能连接互联网就可以随时随地访问和使用，同时 tour 还提供了离线版本，以便在你无法连接互联网是同样可以通过 tour 工具学习和实践。</p>
<p>安装离线版 tour 非常简单只需要执行以下命令即可。</p>
<p>创建 <code>projectsDir/tour</code> 目录并在目录中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br><span class="line"># 安装中文版</span><br><span class="line">go get github.com/Go-zh/tour</span><br><span class="line"># 安装英文原版</span><br><span class="line">go get golang.org/x/tour</span><br></pre></td></tr></table></figure>
<p>建议为 <code>tour</code> 可执行文件创建软链接，以便在命令行直接使用 <code>tour</code> 命令。</p>
<p>命令行执行 <code>tour</code> 会自动打开默认浏览器并进入本地的 tour 主页</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 MySQL</title>
    <url>/2018/01/04/%E5%AE%89%E8%A3%85MySQL/</url>
    <content><![CDATA[<h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><ul>
<li>Ubuntu</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y cmake build-essential libreadline6-dev libncurses5-dev</span><br></pre></td></tr></table></figure>
<h2 id="获取-MySQL-安装包并解压"><a href="#获取-MySQL-安装包并解压" class="headerlink" title="获取 MySQL 安装包并解压"></a>获取 MySQL 安装包并解压</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.ustc.edu.cn/mysql-ftp/Downloads/MySQL-5.6/mysql-5.6.38.tar.gz</span><br><span class="line">tar -zxf mysql-5.6.38.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建 mysql 用户</span><br><span class="line">sudo groupadd mysql</span><br><span class="line">sudo useradd -r -g mysql mysql</span><br><span class="line"></span><br><span class="line"># 创建一些必要的目录并授权给 mysql 用户</span><br><span class="line">sudo mkdir -p /etc/mysql/conf.d</span><br><span class="line">sudo mkdir /run/mysqld</span><br><span class="line">sudo mkdir -p /var/log/mysql</span><br><span class="line">sudo mkdir -p /data/mysql</span><br><span class="line">sudo mkdir -p /data/mysql-old-log</span><br><span class="line">sudo chown -R mysql:mysql /var/log/mysql</span><br><span class="line">sudo chown -R mysql:mysql /data/mysql</span><br><span class="line">sudo chown -R mysql:mysql /data/mysql-old-log</span><br><span class="line">sudo chown -R mysql:root /run/mysqld</span><br><span class="line"></span><br><span class="line"># 编译安装</span><br><span class="line">cd mysql-5.6.38/</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql -DSYSCONFDIR=/etc/mysql -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/run/mysqld/mysqld.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DEXTRA_CHARSETS=utf8,gbk -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_PARTITION_STORAGE_ENGINE=1</span><br><span class="line">make -j6</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="配置-MySQL"><a href="#配置-MySQL" class="headerlink" title="配置 MySQL"></a>配置 MySQL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改安装目录权限</span><br><span class="line">sudo chown -R mysql:mysql /usr/local/mysql</span><br><span class="line"></span><br><span class="line"># 创建配置文件</span><br><span class="line">sudo touch /etc/mysql/conf.d/.keepme</span><br><span class="line">sudo vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>
<p><code>/etc/mysql/my.cnf</code> 文件内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># The MySQL database server configuration file.</span><br><span class="line">#</span><br><span class="line"># You can copy this to one of:</span><br><span class="line"># - &quot;/etc/mysql/my.cnf&quot; to set global options,</span><br><span class="line"># - &quot;~/.my.cnf&quot; to set user-specific options.</span><br><span class="line">#</span><br><span class="line"># One can use all long options that the program supports.</span><br><span class="line"># Run program with --help to get a list of available options and with</span><br><span class="line"># --print-defaults to see which it would actually understand and use.</span><br><span class="line">#</span><br><span class="line"># For explanations see</span><br><span class="line"># http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span><br><span class="line"></span><br><span class="line"># This will be passed to all mysql clients</span><br><span class="line"># It has been reported that passwords should be enclosed with ticks/quotes</span><br><span class="line"># escpecially if they contain &quot;#&quot; chars...</span><br><span class="line"># Remember to edit /etc/mysql/debian.cnf when changing the socket location.</span><br><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line"></span><br><span class="line"># Here is entries for some specific programs</span><br><span class="line"># The following values assume you have at least 32M ram</span><br><span class="line"></span><br><span class="line"># This was formally known as [safe_mysqld]. Both versions are currently parsed.</span><br><span class="line">[mysqld_safe]</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">nice=0</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># * Basic Settings</span><br><span class="line">#</span><br><span class="line">character_set_server = utf8</span><br><span class="line">user=mysql</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">socket=/var/run/mysqld/mysqld.sock</span><br><span class="line">port=3306</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/data/mysql</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">#lc-messages-dir=/usr/share/mysql</span><br><span class="line">skip-external-locking</span><br><span class="line"></span><br><span class="line">max_connections=1000</span><br><span class="line"></span><br><span class="line">event_scheduler=ON</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line">#</span><br><span class="line"># Instead of skip-networking the default is now to listen only on</span><br><span class="line"># localhost which is more compatible and is not less secure.</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">#</span><br><span class="line"># * Fine Tuning</span><br><span class="line">#</span><br><span class="line">key_buffer=512M</span><br><span class="line">max_allowed_packet=64M</span><br><span class="line">thread_stack=192K</span><br><span class="line">thread_cache_size=24</span><br><span class="line"># This replaces the startup script and checks MyISAM tables if needed</span><br><span class="line"># the first time they are touched</span><br><span class="line">myisam-recover=BACKUP</span><br><span class="line">#max_connections        = 100</span><br><span class="line">#table_cache            = 64</span><br><span class="line">#thread_concurrency     = 10</span><br><span class="line">#</span><br><span class="line"># * Query Cache Configuration</span><br><span class="line">#</span><br><span class="line">query_cache_limit=16M</span><br><span class="line">query_cache_size=128M</span><br><span class="line">#</span><br><span class="line"># * Logging and Replication</span><br><span class="line">#</span><br><span class="line"># Both location gets rotated by the cronjob.</span><br><span class="line"># Be aware that this log type is a performance killer.</span><br><span class="line"># As of 5.1 you can enable the log at runtime!</span><br><span class="line">#general_log_file        = /var/log/mysql/mysql.log</span><br><span class="line">#general_log             = 1</span><br><span class="line">#</span><br><span class="line"># Error log - should be very few entries.</span><br><span class="line">#</span><br><span class="line">log_error=/var/log/mysql/error.log</span><br><span class="line">#</span><br><span class="line"># Here you can see queries with especially long duration</span><br><span class="line">#log_slow_queries    = /var/log/mysql/mysql-slow.log</span><br><span class="line">#long_query_time = 2</span><br><span class="line">#log-queries-not-using-indexes</span><br><span class="line">#</span><br><span class="line"># The following can be used as easy to replay backup logs or for replication.</span><br><span class="line"># note: if you are setting up a replication slave, see README.Debian about</span><br><span class="line">#       other settings you may need to change.</span><br><span class="line">#server-id        = 1</span><br><span class="line">#log_bin            = /var/log/mysql/mysql-bin.log</span><br><span class="line">expire_logs_days=10</span><br><span class="line">max_binlog_size=100M</span><br><span class="line">#binlog_do_db        = include_database_name</span><br><span class="line">#binlog_ignore_db    = include_database_name</span><br><span class="line">#</span><br><span class="line"># * InnoDB</span><br><span class="line">#</span><br><span class="line"># InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.</span><br><span class="line"># Read the manual for more InnoDB related options. There are many!</span><br><span class="line">#</span><br><span class="line"># * Security Features</span><br><span class="line">#</span><br><span class="line"># Read the manual, too, if you want chroot!</span><br><span class="line"># chroot = /var/lib/mysql/</span><br><span class="line">#</span><br><span class="line"># For generating SSL certificates I recommend the OpenSSL GUI &quot;tinyca&quot;.</span><br><span class="line">#</span><br><span class="line"># ssl-ca=/etc/mysql/cacert.pem</span><br><span class="line"># ssl-cert=/etc/mysql/server-cert.pem</span><br><span class="line"># ssl-key=/etc/mysql/server-key.pem</span><br><span class="line"></span><br><span class="line">innodb_file_per_table=1</span><br><span class="line">innodb_open_files=2048</span><br><span class="line"></span><br><span class="line">innodb_log_group_home_dir=/data/mysql</span><br><span class="line">innodb_buffer_pool_instances=24</span><br><span class="line">innodb_buffer_pool_size=24G</span><br><span class="line">innodb_additional_mem_pool_size=64M</span><br><span class="line">innodb_log_file_size=64M</span><br><span class="line">innodb_lock_wait_timeout=50</span><br><span class="line">innodb_flush_log_at_trx_commit=0</span><br><span class="line">### small swap / IO</span><br><span class="line">innodb_flush_method=O_DIRECT</span><br><span class="line">innodb_write_io_threads=16</span><br><span class="line">innodb_read_io_threads=16</span><br><span class="line">innodb_thread_concurrency=16</span><br><span class="line">innodb_log_files_in_group=3</span><br><span class="line">innodb_max_dirty_pages_pct=90</span><br><span class="line"></span><br><span class="line">skip-name-resolve</span><br><span class="line">slow_query_log</span><br><span class="line">long_query_time=0.1</span><br><span class="line"></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_format=mixed</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">#auto-increment-increment=2</span><br><span class="line">#auto-increment-offset=1</span><br><span class="line">server-id=1</span><br><span class="line">log_slave_updates=1</span><br><span class="line">read_only=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">quote-names</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">#no-auto-rehash    # faster start of mysql but no tab completition</span><br><span class="line"></span><br><span class="line">[isamchk]</span><br><span class="line">key_buffer=16M</span><br><span class="line">max_allowed_packet=48M</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># * IMPORTANT: Additional settings that can override those from this file!</span><br><span class="line">#   The files must end with &#x27;.cnf&#x27;, otherwise they&#x27;ll be ignored.</span><br><span class="line">#</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure>
<h2 id="初始化-MySQL"><a href="#初始化-MySQL" class="headerlink" title="初始化 MySQL"></a>初始化 MySQL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql</span><br><span class="line">sudo scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql</span><br></pre></td></tr></table></figure>
<h2 id="创建软链接"><a href="#创建软链接" class="headerlink" title="创建软链接"></a>创建软链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/mysql/bin/* /usr/bin</span><br></pre></td></tr></table></figure>
<h2 id="启动-MySQL"><a href="#启动-MySQL" class="headerlink" title="启动 MySQL"></a>启动 MySQL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mysqld_safe --user=mysql --datadir=/data/mysql --pid-file=/var/run/mysqld/mysqld.pid &amp;amp;</span><br></pre></td></tr></table></figure>
<h2 id="停止-MySQL"><a href="#停止-MySQL" class="headerlink" title="停止 MySQL"></a>停止 MySQL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pkill -9 mysql</span><br></pre></td></tr></table></figure>
<h2 id="完成安装后的一些操作"><a href="#完成安装后的一些操作" class="headerlink" title="完成安装后的一些操作"></a>完成安装后的一些操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改root密码</span><br><span class="line">mysql -uroot</span><br><span class="line">use mysql</span><br><span class="line">update user set password=passworD(&quot;password&quot;) where user=&#x27;root&#x27;;</span><br><span class="line"></span><br><span class="line"># 允许root(或者其他用户)远程登录（可选，个人开发环境可以开启）</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;password&#x27; with grant option;</span><br><span class="line"></span><br><span class="line"># 删除匿名用户</span><br><span class="line">delete from mysql.user where user=&#x27;&#x27;;</span><br><span class="line"></span><br><span class="line"># 刷新权限表</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DBA</tag>
      </tags>
  </entry>
  <entry>
    <title>我应该使用哪个 Kubernetes apiVersion</title>
    <url>/2019/12/09/%E6%88%91%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AAKubernetes_apiVersion/</url>
    <content><![CDATA[<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>Kubernetes 中的对象定义需要 <code>apiVersion</code> 字段。当 Kubernetes 发布（更改其 API 中的某些内容）发行版更新时，将创建一个新的 <code>apiVersion</code> 。但是，官方的 Kubernetes 文档几乎没有提供关于 <code>apiVersion</code> 的指导。本指南提供了要使用的版本的备忘单，同时介绍了每个版本及其发行时间表。</p>
<p><strong>PS</strong>：<strong>只列出 v1.10+ 版本</strong></p>
<h2 id="1-kind-apiVersion-对应表"><a href="#1-kind-apiVersion-对应表" class="headerlink" title="1. kind apiVersion 对应表"></a>1. kind apiVersion 对应表</h2><p>|kind|apiVersion<br>|——<br>|CertificateSigningRequest|certificates.k8s.io&#x2F;v1beta1<br>|ClusterRoleBinding|rbac.authorization.k8s.io&#x2F;v1<br>|ClusterRole|rbac.authorization.k8s.io&#x2F;v1<br>|ComponentStatus|v1<br>|ConfigMap|v1<br>|ControllerRevision|apps&#x2F;v1<br>|CronJob|batch&#x2F;v1beta1<br>|DaemonSet|apps&#x2F;v1<br>|Deployment|apps&#x2F;v1<br>|Endpoints|v1<br>|Event|v1<br>|HorizontalPodAutoscaler|autoscaling&#x2F;v1<br>|Ingress|networking.k8s.io&#x2F;v1beta1<br>|Job|batch&#x2F;v1<br>|LimitRange|v1<br>|Namespace|v1<br>|NetworkPolicy|networking.k8s.io&#x2F;v1beta1<br>|Node|v1<br>|PersistentVolumeClaim|v1<br>|PersistentVolume|v1<br>|PodDisruptionBudget|policy&#x2F;v1beta1<br>|Pod|v1<br>|PodSecurityPolicy|policy&#x2F;v1beta1<br>|PodTemplate|v1<br>|ReplicaSet|apps&#x2F;v1<br>|ReplicationController|v1<br>|ResourceQuota|v1<br>|RoleBinding|rbac.authorization.k8s.io&#x2F;v1<br>|Role|rbac.authorization.k8s.io&#x2F;v1<br>|Secret|v1<br>|ServiceAccount|v1<br>|Service|v1<br>|StatefulSet|apps&#x2F;v1</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2>]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 Kubernetes 源码编译环境</title>
    <url>/2019/10/25/%E6%90%AD%E5%BB%BAkubernetes%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="0-Overview"><a href="#0-Overview" class="headerlink" title="0. Overview"></a>0. Overview</h2><p>虽然可以使用本地 golang 安装来构建 Kubernetes，但在 Docker 容器中运行的构建过程简化了初始设置，并提供了非常一致的构建和测试环境。尽管如此，本文还是会介绍本地 golang 和 Docker 容器两种构建方式，以供读者自由选择。</p>
<h2 id="1-本地-golang-构建（适用于对-Kubernetes-有二次开发-源码阅读需求的用户）"><a href="#1-本地-golang-构建（适用于对-Kubernetes-有二次开发-源码阅读需求的用户）" class="headerlink" title="1. 本地 golang 构建（适用于对 Kubernetes 有二次开发&#x2F;源码阅读需求的用户）"></a>1. 本地 golang 构建（适用于对 Kubernetes 有二次开发&#x2F;源码阅读需求的用户）</h2><h3 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h3><ul>
<li>安装 Golang</li>
</ul>
<p>见<a href="https://atompi.io/2019/11/30/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">如何快速构建一个 Go 语言开发环境</a></p>
<h3 id="1-2-下载-Kubernetes-源码"><a href="#1-2-下载-Kubernetes-源码" class="headerlink" title="1.2 下载 Kubernetes 源码"></a>1.2 下载 Kubernetes 源码</h3><p><a href="https://github.com/kubernetes/kubernetes">项目地址</a></p>
<p>项目默认分支为 <code>master</code> 可以使用以下命令下载指定分支 &#x2F; tag ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建并进入 Kubernetes 专用的 workdir ，如：</span><br><span class="line">mkdir -p /home/atompi/workdir/GolandProjects/Kubernetes</span><br><span class="line">cd /home/atompi/workdir/GolandProjects/Kubernetes</span><br><span class="line">export GOPATH=`pwd`</span><br><span class="line">mkdir -p $GOPATH/src/k8s.io</span><br><span class="line">cd $GOPATH/src/k8s.io</span><br><span class="line">git clone https://github.com/kubernetes/kubernetes -b &lt;branch name=&quot;&quot; tag=&quot;&quot;&gt;&lt;/branch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-编译"><a href="#1-3-编译" class="headerlink" title="1.3 编译"></a>1.3 编译</h3><p><code>KUBE_BUILD_PLATFORMS</code> 指定目标平台， <code>WHAT</code> 指定编译的组件，通过 <code>GOFLAGS</code> 和 <code>GOGCFLAGS</code> 传入编译时参数，如此处编译 <code>kubelet</code> 组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KUBE_BUILD_PLATFORMS=linux/amd64 make all WHAT=cmd/kubelet GOFLAGS=-v GOGCFLAGS=&quot;-N -l&quot;</span><br></pre></td></tr></table></figure>
<p>make 参数说明：</p>
<ul>
<li><code>WHAT</code> ：指定需要编译的包如 <code>WHAT=cmd/kubelet</code> ，如果不指定则编译全部</li>
<li><code>all</code> ：在本地环境中进行编译，相对于 <code>release</code> 、 <code>quick-release</code> 是在容器中完成编译并打包成 Docker 镜像，默认为 <code>all</code></li>
<li><code>clean</code> :清理编译结果以便重新编译</li>
</ul>
<h3 id="快速编译"><a href="#快速编译" class="headerlink" title="快速编译"></a>快速编译</h3><p>编译过程较长，编译后的文件在 <code>_output</code> 里。可以在 <code>cmd/xxx</code> 目录下执行 <code>go build -v</code> 构建当前平台下当前的二进制包，构建结果直接输出在当前文件夹。如快速构建 kubelet ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd cmd/kubelet</span><br><span class="line">go build -v</span><br></pre></td></tr></table></figure>
<h2 id="2-在-Docker-容器中运行构建"><a href="#2-在-Docker-容器中运行构建" class="headerlink" title="2. 在 Docker 容器中运行构建"></a>2. 在 Docker 容器中运行构建</h2><h3 id="2-1-环境要求"><a href="#2-1-环境要求" class="headerlink" title="2.1 环境要求"></a>2.1 环境要求</h3><p>只需要在本地安装 Docker daemon 即可</p>
<h3 id="2-2-关键性脚本（构建命令及说明）"><a href="#2-2-关键性脚本（构建命令及说明）" class="headerlink" title="2.2 关键性脚本（构建命令及说明）"></a>2.2 关键性脚本（构建命令及说明）</h3><p>以下脚本都可以在 <code>build/</code> 目录中找到。注意：所有脚本必须在 Kubernetes 根目录（即 <code>$GOPATH/src/k8s.io/kubernetes</code> ）运行。</p>
<li>`build/run.sh` ：在用来构建的 docker 容器中运行命令。常用的有以下调用参数：
<ul>
- `build/run.sh make`：运行构建，默认仅构建 linux 所有二进制文件。可以根据需要传递 make 参数来跨平台构建或者构建指定包，如下：
- `build/run.sh make cross` ：构建所有平台的所有二进制文件
- `build/run.sh make kubectl KUBE_BUILD_PLATFORMS=darwin/amd64` ：为特定平台构建特定二进制文件（如这行命令表示只构建 `darwin/amd64` 平台的 `kubelet` 二进制文件）
- `build/run.sh make test` ：运行所有单元测试
- `build/run.sh make test-integration` ：运行集成测试
- `build/run.sh make test-cmd` ：运行 CLI 测试

<p><code>build/copy-output.sh</code> ：将构建结果从 Docker 容器的 <code>_output/dockerized/bin</code> 文件夹复制到本地 <code>_output/dockerized/bin</code> 文件夹同时复制在构建过程中生成的特定文件属性。该命令已经在 <code>build/run.sh</code> 中自动运行，也可在完成构建后单独多次运行。</p>
<p><code>build/make-clean.sh</code> ：清除本地 <code>_output</code> 的内容，删除所有本地构建的容器镜像，删除 Docker 持久化数据卷，即清空构建过程中产生的所有文件。</p>
<p><code>build/shell.sh</code> ：进入挂载有当前代码的构建容器中，相当于 <code>docker exec -it &lt;container&gt; bash&lt;/container&gt;</code></p>
<h3 id="2-3-基本流程"><a href="#2-3-基本流程" class="headerlink" title="2.3 基本流程"></a>2.3 基本流程</h3><li>位于 `build/` 目录下（父目录下，不包含子目录下）的脚本用于构建和测试。这些脚本用于构建 `kube-build` Docker 镜像（基于 `build/build-image/Dockerfile` 构建），然后在基于该镜像启动的容器中执行构建命令。这些脚本同时确保每次运行都缓存正确的数据以进行增量构建，并将结果复制回容器。
</li>
<li>通过首先在 `_output/images/build-image` 中创建一个 `context` 目录来构建 `kube-build` 容器镜像。在 `context` 而不是在 `Kubernetes` 存储库的根目录进行镜像构建，可以以最大程度地减少构建镜像时需要打包的数据量。
</li>
<li>从此镜像运行 3 个不同的容器实例。第一个是持久化数据卷（ `data` ）容器，用于存储需要持久存储以支持增量构建的所有数据。接下来是一个同步（ `rsync` ）容器，用于将数据传入和传出到持久化数据卷容器。最后一个是构建（ `build` ）容器，用于实际执行构建操作。每次运行后，持久化数据卷容器在运行期间都将保留，而同步和构建容器将被删除。
</li>
<li>`rsync` 在后台透明地使用，以有效地将数据移入和移出容器。这将使用 Docker 选择的临时端口。您可以通过设置 `KUBE_RSYNC_PORT` 变量来修改它。
</li>
<li>所有 Docker 名称都以从文件路径派生的哈希作为后缀（以允许在 CI 机器上同时使用）和版本号。当版本号更改时，所有状态都将清除，并开始全新构建。这允许更改构建基础结构，并向 CI 系统发出需要删除旧工件的信号。
</li>

<h3 id="2-4-代理设置"><a href="#2-4-代理设置" class="headerlink" title="2.4 代理设置"></a>2.4 代理设置</h3><p>如果你需要通过代理上网，并且让这些脚本使用 docker-machine 在 macOS 上为你设置本地 VM ，则需要配置 Kubernetes 构建的代理设置，具体操作为定义以下环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KUBERNETES_HTTP_PROXY=http://username:password@proxyaddr:proxyport</span><br><span class="line">export KUBERNETES_HTTPS_PROXY=https://username:password@proxyaddr:proxyport</span><br></pre></td></tr></table></figure>
<p>同时可以选择为 Kubernetes 构建指定不需要代理的地址，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KUBERNETES_NO_PROXY=127.0.0.1</span><br></pre></td></tr></table></figure>
<p>如果使用 sudo 进行 Kubernetes 的构建（例如 <code>make quick-release</code> ），则需要运行 <code>sudo -E make quick-release</code> 来传递环境变量。</p>
<h3 id="2-5-使用远程-Docker-engine-构建（不推荐）"><a href="#2-5-使用远程-Docker-engine-构建（不推荐）" class="headerlink" title="2.5 使用远程 Docker engine 构建（不推荐）"></a>2.5 使用远程 Docker engine 构建（不推荐）</h3><p>原理同使用本地 Docker engine 构建，只是需要通过配置环境变量将远程的 Docker engine 当作本地使用（需要创建 SSH Tunnel 将本地 rsync 端口映射到远程以从远程将构建结果复制回本地）</p>
<p>详细操作这里不作介绍，可参考<a href="https://github.com/kubernetes/kubernetes/tree/master/build#really-remote-docker-engine">官方配置</a></p>
<h3 id="2-6-构建发行版"><a href="#2-6-构建发行版" class="headerlink" title="2.6 构建发行版"></a>2.6 构建发行版</h3><p><code>build/release.sh</code> 脚本将构建发行版。它将构建二进制文件、运行测试同时构建 Docker 映像（可选）。</p>
<p>构建结果是 tar 文件：主要是 <code>kubernetes.tar.gz</code> ，这个 tar 文件中包括：</p>
<ul>
<li>交叉编译的客户端。</li>
<li>kubectl ，用于基于平台选择和运行正确的客户端二进制文件。</li>
<li>Examples</li>
<li>各种云的集群部署脚本</li>
<li>包含所有服务端二进制文件的 tar 文件</li>
</ul>
<p>此外，还创建了其他一些 tar 文件：</p>
<ul>
<li><code>kubernetes-client-*.tar.gz</code> 特定平台的客户端二进制文件</li>
<li><code>kubernetes-server-*.tar.gz</code> 特定平台的服务端二进制文件</li>
</ul>
<p>构建最终发行版 tar 时，tar 包里面的文件会暂存在 <code>_output/release-stage</code> ，然后再将其打入 tar 包到 <code>_output/release-tars</code> 目录下。</p>
<h3 id="2-7-可重复性的构建环境（-Reproducible-Builds-项目）"><a href="#2-7-可重复性的构建环境（-Reproducible-Builds-项目）" class="headerlink" title="2.7 可重复性的构建环境（ Reproducible Builds 项目）"></a>2.7 可重复性的构建环境（ Reproducible Builds 项目）</h3><p>可重复性的构建是一组软件开发实践，可创建从源代码到二进制代码的独立可验证路径。见 <a href="https://reproducible-builds.org/docs/definition/">Reproducible builds</a></p>
<p><code>make release</code> 、其派生的 <code>make quick-release</code> 以及 <a href="https://www.bazel.build/">Bazel 构建工具</a> 都提供了一个封闭的构建环境，为构建提供一定程度的可重复性（ <code>make</code> 本身是不封闭的）。</p>
<p>Kubernetes 构建环境支持 Reproducible Builds 项目指定的 <a href="https://reproducible-builds.org/specs/source-date-epoch/"><code>SOURCE_DATE_EPOCH</code> 环境变量</a>，可以将其设置为 UNIX 时间戳。这将用于嵌入已编译的 Go 二进制文件中的构建时间戳，也许未来还会用于 Docker 映像。这个变量的一个合理设置是使用从正在构建的树的顶端开始的提交时间戳（这是Kubernetes CI 系统使用的）。例如，可以使用以下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SOURCE_DATE_EPOCH=$(git show -s --format=format:%ct HEAD)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 docker 源码编译环境</title>
    <url>/2019/01/28/%E6%90%AD%E5%BB%BAdocker%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="0-下载-moby-moby-源码"><a href="#0-下载-moby-moby-源码" class="headerlink" title="0. 下载 moby&#x2F;moby 源码"></a>0. 下载 moby&#x2F;moby 源码</h2><p>如果想要为 docker 贡献代码，则要进行以下步骤：</p>
<ol>
<li>Fork and clone the Moby code： Fork 后 clone moby 源码</li>
<li>Set your signature and an upstream remote：设置签名和上游 remote</li>
</ol>
<p>当你向 Docker 贡献代码时，你必须证明你同意（ <a href="http://developercertificate.org/">Developer Certificate of Origin</a> ）开发人员原产地证书。你通过签署你的 git 提交来表明您的同意，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Signed-off-by: Pat Smith &lt;pat.smith@email.com&gt;&lt;/pat.smith@email.com&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>具体做法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local user.name &quot;FirstName LastName&quot;    # 必须是真实姓名</span><br><span class="line">git config --local user.email &quot;emailname@mycompany.com&quot;    # 必须是有效可用的邮箱</span><br><span class="line">git remote add upstream https://github.com/moby/moby.git</span><br><span class="line"># 提交代码时使用 git commit -s 自动签署</span><br><span class="line">git commit -s -m &quot;Making a dry run test.&quot;</span><br></pre></td></tr></table></figure>
<h2 id="1-净化本地-Docker-环境-Remove-images-and-containers"><a href="#1-净化本地-Docker-环境-Remove-images-and-containers" class="headerlink" title="1. 净化本地 Docker 环境 Remove images and containers"></a>1. 净化本地 Docker 环境 Remove images and containers</h2><p><strong>这个步骤并非必要的，但是是推荐的： Moby developers run the latest stable release of the Docker software. They clean their local hosts of unnecessary Docker artifacts such as stopped containers or unused images. Cleaning unnecessary artifacts isn’t strictly necessary, but it is good practice, so it is included here.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker system prune -a</span><br></pre></td></tr></table></figure>
<h2 id="2-启动开发环境容器-Start-a-development-container"><a href="#2-启动开发环境容器-Start-a-development-container" class="headerlink" title="2. 启动开发环境容器 Start a development container"></a>2. 启动开发环境容器 Start a development container</h2><p>进入自己 fork 的 moby 项目 clone 目录，切换到某分支（如： <code>git checkout dry-run-test</code> ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make BIND_DIR=. shell    # 该命令会构建一个名为docker-dev:dry-run-test 的镜像</span><br></pre></td></tr></table></figure>
<p>执行结果：（容器运行命令会打印在终端并运行，之后要执行复制保存即可）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Successfully built 87f31121696f</span><br><span class="line">Successfully tagged docker-dev:overlay-vxlan-port</span><br><span class="line">docker run --rm -i --privileged  -e DOCKER_CROSSPLATFORMS -e BUILD_APT_MIRROR -e BUILDFLAGS -e KEEPBUNDLE -e DOCKER_BUILD_ARGS -e DOCKER_BUILD_GOGC -e DOCKER_BUILD_OPTS -e DOCKER_BUILD_PKGS -e DOCKER_BUILDKIT -e DOCKER_BASH_COMPLETION_PATH -e DOCKER_CLI_PATH -e DOCKER_DEBUG -e DOCKER_EXPERIMENTAL -e DOCKER_GITCOMMIT -e DOCKER_GRAPHDRIVER -e DOCKER_LDFLAGS -e DOCKER_PORT -e DOCKER_REMAP_ROOT -e DOCKER_STORAGE_OPTS -eDOCKER_USERLANDPROXY -e DOCKERD_ARGS -e TEST_INTEGRATION_DIR -e TESTDIRS -e TESTFLAGS -e TIMEOUT -e HTTP_PROXY -e HTTPS_PROXY -e NO_PROXY -e http_proxy -e https_proxy -e no_proxy -e VERSION -e PLATFORM -e DEFAULT_PRODUCT_LICENSE -e PRODUCT -v &quot;/home/atompi/GolandProjects/src/github.com/mission802/moby/.:/go/src/github.com/docker/docker/.&quot; -v &quot;/home/atompi/GolandProjects/src/github.com/mission802/moby/.git:/go/src/github.com/docker/docker/.git&quot; -v docker-dev-cache:/root/.cache    -t &quot;docker-dev:overlay-vxlan-port&quot; bash</span><br></pre></td></tr></table></figure>
<p>启动容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm -i --privileged  -e DOCKER_CROSSPLATFORMS -e BUILD_APT_MIRROR -e BUILDFLAGS -e KEEPBUNDLE -e DOCKER_BUILD_ARGS -e DOCKER_BUILD_GOGC -e DOCKER_BUILD_OPTS -e DOCKER_BUILD_PKGS -e DOCKER_BUILDKIT -e DOCKER_BASH_COMPLETION_PATH -e DOCKER_CLI_PATH -e DOCKER_DEBUG -e DOCKER_EXPERIMENTAL -e DOCKER_GITCOMMIT -e DOCKER_GRAPHDRIVER -e DOCKER_LDFLAGS -e DOCKER_PORT -e DOCKER_REMAP_ROOT -e DOCKER_STORAGE_OPTS -eDOCKER_USERLANDPROXY -e DOCKERD_ARGS -e TEST_INTEGRATION_DIR -e TESTDIRS -e TESTFLAGS -e TIMEOUT -e HTTP_PROXY -e HTTPS_PROXY -e NO_PROXY -e http_proxy -e https_proxy -e no_proxy -e VERSION -e PLATFORM -e DEFAULT_PRODUCT_LICENSE -e PRODUCT -v &quot;/home/atompi/GolandProjects/src/github.com/mission802/moby/.:/go/src/github.com/docker/docker/.&quot; -v &quot;/home/atompi/GolandProjects/src/github.com/mission802/moby/.git:/go/src/github.com/docker/docker/.git&quot; -v docker-dev-cache:/root/.cache    -t &quot;docker-dev:overlay-vxlan-port&quot; bash</span><br></pre></td></tr></table></figure>
<p>构建 <code>dockerd</code> 二进制文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hack/make.sh binary</span><br></pre></td></tr></table></figure>
<p>运行 <code>make install</code> ，将二进制文件复制到容器的 <code>/usr/local/bin/</code> 目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>启动在后台运行的 Engine 守护程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dockerd -D &amp;amp;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（10） -- whereis, which</title>
    <url>/2018/01/09/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-10/</url>
    <content><![CDATA[<h2 id="查找命令相关路径-whereis"><a href="#查找命令相关路径-whereis" class="headerlink" title="查找命令相关路径 whereis"></a>查找命令相关路径 whereis</h2><h3 id="依次列出源文件、可执行文件、手册页文件"><a href="#依次列出源文件、可执行文件、手册页文件" class="headerlink" title="依次列出源文件、可执行文件、手册页文件"></a>依次列出源文件、可执行文件、手册页文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure>
<h3 id="只列出可执行文件"><a href="#只列出可执行文件" class="headerlink" title="只列出可执行文件"></a>只列出可执行文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# whereis -b ls</span><br><span class="line">ls: /bin/ls</span><br></pre></td></tr></table></figure>
<h3 id="只列出手册页文件"><a href="#只列出手册页文件" class="headerlink" title="只列出手册页文件"></a>只列出手册页文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# whereis -m ls</span><br><span class="line">ls: /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure>
<h2 id="查找命令被执行时的可执行文件路径-which"><a href="#查找命令被执行时的可执行文件路径-which" class="headerlink" title="查找命令被执行时的可执行文件路径 which"></a>查找命令被执行时的可执行文件路径 which</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# which ls</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（1） -- 导航文件系统</title>
    <url>/2017/12/31/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-1/</url>
    <content><![CDATA[<h2 id="导航文件系统"><a href="#导航文件系统" class="headerlink" title="导航文件系统"></a>导航文件系统</h2><h3 id="列出当前目录的文件和文件夹"><a href="#列出当前目录的文件和文件夹" class="headerlink" title="列出当前目录的文件和文件夹"></a>列出当前目录的文件和文件夹</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls</span><br><span class="line">anaconda2  atomsrc  Documents  Downloads  Templates</span><br></pre></td></tr></table></figure>
<h3 id="列出指定目录的文件和文件夹"><a href="#列出指定目录的文件和文件夹" class="headerlink" title="列出指定目录的文件和文件夹"></a>列出指定目录的文件和文件夹</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls Downloads</span><br><span class="line">Anaconda2-5.0.1-Linux-x86_64.sh  mysql-5.6.38  mysql-5.6.38.tar.gz  redis-3.2.11  redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="使用通配符列出文件夹内容"><a href="#使用通配符列出文件夹内容" class="headerlink" title="使用通配符列出文件夹内容"></a>使用通配符列出文件夹内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls ~/Downloads/*.tar.gz</span><br><span class="line">/home/atompi/Downloads/mysql-5.6.38.tar.gz  /home/atompi/Downloads/redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="查看子文件夹中的文件列表"><a href="#查看子文件夹中的文件列表" class="headerlink" title="查看子文件夹中的文件列表"></a>查看子文件夹中的文件列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -R ~/Documents</span><br><span class="line">/home/atompi/Documents:</span><br><span class="line">Templates</span><br><span class="line"></span><br><span class="line">/home/atompi/Documents/Templates:</span><br><span class="line">DockerFiles</span><br><span class="line"></span><br><span class="line">/home/atompi/Documents/Templates/DockerFiles:</span><br><span class="line">dockerfiles  docker_images</span><br><span class="line"></span><br><span class="line">/home/atompi/Documents/Templates/DockerFiles/dockerfiles:</span><br><span class="line">IDEA-licsrv</span><br><span class="line"></span><br><span class="line">/home/atompi/Documents/Templates/DockerFiles/dockerfiles/IDEA-licsrv:</span><br><span class="line">Dockerfile  linux.tar.gz  README.md</span><br><span class="line"></span><br><span class="line">/home/atompi/Documents/Templates/DockerFiles/docker_images:</span><br><span class="line">idealicsrv100.tar</span><br></pre></td></tr></table></figure>
<h3 id="以单独一列显示内容列表"><a href="#以单独一列显示内容列表" class="headerlink" title="以单独一列显示内容列表"></a>以单独一列显示内容列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -1 ~/Downloads</span><br><span class="line">Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">mysql-5.6.38</span><br><span class="line">mysql-5.6.38.tar.gz</span><br><span class="line">redis-3.2.11</span><br><span class="line">redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="以逗号分隔列表显示内容"><a href="#以逗号分隔列表显示内容" class="headerlink" title="以逗号分隔列表显示内容"></a>以逗号分隔列表显示内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -m ~/Downloads</span><br><span class="line">Anaconda2-5.0.1-Linux-x86_64.sh, mysql-5.6.38, mysql-5.6.38.tar.gz, redis-3.2.11, redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="查看隐藏的文件和文件夹"><a href="#查看隐藏的文件和文件夹" class="headerlink" title="查看隐藏的文件和文件夹"></a>查看隐藏的文件和文件夹</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -a ~/Downloads</span><br><span class="line">.  ..  Anaconda2-5.0.1-Linux-x86_64.sh  mysql-5.6.38  mysql-5.6.38.tar.gz  redis-3.2.11  redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="直观显示文件的类型"><a href="#直观显示文件的类型" class="headerlink" title="直观显示文件的类型"></a>直观显示文件的类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -F /usr/local/bin</span><br><span class="line">ansible*             ansible-console@  ansible-inventory@  ansible-vault@    redis-check-aof*  redis-sentinel@  ssserver*</span><br><span class="line">ansible-config@      ansible-doc@      ansible-playbook@   proxy*            redis-check-rdb*  redis-server*    startss.sh*</span><br><span class="line">ansible-connection*  ansible-galaxy@   ansible-pull@       redis-benchmark*  redis-cli*        sslocal*         virtualenv*</span><br></pre></td></tr></table></figure>
<h3 id="列出权限、所有者等其他信息"><a href="#列出权限、所有者等其他信息" class="headerlink" title="列出权限、所有者等其他信息"></a>列出权限、所有者等其他信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -l ~/Downloads</span><br><span class="line">total 552872</span><br><span class="line">-rw-rw-r--  1 atompi atompi 532375438 Oct 25 09:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">drwxr-xr-x 36 atompi atompi      4096 Jan  5 05:59 mysql-5.6.38</span><br><span class="line">-rw-rw-r--  1 atompi atompi  32197625 Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">drwxrwxr-x  6 atompi atompi      4096 Sep 21 07:20 redis-3.2.11</span><br><span class="line">-rw-rw-r--  1 atompi atompi   1550452 Sep 21 07:20 redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="以倒序列出文件夹内容"><a href="#以倒序列出文件夹内容" class="headerlink" title="以倒序列出文件夹内容"></a>以倒序列出文件夹内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -lr ~/Downloads</span><br><span class="line">total 552872</span><br><span class="line">-rw-rw-r--  1 atompi atompi   1550452 Sep 21 07:20 redis-3.2.11.tar.gz</span><br><span class="line">drwxrwxr-x  6 atompi atompi      4096 Sep 21 07:20 redis-3.2.11</span><br><span class="line">-rw-rw-r--  1 atompi atompi  32197625 Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">drwxr-xr-x 36 atompi atompi      4096 Jan  5 05:59 mysql-5.6.38</span><br><span class="line">-rw-rw-r--  1 atompi atompi 532375438 Oct 25 09:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<h3 id="按日期和时间排序文件夹内容"><a href="#按日期和时间排序文件夹内容" class="headerlink" title="按日期和时间排序文件夹内容"></a>按日期和时间排序文件夹内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -latr ~/Downloads</span><br><span class="line">total 552880</span><br><span class="line">-rw-rw-r--  1 atompi atompi  32197625 Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">drwxrwxr-x  6 atompi atompi      4096 Sep 21 07:20 redis-3.2.11</span><br><span class="line">-rw-rw-r--  1 atompi atompi   1550452 Sep 21 07:20 redis-3.2.11.tar.gz</span><br><span class="line">-rw-rw-r--  1 atompi atompi 532375438 Oct 25 09:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">drwxr-xr-x 36 atompi atompi      4096 Jan  5 05:59 mysql-5.6.38</span><br><span class="line">drwxrwxr-x  4 atompi atompi      4096 Jan  5 06:06 .</span><br><span class="line">drwxr-xr-x 19 atompi atompi      4096 Jan  6 03:08 ..</span><br></pre></td></tr></table></figure>
<h3 id="按文件大小排序文件夹内容"><a href="#按文件大小排序文件夹内容" class="headerlink" title="按文件大小排序文件夹内容"></a>按文件大小排序文件夹内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -laS ~/Downloads</span><br><span class="line">total 552880</span><br><span class="line">-rw-rw-r--  1 atompi atompi 532375438 Oct 25 09:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">-rw-rw-r--  1 atompi atompi  32197625 Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">-rw-rw-r--  1 atompi atompi   1550452 Sep 21 07:20 redis-3.2.11.tar.gz</span><br><span class="line">drwxrwxr-x  4 atompi atompi      4096 Jan  5 06:06 .</span><br><span class="line">drwxr-xr-x 19 atompi atompi      4096 Jan  6 03:10 ..</span><br><span class="line">drwxr-xr-x 36 atompi atompi      4096 Jan  5 05:59 mysql-5.6.38</span><br><span class="line">drwxrwxr-x  6 atompi atompi      4096 Sep 21 07:20 redis-3.2.11</span><br></pre></td></tr></table></figure>
<h3 id="用-K-、-M-、-G表示文件大小"><a href="#用-K-、-M-、-G表示文件大小" class="headerlink" title="用 K 、 M 、 G表示文件大小"></a>用 K 、 M 、 G表示文件大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -laSh ~/Downloads</span><br><span class="line">total 540M</span><br><span class="line">-rw-rw-r--  1 atompi atompi 508M Oct 25 09:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">-rw-rw-r--  1 atompi atompi  31M Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">-rw-rw-r--  1 atompi atompi 1.5M Sep 21 07:20 redis-3.2.11.tar.gz</span><br><span class="line">drwxrwxr-x  4 atompi atompi 4.0K Jan  5 06:06 .</span><br><span class="line">drwxr-xr-x 19 atompi atompi 4.0K Jan  6 03:12 ..</span><br><span class="line">drwxr-xr-x 36 atompi atompi 4.0K Jan  5 05:59 mysql-5.6.38</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Sep 21 07:20 redis-3.2.11</span><br></pre></td></tr></table></figure>
<h3 id="显示当前目录路径"><a href="#显示当前目录路径" class="headerlink" title="显示当前目录路径"></a>显示当前目录路径</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ pwd</span><br><span class="line">/home/atompi</span><br></pre></td></tr></table></figure>
<h3 id="更改当前目录"><a href="#更改当前目录" class="headerlink" title="更改当前目录"></a>更改当前目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ pwd</span><br><span class="line">/home/atompi</span><br><span class="line">➜  ~ cd /usr/local/bin</span><br><span class="line">➜  bin pwd</span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure>
<h3 id="回到之前的目录"><a href="#回到之前的目录" class="headerlink" title="回到之前的目录"></a>回到之前的目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ pwd</span><br><span class="line">/home/atompi</span><br><span class="line">➜  ~ cd /usr/local/bin</span><br><span class="line">➜  bin pwd</span><br><span class="line">/usr/local/bin</span><br><span class="line">➜  bin cd -</span><br><span class="line">~</span><br><span class="line">➜  ~ pwd</span><br><span class="line">/home/atompi</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（11） -- file</title>
    <url>/2018/01/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-11/</url>
    <content><![CDATA[<h2 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# file 每天一个Linux命令-11.md</span><br><span class="line">每天一个Linux命令-11.md: UTF-8 Unicode text</span><br><span class="line"></span><br><span class="line">root@atompi:~# file atompi.io.tar.gz</span><br><span class="line">atompi.io.tar.gz: gzip compressed data, last modified: Sun Jan  7 03:07:23 2018, from Unix</span><br></pre></td></tr></table></figure>
<h2 id="尝试查看压缩文件内部信息"><a href="#尝试查看压缩文件内部信息" class="headerlink" title="尝试查看压缩文件内部信息"></a>尝试查看压缩文件内部信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# file -z atompi.io.tar.gz</span><br><span class="line">atompi.io.tar.gz: POSIX tar archive (GNU) (gzip compressed data, last modified: Sun Jan  7 03:07:23 2018, from Unix)</span><br></pre></td></tr></table></figure>
<p>对文件的类型存有疑问？对该文件运行 <code>file</code> 命令！</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（12） -- cat</title>
    <url>/2018/01/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-12/</url>
    <content><![CDATA[<h2 id="在标准输出设备上查看文件内容"><a href="#在标准输出设备上查看文件内容" class="headerlink" title="在标准输出设备上查看文件内容"></a>在标准输出设备上查看文件内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# cat 每天一个Linux命令-11.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（11） -- file</span><br><span class="line">date: 2018-01-11 21:31:34</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 查看文件类型</span><br></pre></td></tr></table></figure>
<h2 id="同时查看多个文件（多个文件拼接输出）"><a href="#同时查看多个文件（多个文件拼接输出）" class="headerlink" title="同时查看多个文件（多个文件拼接输出）"></a>同时查看多个文件（多个文件拼接输出）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# echo &quot;test1&quot; &amp;gt; test1</span><br><span class="line">root@atompi:~# echo &quot;test2&quot; &amp;gt; test2</span><br><span class="line">root@atompi:~# cat test1 test2</span><br><span class="line">test1</span><br><span class="line">test2</span><br></pre></td></tr></table></figure>
<h2 id="输出时显示行号"><a href="#输出时显示行号" class="headerlink" title="输出时显示行号"></a>输出时显示行号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# cat test1 test2 -n</span><br><span class="line">     1	test1</span><br><span class="line">     2	test2</span><br></pre></td></tr></table></figure>
<h2 id="将多个文件拼接成一个新文件"><a href="#将多个文件拼接成一个新文件" class="headerlink" title="将多个文件拼接成一个新文件"></a>将多个文件拼接成一个新文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# cat test1 test2 &amp;gt; test3</span><br><span class="line">root@atompi:~# cat test3</span><br><span class="line">test1</span><br><span class="line">test2</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（13） -- less</title>
    <url>/2018/01/12/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-13/</url>
    <content><![CDATA[<h2 id="逐屏查看文本文件"><a href="#逐屏查看文本文件" class="headerlink" title="逐屏查看文本文件"></a>逐屏查看文本文件</h2><th align="center">按键命令</th><th align="center">操作</th>
|------
<td align="center">PageDn 、 e 或空格</td><td align="center">向下翻页</td>
<td align="center">PageUp 或 b</td><td align="center">向上翻页</td>
<td align="center">Enter 、 e 、 j 或下箭头键</td><td align="center">向下一行</td>
<td align="center">y 、 k 、 或上箭头键</td><td align="center">向上一行</td>
<td align="center">G 或 p</td><td align="center">跳到文件尾部</td>
<td align="center">1G</td><td align="center">跳到文件开头</td>
<td align="center">q</td><td align="center">退出less</td>
<td align="center">=</td><td align="center">显示文件信息</td>
<td align="center">v</td><td align="center">编辑当前文件</td>
<td align="center">/</td><td align="center">搜索</td>
<td align="center">n</td><td align="center">向前搜索</td>
<td align="center">N</td><td align="center">向后搜索</td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# less 每天一个Linux命令-12.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（12） -- cat</span><br><span class="line">date: 2018-01-12 21:45:15</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 在标准输出设备上查看文件内容</span><br><span class="line"></span><br><span class="line">root@atompi:~# cat 每天一个Linux命令-11.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（11） -- file</span><br><span class="line">date: 2018-01-11 21:31:34</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 查看文件类型</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 同时查看多个文件（多个文件拼接输出）</span><br><span class="line"></span><br><span class="line">root@atompi:~# echo &quot;test1&quot; &amp;gt; test1</span><br><span class="line">atompi.io/source/_posts/每天一个Linux命令-12.md</span><br></pre></td></tr></table></figure>
<h2 id="在-less-下进入编辑文件时，指定编辑器："><a href="#在-less-下进入编辑文件时，指定编辑器：" class="headerlink" title="在 less 下进入编辑文件时，指定编辑器："></a>在 less 下进入编辑文件时，指定编辑器：</h2><p>使用 less 前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export EDITOR=vim</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（14） -- head</title>
    <url>/2018/01/13/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-14/</url>
    <content><![CDATA[<h2 id="查看文件前-10-行内容"><a href="#查看文件前-10-行内容" class="headerlink" title="查看文件前 10 行内容"></a>查看文件前 10 行内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# head 每天一个Linux命令-13.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（13） -- less</span><br><span class="line">date: 2018-01-13 21:52:54</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="查看多个文件前-10-行内容"><a href="#查看多个文件前-10-行内容" class="headerlink" title="查看多个文件前 10 行内容"></a>查看多个文件前 10 行内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# head 每天一个Linux命令-12.md 每天一个Linux命令-13.md</span><br><span class="line">==&amp;gt; 每天一个Linux命令-12.md &amp;lt;==</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（12） -- cat</span><br><span class="line">date: 2018-01-12 21:45:15</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==&amp;gt; 每天一个Linux命令-13.md &amp;lt;==</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（13） -- less</span><br><span class="line">date: 2018-01-13 21:52:54</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="查看文件前-n-行"><a href="#查看文件前-n-行" class="headerlink" title="查看文件前 n 行"></a>查看文件前 n 行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# head -n 3 每天一个Linux命令-13.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（13） -- less</span><br><span class="line">date: 2018-01-13 21:52:54</span><br></pre></td></tr></table></figure>
<h2 id="查看文件前-c-字节内容"><a href="#查看文件前-c-字节内容" class="headerlink" title="查看文件前 c 字节内容"></a>查看文件前 c 字节内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# head -c 3 每天一个Linux命令-13.md</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">root@atompi:~# head -c 10 每天一个Linux命令-13.md</span><br><span class="line">---</span><br><span class="line">title:</span><br><span class="line"></span><br><span class="line">root@atompi:~# head -c 100 每天一个Linux命令-13.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（13） -- less</span><br><span class="line">date: 2018-01-13 21:52:54</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - s</span><br><span class="line"></span><br><span class="line">root@atompi:~# head -c 1KB 每天一个Linux命令-13.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（13） -- less</span><br><span class="line">date: 2018-01-13 21:52:54</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 逐屏查看文本文件</span><br><span class="line"></span><br><span class="line">|按键命令|操作|</span><br><span class="line">|:--:|:--:|</span><br><span class="line">|PageDn 、 e 或空格|向下翻页|</span><br><span class="line">|PageUp 或 b|向上翻页|</span><br><span class="line">|Enter 、 e 、 j 或下箭头键|向下一行|</span><br><span class="line">|y 、 k 、 或上箭头键|向上一行|</span><br><span class="line">|G 或 p|跳到文件尾部|</span><br><span class="line">|1G|跳到文件开头|</span><br><span class="line">|q|退出less|</span><br><span class="line">|=|显示文件信息|</span><br><span class="line">|v|编辑当前文件|</span><br><span class="line">|/|搜索|</span><br><span class="line">|n|向前搜索|</span><br><span class="line">|N|向后搜索|</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">root@atompi:~# less 每天一个Linux命令-12.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（12） -- cat</span><br><span class="line">date: 2018-01-12 21:45:15</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 在标准输出设备上查看文件内容</span><br><span class="line"></span><br><span class="line">root@atompi:~# cat 每天一个Linux命令-11.md</span><br><span class="line">---</span><br><span class="line">title: 每天一个 Linux 命令（11） -- file</span><br><span class="line">date: 2018-01-11 21:31:34</span><br><span class="line">tags:</span><br><span class="line">  - Linux</span><br><span class="line">  - shell</span><br><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 查看文件类型</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 同时查看多个文</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（15） -- wc</title>
    <url>/2018/01/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-15/</url>
    <content><![CDATA[<p>统计文件的字节数、字数、行数</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>wc 命令</strong> 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用 wc 指令我们可以计算文件的 Byte 数、字数或是列数，若不指定文件名称，或是所给予的文件名为 “-” ，则 wc 指令会从标准输入设备读取数据。 wc 同时也给出所指定文件的总统计数。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc (选项) (参数)</span><br><span class="line">wc [选项]... [文件]...</span><br><span class="line">wc [选项]... --files0-from=F</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-c <span class="comment"># 统计字节数，或 --bytes 或 --chars ：只显示 Bytes 数；。</span></span><br><span class="line">-l <span class="comment"># 统计行数，或 --lines ：只显示列数；。</span></span><br><span class="line">-m <span class="comment"># 统计字符数。这个标志不能与 -c 标志一起使用。</span></span><br><span class="line">-w <span class="comment"># 统计字数，或 --words ：只显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</span></span><br><span class="line">-L <span class="comment"># 打印最长行的长度。</span></span><br><span class="line">-<span class="built_in">help</span>     <span class="comment"># 显示帮助信息</span></span><br><span class="line">--version <span class="comment"># 显示版本信息</span></span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件：需要统计的文件列表。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l *       <span class="comment"># 统计当前目录下的所有文件行数</span></span><br><span class="line"><span class="built_in">wc</span> -l *.js    <span class="comment"># 统计当前目录下的所有 .js 后缀的文件行数</span></span><br><span class="line">find  . * | xargs <span class="built_in">wc</span> -l <span class="comment"># 当前目录以及子目录的所有文件行数</span></span><br><span class="line"><span class="built_in">wc</span> test.txt   <span class="comment"># 查看文件的字节数、字数、行数</span></span><br></pre></td></tr></table></figure>
<p>查看文件的字节数、字数、行数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> test.txt</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">7     8     70     test.txt</span><br><span class="line">行数 单词数 字节数 文件名</span><br></pre></td></tr></table></figure>
<p>用 wc 命令怎么做到只打印统计数字不打印文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l test.txt</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">7 test.txt</span><br></pre></td></tr></table></figure>
<p>用来统计当前目录下的文件数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（16） -- nl</title>
    <url>/2018/01/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-16/</url>
    <content><![CDATA[<p>在Linux系统中计算文件内容行号</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>nl命令</strong> 读取 file 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。除非使用 <code>-p</code> 选项，nl 命令在每个逻辑页开始的地方重新设置行号。可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。其默认的结果与 <code>cat -n</code> 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐0等等的功能。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b ：指定行号指定的方式，主要有两种：</span><br><span class="line">    -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</span><br><span class="line">    -b t ：如果有空行，空的那一行不要列出行号(默认值)；</span><br><span class="line"></span><br><span class="line">-n ：列出行号表示的方法，主要有三种：</span><br><span class="line">    -n ln ：行号在萤幕的最左方显示；</span><br><span class="line">    -n rn ：行号在自己栏位的最右方显示，且不加 0 ；</span><br><span class="line">    -n rz ：行号在自己栏位的最右方显示，且加 0 ；</span><br><span class="line"></span><br><span class="line">-w ：行号栏位的占用的位数。</span><br><span class="line">-p ：在逻辑定界符处不重新开始计算。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> <strong>用 nl 列出 log2015.log 的内容</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@localhost [test]# nl log2015.log</span><br><span class="line">1 2015-01</span><br><span class="line">2 2015-02</span><br><span class="line"></span><br><span class="line">3 ======[root@localhost test]#</span><br></pre></td></tr></table></figure>
<p>说明：文件中的空白行，nl 不会加上行号</p>
<p> <strong>用 nl 列出 log2015.log 的内容，空本行也加上行号</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# nl -b a log2015.log</span><br><span class="line">1 2015-01</span><br><span class="line">2 2015-02</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5 ======[root@localhost test]#</span><br></pre></td></tr></table></figure>
<p> <strong>让行号前面自动补上0，统一输出格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# nl -b a -n rz log2015.log</span><br><span class="line">000001 2015-01</span><br><span class="line">000002 2015-02</span><br><span class="line">000003 2015-03</span><br><span class="line">000004 2015-04</span><br><span class="line">000005 2015-05</span><br><span class="line">000006 2015-06</span><br><span class="line">000007 2015-07</span><br><span class="line">000008 2015-08</span><br><span class="line">000009 2015-09</span><br><span class="line">000010 2015-10</span><br><span class="line">000011 2015-11</span><br><span class="line">000012 2015-12</span><br><span class="line">000013 =======</span><br><span class="line"></span><br><span class="line">[root@localhost test]# nl -b a -n rz -w 3 log2015.log</span><br><span class="line">001 2015-01</span><br><span class="line">002 2015-02</span><br><span class="line">003 2015-03</span><br><span class="line">004 2015-04</span><br><span class="line">005 2015-05</span><br><span class="line">006 2015-06</span><br><span class="line">007 2015-07</span><br><span class="line">008 2015-08</span><br><span class="line">009 2015-09</span><br><span class="line">010 2015-10</span><br><span class="line">011 2015-11</span><br><span class="line">012 2015-12</span><br><span class="line">013 =======</span><br></pre></td></tr></table></figure>
<p>说明：<code>nl -b a -n rz</code> 命令行号默认为六位，要调整位数可以加上参数 <code>-w 3</code> 调整为3位。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（17） -- cut</title>
    <url>/2018/01/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-17/</url>
    <content><![CDATA[<p>连接文件并打印到标准输出设备上</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>cut 命令</strong> 用来显示行中的指定部分，删除文件中指定字段。 cut 经常用来显示文件的内容，类似于下的 type 命令。</p>
<p>说明：该命令有两项功能，其一是用来显示文件的内容，它依次读取由参数file所指 明的文件，将它们的内容输出到标准输出上；其二是连接两个或多个文件，如 <code>cut fl f2 &amp;gt; f3</code> 将把文件fl和几的内容合并起来，然后通过输出重定向符 “&gt;” 的作用，将它们放入文件f3中。</p>
<p>当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more 等命令分屏显示。为了控制滚屏，可以按 Ctrl+S 键，停止滚屏；按 Ctrl+Q 键可以恢复滚屏。按 Ctrl+C（中断）键可以终止该命令的执行，并且返回 Shell 提示符状态。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b：仅显示行中指定直接范围的内容；</span><br><span class="line">-c：仅显示行中指定范围的字符；</span><br><span class="line">-d：指定字段的分隔符，默认的字段分隔符为“TAB”；</span><br><span class="line">-f：显示指定字段的内容；</span><br><span class="line">-n：与“-b”选项连用，不分割多字节字符；</span><br><span class="line">--complement：补足被选择的字节、字符或字段；</span><br><span class="line">--out-delimiter=&amp;lt;字段分隔符&amp;gt;：指定输出内容是的字段分割符；</span><br><span class="line">--help：显示指令的帮助信息；</span><br><span class="line">--version：显示指令的版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件：指定要进行内容过滤的文件。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>例如有一个学生报表信息，包含 No 、 Name 、 Mark 、 Percent ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test.txt</span><br><span class="line">No Name Mark Percent</span><br><span class="line">01 tom 69 91</span><br><span class="line">02 jack 71 87</span><br><span class="line">03 alex 68 98</span><br></pre></td></tr></table></figure>
<p>使用  <strong>-f</strong>  选项提取指定字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f 1 test.txt</span><br><span class="line">No</span><br><span class="line">01</span><br><span class="line">02</span><br><span class="line">03</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2,3 test.txt</span><br><span class="line">Name Mark</span><br><span class="line">tom 69</span><br><span class="line">jack 71</span><br><span class="line">alex 68</span><br></pre></td></tr></table></figure>
<p> <strong>–complement</strong>  选项提取指定字段之外的列（打印除了第二列之外的列）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2 --complement test.txt</span><br><span class="line">No Mark Percent</span><br><span class="line">01 69 91</span><br><span class="line">02 71 87</span><br><span class="line">03 68 98</span><br></pre></td></tr></table></figure>
<p>使用  <strong>-d</strong>  选项指定字段分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test2.txt</span><br><span class="line">No;Name;Mark;Percent</span><br><span class="line">01;tom;69;91</span><br><span class="line">02;jack;71;87</span><br><span class="line">03;alex;68;98</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -f2 -d&quot;;&quot; test2.txt</span><br><span class="line">Name</span><br><span class="line">tom</span><br><span class="line">jack</span><br><span class="line">alex</span><br></pre></td></tr></table></figure>
<h2 id="指定字段的字符或者字节范围"><a href="#指定字段的字符或者字节范围" class="headerlink" title="指定字段的字符或者字节范围"></a>指定字段的字符或者字节范围</h2><p>cut 命令可以将一串字符作为列来显示，字符字段的记法：</p>
<ul>
<li><strong>N-</strong> ：从第 N 个字节、字符、字段到结尾；</li>
<li><strong>N-M</strong> ：从第 N 个字节、字符、字段到第 M 个（包括 M 在内）字节、字符、字段；</li>
<li><strong>-M</strong> ：从第 1 个字节、字符、字段到第 M 个（包括 M 在内）字节、字符、字段。</li>
</ul>
<p>上面是记法，结合下面选项将摸个范围的字节、字符指定为字段：</p>
<li>**-b**  表示字节；
</li>
<li>**-c**  表示字符；
</li>
<li>**-f**  表示定义字段。
**示例**
</li>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cat test.txt</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>
<p>打印第 1 个到第 3 个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c1-3 test.txt</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<p>打印前 2 个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c-2 test.txt</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br><span class="line">ab</span><br></pre></td></tr></table></figure>
<p>打印从第 5 个字符开始到结尾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# cut -c5- test.txt</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br><span class="line">efghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（18） -- sort</title>
    <url>/2018/01/17/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-18/</url>
    <content><![CDATA[<p>将文件进行排序并输出</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>sort命令</strong> 是在 Linux 里非常有用，它将文件进行排序，并将排序结果标准输出。sort 命令既可以从特定的文件，也可以从 stdin 中获取输入。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b：忽略每行前面开始出的空格字符；</span><br><span class="line">-c：检查文件是否已经按照顺序排序；</span><br><span class="line">-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；</span><br><span class="line">-f：排序时，将小写字母视为大写字母；</span><br><span class="line">-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</span><br><span class="line">-m：将几个排序号的文件进行合并；</span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序；</span><br><span class="line">-n：依照数值的大小排序；</span><br><span class="line">-o&amp;lt;输出文件&amp;gt;：将排序后的结果存入制定的文件；</span><br><span class="line">-r：以相反的顺序来排序；</span><br><span class="line">-t&amp;lt;分隔字符&amp;gt;：指定排序时所用的栏位分隔字符；</span><br><span class="line">+&amp;lt;起始栏位&amp;gt;-&amp;lt;结束栏位&amp;gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件：指定待排序的文件列表。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>sort将文件&#x2F;文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@[mail text]# cat sort.txt</span><br><span class="line">aaa:10:1.1</span><br><span class="line">ccc:30:3.3</span><br><span class="line">ddd:40:4.4</span><br><span class="line">bbb:20:2.2</span><br><span class="line">eee:50:5.5</span><br><span class="line">eee:50:5.5</span><br><span class="line"></span><br><span class="line">[root@mail text]# sort sort.txt</span><br><span class="line">aaa:10:1.1</span><br><span class="line">bbb:20:2.2</span><br><span class="line">ccc:30:3.3</span><br><span class="line">ddd:40:4.4</span><br><span class="line">eee:50:5.5</span><br><span class="line">eee:50:5.5</span><br></pre></td></tr></table></figure>
<p>忽略相同行使用-u选项或者uniq：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@mail text]# cat sort.txt</span><br><span class="line">aaa:10:1.1</span><br><span class="line">ccc:30:3.3</span><br><span class="line">ddd:40:4.4</span><br><span class="line">bbb:20:2.2</span><br><span class="line">eee:50:5.5</span><br><span class="line">eee:50:5.5</span><br><span class="line"></span><br><span class="line">[root@mail text]# sort -u sort.txt</span><br><span class="line">aaa:10:1.1</span><br><span class="line">bbb:20:2.2</span><br><span class="line">ccc:30:3.3</span><br><span class="line">ddd:40:4.4</span><br><span class="line">eee:50:5.5</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">[root@mail text]# uniq sort.txt</span><br><span class="line">aaa:10:1.1</span><br><span class="line">ccc:30:3.3</span><br><span class="line">ddd:40:4.4</span><br><span class="line">bbb:20:2.2</span><br><span class="line">eee:50:5.5</span><br></pre></td></tr></table></figure>
<p>sort的-n、-r、-k、-t选项的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@mail text]# cat sort.txt</span><br><span class="line">AAA:BB:CC</span><br><span class="line">aaa:30:1.6</span><br><span class="line">ccc:50:3.3</span><br><span class="line">ddd:20:4.2</span><br><span class="line">bbb:10:2.5</span><br><span class="line">eee:40:5.4</span><br><span class="line">eee:60:5.1</span><br><span class="line"></span><br><span class="line">#将BB列按照数字从小到大顺序排列：</span><br><span class="line">[root@mail text]# sort -nk 2 -t: sort.txt</span><br><span class="line">AAA:BB:CC</span><br><span class="line">bbb:10:2.5</span><br><span class="line">ddd:20:4.2</span><br><span class="line">aaa:30:1.6</span><br><span class="line">eee:40:5.4</span><br><span class="line">ccc:50:3.3</span><br><span class="line">eee:60:5.1</span><br><span class="line"></span><br><span class="line">#将CC列数字从大到小顺序排列：</span><br><span class="line">[root@mail text]# sort -nrk 3 -t: sort.txt</span><br><span class="line">eee:40:5.4</span><br><span class="line">eee:60:5.1</span><br><span class="line">ddd:20:4.2</span><br><span class="line">ccc:50:3.3</span><br><span class="line">bbb:10:2.5</span><br><span class="line">aaa:30:1.6</span><br><span class="line">AAA:BB:CC</span><br><span class="line"></span><br><span class="line"># -n是按照数字大小排序，-r是以相反顺序，-k是指定需要爱排序的栏位，-t指定栏位分隔符为冒号</span><br></pre></td></tr></table></figure>
<p> <strong>-k选项的具体语法格式：</strong></p>
<p>-k选项的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FStart.CStart Modifie,FEnd.CEnd Modifier</span><br><span class="line">-------Start--------,-------End--------</span><br><span class="line"> FStart.CStart 选项  ,  FEnd.CEnd 选项</span><br></pre></td></tr></table></figure>
<p>这个语法格式可以被其中的逗号<code>,</code>分为两大部分， <strong>Start</strong> 部分和 <strong>End</strong> 部分。Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分。我们重点说说<code>Start</code>部分的<code>FStart</code>和<code>C.Start</code>。<code>C.Start</code>也是可以省略的，省略的话就表示从本域的开头部分开始。<code>FStart.CStart</code>，其中<code>FStart</code>就是表示使用的域，而<code>CStart</code>则表示在<code>FStart</code>域中从第几个字符开始算“排序首字符”。同理，在End部分中，你可以设定<code>FEnd.CEnd</code>，如果你省略<code>.CEnd</code>，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。</p>
<p>从公司英文名称的第二个字母开始进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sort -t &#x27; &#x27; -k 1.2 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
<p>使用了 <code>-k 1.2</code> ，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。你会发现 baidu 因为第二个字母是 a 而名列榜首。sohu 和 google 第二个字符都是o，但 sohu 的h 在 google 的 o 前面，所以两者分别排在第二和第三。guge 只能屈居第四了。</p>
<p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sort -t &#x27; &#x27; -k 1.2,1.2 -nrk 3,3 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
<p>由于只对第二个字母进行排序，所以我们使用了 <code>-k 1.2,1.2</code> 的表示方式，表示我们 “只” 对第二个字母进行排序。（如果你问“我使用 <code>-k 1.2</code> 怎么不行 ？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。对于员工工资进行排 序，我们也使用了 <code>-k 3,3</code>，这是最准确的表述，表示我们“只”对本域进行排序，因为如果你省略了后面的 3，就变成了我们 “对第 3 个域开始到最后一个域位置的内容进行排序” 了。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（19） -- uniq</title>
    <url>/2018/01/18/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-19/</url>
    <content><![CDATA[<p>报告或忽略文件中的重复行</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>uniq命令</strong> 用于报告或忽略文件中的重复行，一般与sort命令结合使用。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数；</span><br><span class="line">-d或--repeated：仅显示重复出现的行列；</span><br><span class="line">-f&amp;lt;栏位&amp;gt;或--skip-fields=&amp;lt;栏位&amp;gt;：忽略比较指定的栏位；</span><br><span class="line">-s&amp;lt;字符位置&amp;gt;或--skip-chars=&amp;lt;字符位置&amp;gt;：忽略比较指定的字符；</span><br><span class="line">-u或——unique：仅显示出一次的行列；</span><br><span class="line">-w&amp;lt;字符位置&amp;gt;或--check-chars=&amp;lt;字符位置&amp;gt;：指定要比较的字符。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>输入文件：指定要去除的重复行文件。如果不指定此项，则从标准读取数据；</li>
<li>输出文件：指定要去除重复行后的内容要写入的输出文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>删除重复行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq file.txt</span><br><span class="line">sort file.txt | uniq</span><br><span class="line">sort -u file.txt</span><br></pre></td></tr></table></figure>
<p>只显示单一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniq -u file.txt</span><br><span class="line">sort file.txt | uniq -u</span><br></pre></td></tr></table></figure>
<p>统计各行在文件中出现的次数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort file.txt | uniq -c</span><br></pre></td></tr></table></figure>
<p>在文件中找出重复的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort file.txt | uniq -d</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（2） -- touch</title>
    <url>/2018/01/01/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-2/</url>
    <content><![CDATA[<h2 id="将文件改为当前时间"><a href="#将文件改为当前时间" class="headerlink" title="将文件改为当前时间"></a>将文件改为当前时间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ date</span><br><span class="line">Sat Jan  2 20:38:43 PST 2018</span><br><span class="line">➜  ~ ll Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">-rw-rw-r-- 1 atompi atompi 508M Jan  2 20:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">➜  ~ touch Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">➜  ~ ll Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">-rw-rw-r-- 1 atompi atompi 508M Jan  2 20:39 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">➜  ~ date</span><br><span class="line">Sat Jan  2 20:39:31 PST 2018</span><br></pre></td></tr></table></figure>
<h2 id="将文件改为任意时间"><a href="#将文件改为任意时间" class="headerlink" title="将文件改为任意时间"></a>将文件改为任意时间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ll Downloads/Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">-rw-rw-r-- 1 atompi atompi 508M Jan  2 20:38 Downloads/Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">➜  ~ touch -t 201801060354 Downloads/Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">➜  ~ ll Downloads/Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">-rw-rw-r-- 1 atompi atompi 508M Jan  6 03:54 Downloads/Anaconda2-5.0.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<h2 id="创建空文件"><a href="#创建空文件" class="headerlink" title="创建空文件"></a>创建空文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ll ~/Downloads</span><br><span class="line">total 540M</span><br><span class="line">-rw-rw-r--  1 atompi atompi 508M Jan  1 20:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">drwxr-xr-x 36 atompi atompi 4.0K Jan  5 05:59 mysql-5.6.38</span><br><span class="line">-rw-rw-r--  1 atompi atompi  31M Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Sep 21 07:20 redis-3.2.11</span><br><span class="line">-rw-rw-r--  1 atompi atompi 1.5M Sep 21 07:20 redis-3.2.11.tar.gz</span><br><span class="line">➜  ~ touch ~/Downloads/test.txt</span><br><span class="line">➜  ~ ll ~/Downloads</span><br><span class="line">total 540M</span><br><span class="line">-rw-rw-r--  1 atompi atompi 508M Jan  1 20:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">drwxr-xr-x 36 atompi atompi 4.0K Jan  5 05:59 mysql-5.6.38</span><br><span class="line">-rw-rw-r--  1 atompi atompi  31M Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Sep 21 07:20 redis-3.2.11</span><br><span class="line">-rw-rw-r--  1 atompi atompi 1.5M Sep 21 07:20 redis-3.2.11.tar.gz</span><br><span class="line">-rw-rw-r--  1 atompi atompi    0 Jan  6 04:04 test.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（20） -- tr</title>
    <url>/2018/01/19/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-20/</url>
    <content><![CDATA[<p>将字符进行替换压缩和删除</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>tr命令</strong> 可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tr (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c或——complerment：取代所有不属于第一字符集的字符；</span><br><span class="line">-d或——delete：删除所有属于第一字符集的字符；</span><br><span class="line">-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；</li>
<li>字符集2：指定要转换成的目标字符集。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将输入字符由大写转换为小写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;HELLO WORLD&quot; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>‘A-Z’ 和 ‘a-z’都是集合，集合是可以自己制定的，例如：’ABD-}’、’bB.,’、’a-de-h’、’a-c0-9’都属于集合，集合里可以使用’\n’、’\t’，可以可以使用其他ASCII字符。</p>
<p>使用tr删除字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello 123 world 456&quot; | tr -d &#x27;0-9&#x27;</span><br><span class="line">hello  world</span><br></pre></td></tr></table></figure>
<p>将制表符转换为空格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat text | tr &#x27;\t&#x27; &#x27; &#x27;</span><br></pre></td></tr></table></figure>
<p>字符集补集，从输入文本中将不在补集中的所有字符删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo aa.,a 1 b#$bb 2 c*/cc 3 ddd 4 | tr -d -c &#x27;0-9 \n&#x27;</span><br><span class="line"> 1  2  3  4</span><br></pre></td></tr></table></figure>
<p>此例中，补集中包含了数字0~9、空格和换行符\n，所以没有被删除，其他字符全部被删除了。</p>
<p>用tr压缩字符，可以压缩输入中重复的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;thissss is      a text linnnnnnne.&quot; | tr -s &#x27; sn&#x27;</span><br><span class="line">this is a text line.</span><br></pre></td></tr></table></figure>
<p>巧妙使用tr做数字相加操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 2 3 4 5 6 7 8 9 | xargs -n1 | echo $[ $(tr &#x27;\n&#x27; &#x27;+&#x27;) 0 ]</span><br></pre></td></tr></table></figure>
<p>删除Windows文件“造成”的’^M’字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat file | tr -s &quot;\r&quot; &quot;\n&quot; &amp;gt; new_file</span><br><span class="line">或</span><br><span class="line">cat file | tr -d &quot;\r&quot; &amp;gt; new_file</span><br></pre></td></tr></table></figure>
<p> <strong>tr可以使用的字符类：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[:alnum:]：字母和数字</span><br><span class="line">[:alpha:]：字母</span><br><span class="line">[:cntrl:]：控制（非打印）字符</span><br><span class="line">[:digit:]：数字</span><br><span class="line">[:graph:]：图形字符</span><br><span class="line">[:lower:]：小写字母</span><br><span class="line">[:print:]：可打印字符</span><br><span class="line">[:punct:]：标点符号</span><br><span class="line">[:space:]：空白字符</span><br><span class="line">[:upper:]：大写字母</span><br><span class="line">[:xdigit:]：十六进制字符</span><br></pre></td></tr></table></figure>
<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（21） -- sed</title>
    <url>/2018/01/20/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-21/</url>
    <content><![CDATA[<p>功能强大的流式文本编辑器</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>sed</strong> 是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<h2 id="sed的选项、命令、替换标记"><a href="#sed的选项、命令、替换标记" class="headerlink" title="sed的选项、命令、替换标记"></a>sed的选项、命令、替换标记</h2><p> <strong>命令格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [options] &#x27;command&#x27; file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><pre><code class="plain">-e&lt;script&gt;或--expression=&lt;script&gt;：以选项中的指定的script来处理输入的文本文件；&lt;br&gt;-f&lt;script文件&gt;或--file=&lt;script文件&gt;：以选项中指定的script文件来处理输入的文本文件；&lt;br&gt;-h或--help：显示帮助；&lt;br&gt;-n或--quiet或——silent：仅显示script处理后的结果；&lt;br&gt;-V或--version：显示版本信息。&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

## [](#参数)参数

文件：指定待处理的文本文件列表。

### [](#sed命令)sed命令
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;4&lt;br&gt;5&lt;br&gt;6&lt;br&gt;7&lt;br&gt;8&lt;br&gt;9&lt;br&gt;10&lt;br&gt;11&lt;br&gt;12&lt;br&gt;13&lt;br&gt;14&lt;br&gt;15&lt;br&gt;16&lt;br&gt;17&lt;br&gt;18&lt;br&gt;19&lt;br&gt;20&lt;br&gt;21&lt;br&gt;22&lt;br&gt;23&lt;br&gt;24&lt;br&gt;25&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;**a\**  在当前行下面插入文本。&lt;br&gt;**i\**  在当前行上面插入文本。&lt;br&gt;**c\**  把选定的行改为新的文本。&lt;br&gt;**d**  删除，删除选择的行。&lt;br&gt;**D**  删除模板块的第一行。&lt;br&gt;**s**  替换指定字符&lt;br&gt;**h**  拷贝模板块的内容到内存中的缓冲区。&lt;br&gt;**H**  追加模板块的内容到内存中的缓冲区。&lt;br&gt;**g**  获得内存缓冲区的内容，并替代当前模板块中的文本。&lt;br&gt;**G**  获得内存缓冲区的内容，并追加到当前模板块文本的后面。&lt;br&gt;**l**  列表不能打印字符的清单。&lt;br&gt;**n**  读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。&lt;br&gt;**N**  追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。&lt;br&gt;**p**  打印模板块的行。&lt;br&gt;**P** (大写) 打印模板块的第一行。&lt;br&gt;**q**  退出Sed。&lt;br&gt;**b lable**  分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。&lt;br&gt;**r file**  从file中读行。&lt;br&gt;**t label**  if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。&lt;br&gt;**T label**  错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。&lt;br&gt;**w file**  写并追加模板块到file末尾。  &lt;br&gt;**W file**  写并追加模板块的第一行到file末尾。  &lt;br&gt;**!**  表示后面的命令对所有没有被选定的行发生作用。  &lt;br&gt;**=**  打印当前行号码。  &lt;br&gt;**#**  把注释扩展到下一个换行符以前。&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

## [](#sed替换标记)sed替换标记
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;4&lt;br&gt;5&lt;br&gt;6&lt;br&gt;7&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;**g**  表示行内全面替换。  &lt;br&gt;**p**  表示打印行。  &lt;br&gt;**w**  表示把行写入一个文件。  &lt;br&gt;**x**  表示互换模板块中的文本和缓冲区中的文本。  &lt;br&gt;**y**  表示把一个字符翻译为另外的字符（但是不用于正则表达式）&lt;br&gt;**\1**  子串匹配标记&lt;br&gt;**&amp;**  已匹配字符串标记&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

## [](#sed元字符集)sed元字符集
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;4&lt;br&gt;5&lt;br&gt;6&lt;br&gt;7&lt;br&gt;8&lt;br&gt;9&lt;br&gt;10&lt;br&gt;11&lt;br&gt;12&lt;br&gt;13&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;**^**  匹配行开始，如：/^sed/匹配所有以sed开头的行。&lt;br&gt;**$**  匹配行结束，如：/sed$/匹配所有以sed结尾的行。&lt;br&gt;**.**  匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。&lt;br&gt;**** * 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。&lt;br&gt;**[]**  匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。  &lt;br&gt;**[^]**  匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。&lt;br&gt;**\(..\)**  匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。&lt;br&gt;**&amp;**  保存搜索字符用来替换其他字符，如s/love/ **&amp;** /，love这成 **love** 。&lt;br&gt;**\&lt;**  匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。&lt;br&gt;**\&gt;**  匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。&lt;br&gt;**x\&#123;m\&#125;**  重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。&lt;br&gt;**x\&#123;m,\&#125;**  重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。&lt;br&gt;**x\&#123;m,n\&#125;**  重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

## [](#sed用法实例)sed用法实例

### [](#替换操作：s命令)替换操作：s命令

替换文本中的字符串：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;s/book/books/&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

 **-n选项** 和 **p命令** 一起使用表示只打印那些发生替换的行：

sed -n ‘s/test/TEST/p’ file

直接编辑文件 **选项-i** ，会匹配file文件中每一行的第一个book替换为books：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -i &#39;s/book/books/g&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#全面替换标记g)全面替换标记g

使用后缀 /g 标记会替换每一行中的所有匹配：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;s/book/books/g&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

当需要从第N处匹配开始替换时，可以使用 /Ng：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;4&lt;br&gt;5&lt;br&gt;6&lt;br&gt;7&lt;br&gt;8&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;echo sksksksksksk | sed &#39;s/sk/SK/2g&#39;&lt;br&gt;skSKSKSKSKSK&lt;br&gt;&lt;br&gt;echo sksksksksksk | sed &#39;s/sk/SK/3g&#39;&lt;br&gt;skskSKSKSKSK&lt;br&gt;&lt;br&gt;echo sksksksksksk | sed &#39;s/sk/SK/4g&#39;&lt;br&gt;skskskSKSKSK&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#定界符)定界符

以上命令中字符 / 在sed中作为定界符使用，也可以使用任意的定界符：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;s:test:TEXT:g&#39;&lt;br&gt;sed &#39;s|test|TEXT|g&#39;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

定界符出现在样式内部时，需要进行转义：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;s/\/bin/\/usr\/local\/bin/g&#39;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#删除操作：d命令)删除操作：d命令

删除空白行：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;/^$/d&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

删除文件的第2行：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;2d&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

删除文件的第2行到末尾所有行：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;2,$d&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

删除文件最后一行：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;$d&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

删除文件中所有开头是test的行：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;/^test/&#39;d file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#已匹配字符串标记-amp)已匹配字符串标记&amp;

正则表达式 \w+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;echo this is a test line | sed &#39;s/\w\+/[&amp;]/g&#39;&lt;br&gt;[this] [is] [a] [test] [line]&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

所有以192.168.0.1开头的行都会被替换成它自已加localhost：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;s/^192.168.0.1/&amp;localhost/&#39; file&lt;br&gt;192.168.0.1localhost&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#子串匹配标记-1)子串匹配标记\1

匹配给定样式的其中一部分：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;echo this is digit 7 in a number | sed &#39;s/digit \([0-9]\)/\1/&#39;&lt;br&gt;this is 7 in a number&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，(..) 用于匹配子串，对于匹配到的第一个子串就标记为  **\1** ，依此类推匹配到的第二个结果就是  **\2** ，例如：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;echo aaa BBB | sed &#39;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#39;&lt;br&gt;BBB aaa&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

love被标记为1，所有loveable会被替换成lovers，并打印出来：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -n &#39;s/\(love\)able/\1rs/p&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#组合多个表达式)组合多个表达式
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;4&lt;br&gt;5&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;表达式&#39; | sed &#39;表达式&#39;&lt;br&gt;&lt;br&gt;等价于：&lt;br&gt;&lt;br&gt;sed &#39;表达式; 表达式&#39;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#引用)引用

sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;test=hello&lt;br&gt;echo hello WORLD | sed &quot;s/$test/HELLO&quot;&lt;br&gt;HELLO WORLD&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#选定行的范围：-（逗号）)选定行的范围：,（逗号）

所有在模板test和check所确定的范围内的行都被打印：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -n &#39;/test/,/check/p&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

打印从第5行开始到第一个包含以test开始的行之间的所有行：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -n &#39;5,/^test/p&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;/test/,/west/s/$/aaa bbb/&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#多点编辑：e命令)多点编辑：e命令

-e选项允许在同一行里执行多条命令：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -e &#39;1,5d&#39; -e &#39;s/test/check/&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

上面sed表达式的第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。

和 -e 等价的命令是 –expression：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed --expression=&#39;s/test/check/&#39; --expression=&#39;/love/d&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#从文件读入：r命令)从文件读入：r命令

file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;/test/r file&#39; filename&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#写入文件：w命令)写入文件：w命令

在example中所有包含test的行都被写入file里：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -n &#39;/test/w file&#39; example&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#追加（行下）：a-命令)追加（行下）：a\命令

将 this is a test line 追加到 以test 开头的行后面：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;/^test/a\this is a test line&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

在 test.conf 文件第2行之后插入 this is a test line：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -i &#39;2a\this is a test line&#39; test.conf&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#插入（行上）：i-命令)插入（行上）：i\命令

将 this is a test line 追加到以test开头的行前面：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;/^test/i\this is a test line&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

在test.conf文件第5行之前插入this is a test line：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -i &#39;5i\this is a test line&#39; test.conf&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#下一个：n命令)下一个：n命令

如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;/test/&#123; n; s/aa/bb/; &#125;&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#变形：y命令)变形：y命令

把1~10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;1,10y/abcde/ABCDE/&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#退出：q命令)退出：q命令

打印完第10行后，退出sed
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed &#39;10q&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#保持和获取：h命令和G命令)保持和获取：h命令和G命令

在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -e &#39;/test/h&#39; -e &#39;$G&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。

### [](#保持和互换：h命令和x命令)保持和互换：h命令和x命令

互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -e &#39;/test/h&#39; -e &#39;/check/x&#39; file&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#脚本scriptfile)脚本scriptfile

sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed [options] -f scriptfile file(s)&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#打印奇数行或偶数行)打印奇数行或偶数行

方法1：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -n &#39;p;n&#39; test.txt  #奇数行&lt;br&gt;sed -n &#39;n;p&#39; test.txt  #偶数行&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

方法2：
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sed -n &#39;1~2p&#39; test.txt  #奇数行&lt;br&gt;sed -n &#39;2~2p&#39; test.txt  #偶数行&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

### [](#打印匹配字符串的下一行)打印匹配字符串的下一行
&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;grep -A 1 SCC URFILE&lt;br&gt;sed -n &#39;/SCC/&#123;n;p&#125;&#39; URFILE&lt;br&gt;awk &#39;/SCC/&#123;getline; print&#125;&#39; URFILE&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;

  &lt;li class=&quot;post-copyright-author&quot;&gt;
    **本文作者： **atompi
  &lt;/li&gt;
  &lt;li class=&quot;post-copyright-link&quot;&gt;
    **本文链接：**
    [https://blog.atompi.com/2018/01/21/每天一个Linux命令-21/](https://blog.atompi.com/2018/01/21/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-21/)
  &lt;/li&gt;
  &lt;li class=&quot;post-copyright-license&quot;&gt;
    **版权声明： **本博客所有文章除特别声明外，均采用 [&lt;i class=&quot;fab fa-fw fa-creative-commons&quot;&gt;&lt;/i&gt;BY-NC-SA](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议。转载请注明出处！
  &lt;/li&gt;
&lt;/script&gt;```
</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（22） -- awk</title>
    <url>/2018/01/21/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-22/</url>
    <content><![CDATA[<p>文本和数据进行处理的编程语言</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>awk</strong> 是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p>
<h2 id="awk命令格式和选项"><a href="#awk命令格式和选项" class="headerlink" title="awk命令格式和选项"></a>awk命令格式和选项</h2><p> <strong>语法形式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk [options] &#x27;script&#x27; var=value file(s)</span><br><span class="line">awk [options] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure>
<p> <strong>常用命令选项</strong></p>
<ul>
<li>***-F fs   *** fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li>
<li>***-v var&#x3D;value   *** 赋值一个用户定义变量，将外部变量传递给awk</li>
<li>***-f scripfile  *** 从脚本文件中读取awk命令</li>
<li>***-m[fr] val   *** 对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
</ul>
<h2 id="awk模式和操作"><a href="#awk模式和操作" class="headerlink" title="awk模式和操作"></a>awk模式和操作</h2><p>awk脚本是由模式和操作组成的。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式可以是以下任意一个：</p>
<ul>
<li>&#x2F;正则表达式&#x2F;：使用通配符的扩展集。</li>
<li>关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。</li>
<li>模式匹配表达式：用运算符<code>~</code>（匹配）和<code>!~</code>（不匹配）。</li>
<li>BEGIN语句块、pattern语句块、END语句块：参见awk的工作原理</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是：</p>
<ul>
<li>变量或数组赋值</li>
<li>输出命令</li>
<li>内置函数</li>
<li>控制流语句</li>
</ul>
<h2 id="awk脚本基本结构"><a href="#awk脚本基本结构" class="headerlink" title="awk脚本基本结构"></a>awk脚本基本结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; print &quot;start&quot; &#125; pattern&#123; commands &#125; END&#123; print &quot;end&quot; &#125;&#x27; file</span><br></pre></td></tr></table></figure>
<p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被 <strong>单引号</strong> 或 <strong>双引号</strong> 中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;&#x27; filename</span><br><span class="line">awk &quot;BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;&quot; filename</span><br></pre></td></tr></table></figure>
<h3 id="awk的工作原理"><a href="#awk的工作原理" class="headerlink" title="awk的工作原理"></a>awk的工作原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#x27;</span><br></pre></td></tr></table></figure>
<li>第一步：执行`BEGIN{ commands }`语句块中的语句；
</li>
<li>第二步：从文件或标准输入(stdin)读取一行，然后执行`pattern{ commands }`语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。
</li>
<li>第三步：当读至输入流末尾时，执行`END{ commands }`语句块。
**BEGIN语句块** 在awk开始从输入流中读取行 **之前** 被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。
**END语句块** 在awk从输入流中读取完所有的行 **之后** 即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。
**pattern语句块** 中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行`{ print }`，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。
**示例**
</li>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -e &quot;A line 1nA line 2&quot; | awk &#x27;BEGIN&#123; print &quot;Start&quot; &#125; &#123; print &#125; END&#123; print &quot;End&quot; &#125;&#x27;</span><br><span class="line">Start</span><br><span class="line">A line 1</span><br><span class="line">A line 2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<p>当使用不带参数的<code>print</code>时，它就打印当前行，当<code>print</code>的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo | awk &#x27;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; &#125;&#x27;</span><br><span class="line">v1 v2 v3</span><br></pre></td></tr></table></figure>
<p>双引号拼接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo | awk &#x27;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; &#125;&#x27;</span><br><span class="line">v1=v2=v3</span><br></pre></td></tr></table></figure>
<p>{ }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i&#x3D;0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。</p>
<h2 id="awk内置变量（预定义变量）"><a href="#awk内置变量（预定义变量）" class="headerlink" title="awk内置变量（预定义变量）"></a>awk内置变量（预定义变量）</h2><p>说明：[A][N][P][G]表示第一个支持变量的工具，[A]&#x3D;awk、[N]&#x3D;nawk、[P]&#x3D;POSIXawk、[G]&#x3D;gawk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> **$n**  当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。</span><br><span class="line"> **$0**  这个变量包含执行过程中当前行的文本内容。</span><br><span class="line">[N]  **ARGC**  命令行参数的数目。</span><br><span class="line">[G]  **ARGIND**  命令行中当前文件的位置（从0开始算）。</span><br><span class="line">[N]  **ARGV**  包含命令行参数的数组。</span><br><span class="line">[G]  **CONVFMT**  数字转换格式（默认值为%.6g）。</span><br><span class="line">[P]  **ENVIRON**  环境变量关联数组。</span><br><span class="line">[N]  **ERRNO**  最后一个系统错误的描述。</span><br><span class="line">[G]  **FIELDWIDTHS**  字段宽度列表（用空格键分隔）。</span><br><span class="line">[A]  **FILENAME**  当前输入文件的名。</span><br><span class="line">[P]  **FNR**  同NR，但相对于当前文件。</span><br><span class="line">[A]  **FS**  字段分隔符（默认是任何空格）。</span><br><span class="line">[G]  **IGNORECASE**  如果为真，则进行忽略大小写的匹配。</span><br><span class="line">[A]  **NF**  表示字段数，在执行过程中对应于当前的字段数。</span><br><span class="line">[A]  **NR**  表示记录数，在执行过程中对应于当前的行号。</span><br><span class="line">[A]  **OFMT**  数字的输出格式（默认值是%.6g）。</span><br><span class="line">[A]  **OFS**  输出字段分隔符（默认值是一个空格）。</span><br><span class="line">[A]  **ORS**  输出记录分隔符（默认值是一个换行符）。</span><br><span class="line">[A]  **RS**  记录分隔符（默认是一个换行符）。</span><br><span class="line">[N]  **RSTART**  由match函数所匹配的字符串的第一个位置。</span><br><span class="line">[N]  **RLENGTH**  由match函数所匹配的字符串的长度。</span><br><span class="line">[N]  **SUBSEP**  数组下标分隔符（默认值是34）。</span><br></pre></td></tr></table></figure>
<p> <strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3\nline2 f4 f5\nline3 f6 f7&quot; | awk &#x27;&#123;print &quot;Line No:&quot;NR&quot;, No of fields:&quot;NF, &quot;$0=&quot;$0, &quot;$1=&quot;$1, &quot;$2=&quot;$2, &quot;$3=&quot;$3&#125;&#x27;</span><br><span class="line">Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3</span><br><span class="line">Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5</span><br><span class="line">Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7</span><br></pre></td></tr></table></figure>
<p>使用<code>print $NF</code>可以打印出一行中的最后一个字段，使用<code>$(NF-1)</code>则是打印倒数第二个字段，其他以此类推：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3n line2 f4 f5&quot; | awk &#x27;&#123;print $NF&#125;&#x27;</span><br><span class="line">f3</span><br><span class="line">f5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -e &quot;line1 f2 f3n line2 f4 f5&quot; | awk &#x27;&#123;print $(NF-1)&#125;&#x27;</span><br><span class="line">f2</span><br><span class="line">f4</span><br></pre></td></tr></table></figure>
<p>打印每一行的第二和第三个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123; print $2,$3 &#125;&#x27; filename</span><br></pre></td></tr></table></figure>
<p>统计文件中的行数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;END&#123; print NR &#125;&#x27; filename</span><br></pre></td></tr></table></figure>
<p>以上命令只使用了END语句块，在读入每一行的时，awk会将NR更新为对应的行号，当到达最后一行NR的值就是最后一行的行号，所以END语句块中的NR就是文件的行数。</p>
<p>一个每一行中第一个字段值累加的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seq 5 | awk &#x27;BEGIN&#123; sum=0; print &quot;总和：&quot; &#125; &#123; print $1&quot;+&quot;; sum+=$1 &#125; END&#123; print &quot;等于&quot;; print sum &#125;&#x27;</span><br><span class="line">总和：</span><br><span class="line">1+</span><br><span class="line">2+</span><br><span class="line">3+</span><br><span class="line">4+</span><br><span class="line">5+</span><br><span class="line">等于</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<h2 id="将外部变量值传递给awk"><a href="#将外部变量值传递给awk" class="headerlink" title="将外部变量值传递给awk"></a>将外部变量值传递给awk</h2><p>借助 <strong><code>-v</code>选项</strong> ，可以将外部值（并非来自stdin）传递给awk：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VAR=10000</span><br><span class="line">echo | awk -v VARIABLE=$VAR &#x27;&#123; print VARIABLE &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>另一种传递外部变量方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1=&quot;aaa&quot;</span><br><span class="line">var2=&quot;bbb&quot;</span><br><span class="line">echo | awk &#x27;&#123; print v1,v2 &#125;&#x27; v1=$var1 v2=$var2</span><br></pre></td></tr></table></figure>
<p>当输入来自于文件时使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123; print v1,v2 &#125;&#x27; v1=$var1 v2=$var2 filename</span><br></pre></td></tr></table></figure>
<p>以上方法中，变量之间用空格分隔作为awk的命令行参数跟随在BEGIN、{}和END语句块之后。</p>
<h2 id="查找进程pid"><a href="#查找进程pid" class="headerlink" title="查找进程pid"></a>查找进程pid</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -antup | grep 7770 | awk &#x27;&#123; print $NF NR&#125;&#x27; | awk &#x27;&#123; print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="awk运算与判断"><a href="#awk运算与判断" class="headerlink" title="awk运算与判断"></a>awk运算与判断</h2><p>作为一种程序设计语言所应具有的特点之一，awk支持多种运算，这些运算与C语言提供的基本相同。awk还提供了一系列内置的运算函数（如log、sqr、cos、sin等）和一些用于对字符串进行操作（运算）的函数（如length、substr等等）。这些函数的引用大大的提高了awk的运算功能。作为对条件转移指令的一部分，关系判断是每种程序设计语言都具备的功能，awk也不例外，awk中允许进行多种测试，作为样式匹配，还提供了模式匹配表达式<del>（匹配）和!</del>（不匹配）。作为对测试的一种扩充，awk也支持用逻辑运算符。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>|运算符|描述<br>|——<br>|+ -|加，减<br>|* &#x2F; &amp;|乘，除与求余<br>|+ - !|一元加，减和逻辑非<br>|^ ***|求幂<br>|++ –|增加或减少，作为前缀或后缀</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a=&quot;b&quot;;print a++,++a;&#125;&#x27;</span><br><span class="line">0 2</span><br></pre></td></tr></table></figure>
<p>注意：所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>|运算符|描述<br>|——<br>|&#x3D; +&#x3D; -&#x3D; **&#x3D; &#x2F;&#x3D; %&#x3D; ^&#x3D; ***&#x3D;|赋值语句</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a+=5; 等价于：a=a+5; 其它同类</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>|运算符|描述<br>|——<br>|<code>||</code>|逻辑或<br>|&amp;&amp;|逻辑与</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a=1;b=2;print (a&amp;gt;5 &amp;amp;&amp;amp; b&amp;lt;=2),(a&amp;gt;5 || b&amp;lt;=2);&#125;&#x27;</span><br><span class="line">0 1</span><br></pre></td></tr></table></figure>
<h3 id="正则运算符"><a href="#正则运算符" class="headerlink" title="正则运算符"></a>正则运算符</h3><p>|运算符|描述<br>|——<br>|~ !~|匹配正则表达式和不匹配正则表达式</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a=&quot;100testa&quot;;if(a ~ /^100*/)&#123;print &quot;ok&quot;;&#125;&#125;&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>|运算符|描述<br>|——<br>|&lt; &lt;&#x3D; &gt; &gt;&#x3D; !&#x3D; &#x3D;&#x3D;|关系运算符</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a=11;if(a &amp;gt;= 9)&#123;print &quot;ok&quot;;&#125;&#125;&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>注意：&gt; &lt; 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。</p>
<h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><p>|运算符|描述<br>|——<br>|$|字段引用<br>|空格|字符串连接符<br>|?:|C条件表达式<br>|in|数组中是否存在某键值</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a=&quot;b&quot;;print a==&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;;&#125;&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[1]=&quot;c&quot;;print (a in arr);&#125;&#x27;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[&quot;b&quot;]=&quot;c&quot;;print (a in arr);&#125;&#x27;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="运算级优先级表"><a href="#运算级优先级表" class="headerlink" title="运算级优先级表"></a>运算级优先级表</h3><p>!级别越高越优先<br/>级别越高越优先</p>
<h2 id="awk高级输入输出"><a href="#awk高级输入输出" class="headerlink" title="awk高级输入输出"></a>awk高级输入输出</h2><h3 id="读取下一条记录"><a href="#读取下一条记录" class="headerlink" title="读取下一条记录"></a>读取下一条记录</h3><p>awk中<code>next</code>语句使用：在循环逐行匹配，如果遇到next，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。next语句一般用于多行合并：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat text.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">awk &#x27;NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;&#x27; text.txt</span><br><span class="line">2 b</span><br><span class="line">4 d</span><br></pre></td></tr></table></figure>
<p>当记录行号除以2余1，就跳过当前行。下面的<code>print NR,$0</code>也不会执行。下一行开始，程序有开始判断<code>NR%2</code>值。这个时候记录行号是<code>：2</code> ，就会执行下面语句块：<code>&#39;print NR,$0&#39;</code></p>
<p>分析发现需要将包含有“web”行进行跳过，然后需要将内容与下面行合并为一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat text.txt</span><br><span class="line">web01[192.168.2.100]</span><br><span class="line">httpd            ok</span><br><span class="line">tomcat               ok</span><br><span class="line">sendmail               ok</span><br><span class="line">web02[192.168.2.101]</span><br><span class="line">httpd            ok</span><br><span class="line">postfix               ok</span><br><span class="line">web03[192.168.2.102]</span><br><span class="line">mysqld            ok</span><br><span class="line">httpd               ok</span><br><span class="line">0</span><br><span class="line">awk &#x27;/^web/&#123;T=$0;next;&#125;&#123;print T&quot;:t&quot;$0;&#125;&#x27; test.txt</span><br><span class="line">web01[192.168.2.100]:   httpd            ok</span><br><span class="line">web01[192.168.2.100]:   tomcat               ok</span><br><span class="line">web01[192.168.2.100]:   sendmail               ok</span><br><span class="line">web02[192.168.2.101]:   httpd            ok</span><br><span class="line">web02[192.168.2.101]:   postfix               ok</span><br><span class="line">web03[192.168.2.102]:   mysqld            ok</span><br><span class="line">web03[192.168.2.102]:   httpd               ok</span><br></pre></td></tr></table></figure>
<h3 id="简单地读取一条记录"><a href="#简单地读取一条记录" class="headerlink" title="简单地读取一条记录"></a>简单地读取一条记录</h3><p><code>awk getline</code>用法：输出重定向需用到<code>getline函数</code>。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。</p>
<p>getline语法：getline var，变量var包含了特定行的内容。</p>
<p>awk getline从整体上来说，用法说明：</p>
<li>**当其左右无重定向符`|`或`&lt;`时：** getline作用于当前文件，读入当前文件的第一行给其后跟的变量`var`或`$0`（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。
</li>
<li>**当其左右有重定向符`|`或`&lt;`时：** getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。
**示例：**
</li>

<p>执行linux的<code>date</code>命令，并通过管道输出给<code>getline</code>，然后再把输出赋值给自定义变量out，并打印它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; &quot;date&quot; | getline out; print out &#125;&#x27; test</span><br></pre></td></tr></table></figure>
<p>执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; &quot;date&quot; | getline out; split(out,mon); print mon[2] &#125;&#x27; test</span><br></pre></td></tr></table></figure>
<p>命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123; while( &quot;ls&quot; | getline) print &#125;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close(&quot;filename&quot;)</span><br></pre></td></tr></table></figure>
<p>filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。</p>
<h3 id="输出到一个文件"><a href="#输出到一个文件" class="headerlink" title="输出到一个文件"></a>输出到一个文件</h3><p>awk中允许用如下方式将结果输出到一个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo | awk &#x27;&#123;printf(&quot;hello word!n&quot;) &amp;gt; &quot;datafile&quot;&#125;&#x27;</span><br><span class="line">或</span><br><span class="line">echo | awk &#x27;&#123;printf(&quot;hello word!n&quot;) &amp;gt;&amp;gt; &quot;datafile&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="设置字段定界符"><a href="#设置字段定界符" class="headerlink" title="设置字段定界符"></a>设置字段定界符</h2><p>默认的字段定界符是空格，可以使用<code>-F &quot;定界符&quot;</code>  明确指定一个定界符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F: &#x27;&#123; print $NF &#125;&#x27; /etc/passwd</span><br><span class="line">或</span><br><span class="line">awk &#x27;BEGIN&#123; FS=&quot;:&quot; &#125; &#123; print $NF &#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<p>在<code>BEGIN语句块</code>中则可以用<code>OFS=“定界符”</code>设置输出字段的定界符。</p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>在linux awk的while、do-while和for语句中允许使用break,continue语句来控制流程走向，也允许使用exit这样的语句来退出。break中断当前正在执行的循环并跳到循环外执行下一条语句。if 是流程选择用法。awk中，流程控制语句，语法结构，与c语言类型。有了这些语句，其实很多shell程序都可以交给awk，而且性能是非常快的。下面是各个语句用法。</p>
<h3 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(表达式)</span><br><span class="line">  语句1</span><br><span class="line">else</span><br><span class="line">  语句2</span><br></pre></td></tr></table></figure>
<p>格式中语句1可以是多个语句，为了方便判断和阅读，最好将多个语句用{}括起来。awk分枝结构允许嵌套，其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(表达式)</span><br><span class="line">  &#123;语句1&#125;</span><br><span class="line">else if(表达式)</span><br><span class="line">  &#123;语句2&#125;</span><br><span class="line">else</span><br><span class="line">  &#123;语句3&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">test=100;</span><br><span class="line">if(test&amp;gt;90)&#123;</span><br><span class="line">  print &quot;very good&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else if(test&amp;gt;60)&#123;</span><br><span class="line">    print &quot;good&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    print &quot;no pass&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">very good</span><br></pre></td></tr></table></figure>
<p>每条命令语句后面可以用<code>;</code> <strong>分号</strong> 结尾。</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(表达式)</span><br><span class="line">  &#123;语句&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">test=100;</span><br><span class="line">total=0;</span><br><span class="line">while(i&amp;lt;=test)&#123;</span><br><span class="line">  total+=i;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line">print total;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环有两种格式：</p>
<p>格式1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(变量 in 数组)</span><br><span class="line">  &#123;语句&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">for(k in ENVIRON)&#123;</span><br><span class="line">  print k&quot;=&quot;ENVIRON[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x27;</span><br><span class="line">TERM=linux</span><br><span class="line">G_BROKEN_FILENAMES=1</span><br><span class="line">SHLVL=1</span><br><span class="line">pwd=/root/text</span><br><span class="line">...</span><br><span class="line">logname=root</span><br><span class="line">HOME=/root</span><br><span class="line">SSH_CLIENT=192.168.1.21 53087 22</span><br></pre></td></tr></table></figure>
<p>注：ENVIRON是awk常量，是子典型数组。</p>
<p>格式2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(变量;条件;表达式)</span><br><span class="line">  &#123;语句&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">total=0;</span><br><span class="line">for(i=0;i&amp;lt;=100;i++)&#123;</span><br><span class="line">  total+=i;</span><br><span class="line">&#125;</span><br><span class="line">print total;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>
<h4 id="do循环"><a href="#do循环" class="headerlink" title="do循环"></a>do循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;语句&#125; while(条件)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">total=0;</span><br><span class="line">i=0;</span><br><span class="line">do &#123;total+=i;i++;&#125; while(i&amp;lt;=100)</span><br><span class="line">  print total;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>
<h3 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h3><ul>
<li><strong>break</strong>  当 break 语句用于 while 或 for 语句时，导致退出程序循环。</li>
<li><strong>continue</strong>  当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。</li>
<li><strong>next</strong>  能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。</li>
<li><strong>exit</strong>  语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。</li>
</ul>
<h2 id="数组应用"><a href="#数组应用" class="headerlink" title="数组应用"></a>数组应用</h2><p>数组是awk的灵魂，处理文本中最不能少的就是它的数组处理。因为数组索引（下标）可以是数字和字符串在awk中数组叫做关联数组(associative arrays)。awk 中的数组不必提前声明，也不必声明大小。数组元素用0或空字符串来初始化，这根据上下文而定。</p>
<h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>数字做数组索引（下标）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array[1]=&quot;sun&quot;</span><br><span class="line">Array[2]=&quot;kai&quot;</span><br></pre></td></tr></table></figure>
<p>字符串做数组索引（下标）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array[&quot;first&quot;]=&quot;www&quot;</span><br><span class="line">Array&quot;[last&quot;]=&quot;name&quot;</span><br><span class="line">Array[&quot;birth&quot;]=&quot;1987&quot;</span><br></pre></td></tr></table></figure>
<p>使用中<code>print Array[1]</code>会打印出sun；使用<code>print Array[2]</code>会打印出kai；使用<code>print[&quot;birth&quot;]</code>会得到1987。</p>
<p> <strong>读取数组的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; for(item in array) &#123;print array[item]&#125;; &#125;       #输出的顺序是随机的</span><br><span class="line">&#123; for(i=1;i&amp;lt;=len;i++) &#123;print array[i]&#125;; &#125;         #Len是数组的长度</span><br></pre></td></tr></table></figure>
<h3 id="数组相关函数"><a href="#数组相关函数" class="headerlink" title="数组相关函数"></a>数组相关函数</h3><p> <strong>得到数组长度：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;info=&quot;it is a test&quot;;lens=split(info,tA,&quot; &quot;);print length(tA),lens;&#125;&#x27;</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure>
<p>length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);print asort(tA);&#125;&#x27;</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>asort对数组进行排序，返回数组长度。</p>
<p> <strong>输出数组内容（无序，有序输出）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#x27;</span><br><span class="line">4 test</span><br><span class="line">1 it</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br></pre></td></tr></table></figure>
<p><code>for…in</code>输出，因为数组是关联数组，默认是无序的。所以通过<code>for…in</code>得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;info=&quot;it is a test&quot;;tlen=split(info,tA,&quot; &quot;);for(k=1;k&amp;lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;&#x27;</span><br><span class="line">1 it</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br><span class="line">4 test</span><br></pre></td></tr></table></figure>
<p>注意：数组下标是从1开始，与C数组不一样。</p>
<p> <strong>判断键值存在以及删除键值：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#错误的判断方法：</span><br><span class="line">awk &#x27;BEGIN&#123;tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if(tB[&quot;c&quot;]!=&quot;1&quot;)&#123;print &quot;no found&quot;;&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;&#x27;</span><br><span class="line">no found</span><br><span class="line">a a1</span><br><span class="line">b b1</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>以上出现奇怪问题，<code>tB[“c”]</code>没有定义，但是循环时候，发现已经存在该键值，它的值为空，这里需要注意，awk数组是关联数组，只要通过数组引用它的key，就会自动创建改序列。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正确判断方法：</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if( &quot;c&quot; in tB)&#123;print &quot;ok&quot;;&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;&#x27;</span></span><br><span class="line">a a1</span><br><span class="line">b b1</span><br></pre></td></tr></table></figure>
<p><code>if(key in array)</code>通过这种方法判断数组中是否包含<code>key</code>键值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除键值：</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;delete tB[&quot;a&quot;];for(k in tB)&#123;print k,tB[k];&#125;&#125;&#x27;</span></span><br><span class="line">b b1</span><br></pre></td></tr></table></figure>
<p><code>delete array[key]</code>可以删除，对应数组<code>key</code>的，序列值。</p>
<h3 id="二维、多维数组使用"><a href="#二维、多维数组使用" class="headerlink" title="二维、多维数组使用"></a>二维、多维数组使用</h3><p>awk的多维数组在本质上是一维数组，更确切一点，awk在存储上并不支持多维数组。awk提供了逻辑上模拟二维数组的访问方式。例如，<code>array[2,4]=1</code>这样的访问是允许的。awk使用一个特殊的字符串<code>SUBSEP(�34)</code>作为分割字段，在上面的例子中，关联数组array存储的键值实际上是2�344。</p>
<p>类似一维数组的成员测试，多维数组可以使用<code>if ( (i,j) in array)</code>这样的语法，但是下标必须放置在圆括号中。类似一维数组的循环访问，多维数组使用<code>for ( item in array )</code>这样的语法遍历数组。与一维数组不同的是，多维数组必须使用<code>split()</code>函数来访问单独的下标分量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;</span></span><br><span class="line"><span class="string">for(i=1;i&amp;lt;=9;i++)&#123;</span></span><br><span class="line"><span class="string">  for(j=1;j&amp;lt;=9;j++)&#123;</span></span><br><span class="line"><span class="string">    tarr[i,j]=i*j; print i,&quot;*&quot;,j,&quot;=&quot;,tarr[i,j];</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line">1 * 1 = 1</span><br><span class="line">1 * 2 = 2</span><br><span class="line">1 * 3 = 3</span><br><span class="line">1 * 4 = 4</span><br><span class="line">1 * 5 = 5</span><br><span class="line">1 * 6 = 6</span><br><span class="line">...</span><br><span class="line">9 * 6 = 54</span><br><span class="line">9 * 7 = 63</span><br><span class="line">9 * 8 = 72</span><br><span class="line">9 * 9 = 81</span><br></pre></td></tr></table></figure>
<p>可以通过<code>array[k,k2]</code>引用获得数组内容。</p>
<p>另一种方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;</span></span><br><span class="line"><span class="string">for(i=1;i&amp;lt;=9;i++)&#123;</span></span><br><span class="line"><span class="string">  for(j=1;j&amp;lt;=9;j++)&#123;</span></span><br><span class="line"><span class="string">    tarr[i,j]=i*j;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">for(m in tarr)&#123;</span></span><br><span class="line"><span class="string">  split(m,tarr2,SUBSEP); print tarr2[1],&quot;*&quot;,tarr2[2],&quot;=&quot;,tarr[m];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。</p>
<h3 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h3><p>|格式|描述<br>|——<br>|atan2( y, x )|返回 y&#x2F;x 的反正切。<br>|cos( x )|返回 x 的余弦；x 是弧度。<br>|sin( x )|返回 x 的正弦；x 是弧度。<br>|exp( x )|返回 x 幂函数。<br>|log( x )|返回 x 的自然对数。<br>|sqrt( x )|返回 x 平方根。<br>|int( x )|返回 x 的截断至整数的值。<br>|rand( )|返回任意数字 n，其中 0 &lt;&#x3D; n &lt; 1。<br>|srand( [expr] )|将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。</p>
<p>举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;OFMT=&quot;%.3f&quot;;fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;&#x27;</span><br><span class="line">0.841 22026.466 2.303 3</span><br></pre></td></tr></table></figure>
<p>OFMT 设置输出数据格式是保留3位小数。</p>
<p>获得随机数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;</span><br><span class="line">78</span><br><span class="line">awk &#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;</span><br><span class="line">31</span><br><span class="line">awk &#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;</span><br><span class="line">41</span><br></pre></td></tr></table></figure>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>|格式|描述<br>|——<br>|gsub( Ere, Repl, [ In ] )|除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。<br>|sub( Ere, Repl, [ In ] )|用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。<br>|index( String1, String2 )|在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。<br>|length [(String)]|返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。<br>|blength [(String)]|返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。<br>|substr( String, M, [ N ] )|返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。<br>|match( String, Ere )|在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。<br>|split( String, A, [Ere] )|将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。<br>|tolower( String )|返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。<br>|toupper( String )|返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。<br>|sprintf(Format, Expr, Expr, . . . )|根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。</p>
<p>注：Ere都可以是正则表达式。</p>
<p> <strong>gsub,sub使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;gsub(/[0-9]+/,&quot;!&quot;,info);print info&#125;&#x27;</span><br><span class="line">this is a test!test!</span><br></pre></td></tr></table></figure>
<p>在 info中查找满足正则表达式，<code>/[0-9]+/</code> 用<code>””</code>替换，并且替换后的值，赋值给info 未给info值，默认是<code>$0</code></p>
<p> <strong>查找字符串（index使用）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>未找到，返回0</p>
<p> <strong>正则表达式匹配查找(match使用）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print match(info,/[0-9]+/)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p> <strong>截取字符串(substr使用）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wangsl@centos5 ~]$ awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print substr(info,4,10);&#125;&#x27;</span><br><span class="line">s is a tes</span><br></pre></td></tr></table></figure>
<p>从第 4个 字符开始，截取10个长度字符串</p>
<p> <strong>字符串分割（split使用）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;info=&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#x27;</span><br><span class="line">4</span><br><span class="line">4 test</span><br><span class="line">1 this</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br></pre></td></tr></table></figure>
<p>分割info，动态创建数组tA，这里比较有意思，<code>awk for …in</code>循环，是一个无序的循环。 并不是从数组下标1…n ，因此使用时候需要注意。</p>
<p> <strong>格式化字符串输出（sprintf使用）</strong></p>
<p>格式化字符串格式：</p>
<p>其中格式化字符串包括两部分内容：一部分是正常字符，这些字符将按原样输出; 另一部分是格式化规定字符，以<code>&quot;%&quot;</code>开始，后跟一个或几个规定字符,用来确定输出内容格式。</p>
<p>|格式|描述|格式|描述<br>|——<br>|%d|十进制有符号整数|%u|十进制无符号整数<br>|%f|浮点数|%s|字符串<br>|%c|单个字符|%p|指针的值<br>|%e|指数形式的浮点数|%x|%X 无符号以十六进制表示的整数<br>|%o|无符号以八进制表示的整数|%g|自动选择合适的表示法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf(&quot;%.2f,%.2u,%.2g,%X,%on&quot;,n1,n2,n3,n1,n1);&#125;&#x27;</span><br><span class="line">124.11,18446744073709551615,1.2,7C,174</span><br></pre></td></tr></table></figure>
<h3 id="一般函数"><a href="#一般函数" class="headerlink" title="一般函数"></a>一般函数</h3><p>|格式|描述<br>|——<br>|close( Expression )|用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。<br>|system(command )|执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程。<br>|Expression <code>|</code> getline [ Variable ]|从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。<br>|getline [ Variable ] &lt; Expression|从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。<br>|getline [ Variable ]|将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。</p>
<p> <strong>打开外部文件（close用法）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;while(&quot;cat /etc/passwd&quot;|getline)&#123;print $0;&#125;;close(&quot;/etc/passwd&quot;);&#125;&#x27;</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br></pre></td></tr></table></figure>
<p> <strong>逐行读取外部文件(getline使用方法）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;while(getline &amp;lt; &quot;/etc/passwd&quot;)&#123;print $0;&#125;;close(&quot;/etc/passwd&quot;);&#125;&#x27;</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;print &quot;Enter your name:&quot;;getline name;print name;&#125;&#x27;</span><br><span class="line">Enter your name:</span><br><span class="line">chengmo</span><br><span class="line">chengmo</span><br></pre></td></tr></table></figure>
<p> <strong>调用外部应用程序(system使用方法）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;b=system(&quot;ls -al&quot;);print b;&#125;&#x27;</span><br><span class="line">total 42092</span><br><span class="line">drwxr-xr-x 14 chengmo chengmo     4096 09-30 17:47 .</span><br><span class="line">drwxr-xr-x 95 root   root       4096 10-08 14:01 ..</span><br></pre></td></tr></table></figure>
<p>b返回值，是执行结果。</p>
<h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><p>|格式|描述<br>|——<br>|函数名|说明<br>|mktime( YYYY MM dd HH MM ss[ DST])|生成时间格式<br>|strftime([format [, timestamp]])|格式化时间输出，将时间戳转为时间字符串具体格式，见下表。<br>|systime()|得到时间戳，返回从1970年1月1日开始到当前时间(不计闰年)的整秒数</p>
<p> <strong>建指定时间(mktime使用）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;tstamp=mktime(&quot;2001 01 01 12 12 12&quot;);print strftime(&quot;%c&quot;,tstamp);&#125;&#x27;</span><br><span class="line">2001年01月01日 星期一 12时12分12秒</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=mktime(&quot;2001 02 01 0 0 0&quot;);print tstamp2-tstamp1;&#125;&#x27;</span><br><span class="line">2634468</span><br></pre></td></tr></table></figure>
<p>求2个时间段中间时间差，介绍了strftime使用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=systime();print tstamp2-tstamp1;&#125;&#x27;</span><br><span class="line">308201392</span><br></pre></td></tr></table></figure>
<p> <strong>strftime日期和时间格式说明符</strong></p>
<p>|格式|描述<br>|——<br>|%a|星期几的缩写(Sun)<br>|%A|星期几的完整写法(Sunday)<br>|%b|月名的缩写(Oct)<br>|%B|月名的完整写法(October)<br>|%c|本地日期和时间<br>|%d|十进制日期<br>|%D|日期 08&#x2F;20&#x2F;99<br>|%e|日期，如果只有一位会补上一个空格<br>|%H|用十进制表示24小时格式的小时<br>|%I|用十进制表示12小时格式的小时<br>|%j|从1月1日起一年中的第几天<br>|%m|十进制表示的月份<br>|%M|十进制表示的分钟<br>|%p|12小时表示法(AM&#x2F;PM)<br>|%S|十进制表示的秒<br>|%U|十进制表示的一年中的第几个星期(星期天作为一个星期的开始)<br>|%w|十进制表示的星期几(星期天是0)<br>|%W|十进制表示的一年中的第几个星期(星期一作为一个星期的开始)<br>|%x|重新设置本地日期(08&#x2F;20&#x2F;99)<br>|%X|重新设置本地时间(12:00:00)<br>|%y|两位数字表示的年(99)<br>|%Y|当前月份<br>|%%|百分号(%)</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（23） -- su</title>
    <url>/2018/01/22/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-23/</url>
    <content><![CDATA[<p>用于切换当前用户身份到其他用户身份</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>su命令</strong> 用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c&amp;lt;指令&amp;gt;或--command=&amp;lt;指令&amp;gt;：执行完指定的指令后，即恢复原来的身份；</span><br><span class="line">-f或——fast：适用于csh与tsch，使shell不用去读取启动文件；</span><br><span class="line">-l或——login：改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname。此外，也会变更PATH变量；</span><br><span class="line">-m,-p或--preserve-environment：变更身份时，不要变更环境变量；</span><br><span class="line">-s&lt;shell&gt;或--shell=&lt;shell&gt;：指定要执行的shell；&lt;/shell&gt;&lt;/shell&gt;</span><br><span class="line">--help：显示帮助；</span><br><span class="line">--version；显示版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>用户：指定要切换身份的目标用户。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>变更帐号为root并在执行ls指令后退出变回原使用者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su -c ls root</span><br></pre></td></tr></table></figure>
<p>变更帐号为root并传入<code>-f</code>选项给新执行的shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su root -f</span><br></pre></td></tr></table></figure>
<p>变更帐号为test并改变工作目录至test的家目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su -test</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（24） -- chgrp</title>
    <url>/2018/01/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-24/</url>
    <content><![CDATA[<p>用来变更文件或目录的所属群组</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>chgrp命令</strong> 用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组。其中，组名可以是用户组的id，也可以是用户组的组名。文件名可以 是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户(root)，则不能改变该文件的组。</p>
<p>在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chgrp [选项][组群][文件|目录]</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-R 递归式地改变指定目录及其下的所有子目录和文件的所属的组</span><br><span class="line">-c或——changes：效果类似“-v”参数，但仅回报更改的部分；</span><br><span class="line">-f或--quiet或——silent：不显示错误信息；</span><br><span class="line">-h或--no-dereference：只对符号连接的文件作修改，而不是该其他任何相关文件；</span><br><span class="line">-H如果命令行参数是一个通到目录的符号链接，则遍历符号链接</span><br><span class="line">-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；</span><br><span class="line">-L遍历每一个遇到的通到目录的符号链接</span><br><span class="line">-P不遍历任何符号链接（默认）</span><br><span class="line">-v或——verbose：显示指令执行过程；</span><br><span class="line">--reference=&amp;lt;参考文件或目录&amp;gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>组：指定新工作名称；</li>
<li>文件：指定要改变所属组的文件列表。多个文件或者目录之间使用空格隔开。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将<code>/usr/meng</code>及其子目录下的所有文件的用户组改为mengxin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chgrp -R mengxin /usr/meng</span><br></pre></td></tr></table></figure>
<p>更改文件ah的组群所有者为newuser</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@rhel ~]# chgrp newuser ah</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（25） -- chown</title>
    <url>/2018/01/24/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-25/</url>
    <content><![CDATA[<p>用来变更文件或目录的拥有者或所属群组</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>chown命令</strong> 改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。</p>
<p>只有文件主和超级用户才可以便用该命令。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c或——changes：效果类似“-v”参数，但仅回报更改的部分；</span><br><span class="line">-f或--quite或——silent：不显示错误信息；</span><br><span class="line">-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；</span><br><span class="line">-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；</span><br><span class="line">-v或——version：显示指令执行过程；</span><br><span class="line">--dereference：效果和“-h”参数相同；</span><br><span class="line">--help：在线帮助；</span><br><span class="line">--reference=&amp;lt;参考文件或目录&amp;gt;：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>用户：组：指定所有者和所属工作组。当省略“：组”，仅改变文件所有者；<br/>文件：指定要改变所有者和工作组的文件列表。支持多个文件和目标，支持shell通配符。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将目录<code>/usr/meng</code>及其下面的所有文件、子目录的文件主改成 liu：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R liu /usr/meng</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（27） -- zip</title>
    <url>/2018/01/26/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-27/</url>
    <content><![CDATA[<p>可以用来压缩文件</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>zip命令</strong> 可以用来压缩文件，或者对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A：调整可执行的自动解压缩文件；</span><br><span class="line">-b&amp;lt;工作目录&amp;gt;：指定暂时存放文件的目录；</span><br><span class="line">-c：替每个被压缩的文件加上注释；</span><br><span class="line">-d：从压缩文件内删除指定的文件；</span><br><span class="line">-D：压缩文件内不建立目录名称；</span><br><span class="line">-f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；</span><br><span class="line">-F：尝试修复已损坏的压缩文件；</span><br><span class="line">-g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；</span><br><span class="line">-h：在线帮助；</span><br><span class="line">-i&amp;lt;范本样式&amp;gt;：只压缩符合条件的文件；</span><br><span class="line">-j：只保存文件名称及其内容，而不存放任何目录名称；</span><br><span class="line">-J：删除压缩文件前面不必要的数据；</span><br><span class="line">-k：使用MS-DOS兼容格式的文件名称；</span><br><span class="line">-l：压缩文件时，把LF字符置换成LF+CR字符；</span><br><span class="line">-ll：压缩文件时，把LF+cp字符置换成LF字符；</span><br><span class="line">-L：显示版权信息；</span><br><span class="line">-m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；</span><br><span class="line">-n&amp;lt;字尾字符串&amp;gt;：不压缩具有特定字尾字符串的文件；</span><br><span class="line">-o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；</span><br><span class="line">-q：不显示指令执行过程；</span><br><span class="line">-r：递归处理，将指定目录下的所有文件和子目录一并处理；</span><br><span class="line">-S：包含系统和隐藏文件；</span><br><span class="line">-t&amp;lt;日期时间&amp;gt;：把压缩文件的日期设成指定的日期；</span><br><span class="line">-T：检查备份文件内的每个文件是否正确无误；</span><br><span class="line">-u：更换较新的文件到压缩文件内；</span><br><span class="line">-v：显示指令执行过程或显示版本信息；</span><br><span class="line">-V：保存VMS操作系统的文件属性；</span><br><span class="line">-w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；</span><br><span class="line">-x&amp;lt;范本样式&amp;gt;：压缩时排除符合条件的文件；</span><br><span class="line">-X：不保存额外的文件属性；</span><br><span class="line">-y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；</span><br><span class="line">-z：替压缩文件加上注释；</span><br><span class="line">-$：保存第一个被压缩文件所在磁盘的卷册名称；</span><br><span class="line">-&amp;lt;压缩效率&amp;gt;：压缩效率是一个介于1~9的数值。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>zip压缩包：指定要创建的zip压缩包；</li>
<li>文件列表：指定要压缩的文件列表。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将<code>/home/Blinux/html/</code>这个目录下所有文件和文件夹打包为当前目录下的html.zip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip -q -r html.zip /home/Blinux/html</span><br></pre></td></tr></table></figure>
<p>上面的命令操作是将绝对地址的文件及文件夹进行压缩，以下给出压缩相对路径目录，比如目前在Bliux这个目录下，执行以下操作可以达到以上同样的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip -q -r html.zip html</span><br></pre></td></tr></table></figure>
<p>比如现在我的html目录下，我操作的zip压缩命令是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip -q -r html.zip *</span><br></pre></td></tr></table></figure>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>CentOS7中命令找不到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Bash: Unzip: Command Not Found</span><br></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y unzip zip</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（28） -- unzip</title>
    <url>/2018/01/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-28/</url>
    <content><![CDATA[<p>用于解压缩由zip命令压缩的压缩包</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>unzip命令</strong> 用于解压缩由zip命令压缩的“.zip”压缩包。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换；</span><br><span class="line">-f：更新现有的文件；</span><br><span class="line">-l：显示压缩文件内所包含的文件；</span><br><span class="line">-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换；</span><br><span class="line">-t：检查压缩文件是否正确；</span><br><span class="line">-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中；</span><br><span class="line">-v：执行时显示详细的信息；</span><br><span class="line">-z：仅显示压缩文件的备注文字；</span><br><span class="line">-a：对文本文件进行必要的字符转换；</span><br><span class="line">-b：不要对文本文件进行字符转换；</span><br><span class="line">-C：压缩文件中的文件名称区分大小写；</span><br><span class="line">-j：不处理压缩文件中原有的目录路径；</span><br><span class="line">-L：将压缩文件中的全部文件名改为小写；</span><br><span class="line">-M：将输出结果送到more程序处理；</span><br><span class="line">-n：解压缩时不要覆盖原有的文件；</span><br><span class="line">-o：不必先询问用户，unzip执行后覆盖原有的文件；</span><br><span class="line">-P&amp;lt;密码&amp;gt;：使用zip的密码选项；</span><br><span class="line">-q：执行时不显示任何信息；</span><br><span class="line">-s：将文件名中的空白字符转换为底线字符；</span><br><span class="line">-V：保留VMS的文件版本信息；</span><br><span class="line">-X：解压缩时同时回存文件原来的UID/GID；</span><br><span class="line">-d&amp;lt;目录&amp;gt;：指定文件解压缩后所要存储的目录；</span><br><span class="line">-x&amp;lt;文件&amp;gt;：指定不要处理.zip压缩文件中的哪些文件；</span><br><span class="line">-Z：unzip-Z等于执行zipinfo指令。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>压缩包：指定要解压的“.zip”压缩包。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将压缩文件text.zip在当前目录下解压缩。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip test.zip</span><br></pre></td></tr></table></figure>
<p>将压缩文件text.zip在指定目录<code>/tmp</code>下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip -n test.zip -d /tmp</span><br></pre></td></tr></table></figure>
<p>查看压缩文件目录，但不解压。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip -v test.zip</span><br></pre></td></tr></table></figure>
<p>将压缩文件test.zip在指定目录<code>/tmp</code>下解压缩，如果已有相同的文件存在，要求unzip命令覆盖原先的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip -o test.zip -d tmp/</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（26） -- chmod</title>
    <url>/2018/01/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-26/</url>
    <content><![CDATA[<p>用来变更文件或目录的权限</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>chmod命令</strong> 用来变更文件或目录的权限。在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。用户可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。</p>
<p>权限范围的表示法如下：</p>
<p><code>u</code> User，即文件或目录的拥有者；<br/><code>g</code> Group，即文件或目录的所属群组；<br/><code>o</code> Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；<br/><code>a</code> All，即全部的用户，包含拥有者，所属群组以及其他用户；<br/><code>r</code> 读取权限，数字代号为“4”;<br/><code>w</code> 写入权限，数字代号为“2”；<br/><code>x</code> 执行或切换权限，数字代号为“1”；<br/><code>-</code> 不具任何权限，数字代号为“0”；<br/><code>s</code> 特殊功能说明：变更文件或目录的权限。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u  <span class="comment"># 操作对象简称，用户user，文件或目录的所有者。</span></span><br><span class="line">g  <span class="comment"># 操作对象简称，同组用户group，文件或目录所属群组</span></span><br><span class="line">o  <span class="comment"># 操作对象简称，其它用户others</span></span><br><span class="line">a  <span class="comment"># 操作对象简称，所有用户all，系统默认使用此项</span></span><br><span class="line">+  <span class="comment"># 权限操作符，添加某些权限</span></span><br><span class="line">-  <span class="comment"># 权限操作符，取消某些权限</span></span><br><span class="line">=  <span class="comment"># 权限操作符，设置文件的权限为给定的权限</span></span><br><span class="line">r  <span class="comment"># 权限设定（英文），表示可读权限</span></span><br><span class="line">w  <span class="comment"># 权限设定（英文），表示可写权限</span></span><br><span class="line">x  <span class="comment"># 权限设定（英文），表示可执行权限</span></span><br><span class="line">-  <span class="comment"># 权限设定（英文字符），表示没有权限</span></span><br><span class="line">X  <span class="comment"># 权限设定，如果目标文件是可执行文件或目录，可给其设置可执行权限</span></span><br><span class="line">s  <span class="comment"># 权限设定，设置权限suid和sgid，使用权限组合“u+s”设定文件的用户的ID位，“g+s”设置组ID位</span></span><br><span class="line">t  <span class="comment"># 权限设定，只有目录或文件的所有者才可以删除目录下的文件</span></span><br><span class="line">-c或——changes    <span class="comment"># 效果类似“-v”参数，但仅回报更改的部分，如果文件权限已经改变，显示其操作信息；</span></span><br><span class="line">-f或--quiet或——silent <span class="comment"># 操作过程中不显示任何错误信息；</span></span><br><span class="line">-R或——recursive  <span class="comment"># 递归处理，将指令目录下的所有文件及子目录一并处理；</span></span><br><span class="line">-v或——verbose    <span class="comment"># 显示命令运行时的详细执行过程；</span></span><br><span class="line">--reference=&amp;lt;参考文件或目录&amp;gt; <span class="comment"># 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；</span></span><br><span class="line">&amp;lt;权限范围&amp;gt;+&amp;lt;权限设置&amp;gt; <span class="comment"># 开启权限范围的文件或目录的该选项权限设置；</span></span><br><span class="line">&amp;lt;权限范围&amp;gt;-&amp;lt;权限设置&amp;gt; <span class="comment"># 关闭权限范围的文件或目录的该选项权限设置；</span></span><br><span class="line">&amp;lt;权限范围&amp;gt;=&amp;lt;权限设置&amp;gt; <span class="comment"># 指定权限范围的文件或目录的该选项权限设置；</span></span><br><span class="line">--<span class="built_in">help</span>    <span class="comment"># 显示帮助信息</span></span><br><span class="line">--version <span class="comment"># 显示版本信息</span></span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>权限模式：指定文件的权限模式；<br/>文件：要改变权限的文件。</p>
<h2 id="知识扩展和实例"><a href="#知识扩展和实例" class="headerlink" title="知识扩展和实例"></a>知识扩展和实例</h2><p>Linux用 户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信 息， 都是记录在<code>/etc/passwd</code>文件中。每个人的密码则是记录在<code>/etc/shadow</code>文件下。 此外，所有的组群名称记录在<code>/etc/group</code>內！</p>
<p>linux文件的用户权限的分析图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  -rw-r--r--   1 user  staff   651 Oct 12 12:53 .gitmodules</span><br><span class="line"><span class="comment"># ↑╰┬╯╰┬╯╰┬╯</span></span><br><span class="line"><span class="comment"># ┆ ┆  ┆  ╰┈ 0 其他人</span></span><br><span class="line"><span class="comment"># ┆ ┆  ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ g 属组</span></span><br><span class="line"><span class="comment"># ┆ ╰┈┈┈┈ u 属组</span></span><br><span class="line"><span class="comment"># ╰┈┈ 第一个字母 `d` 代表目录，`-` 代表普通文件</span></span><br></pre></td></tr></table></figure>
<p>例：rwx　rw-　r–</p>
<p>r&#x3D;读取属性　　&#x2F;&#x2F;值＝4<br/>w&#x3D;写入属性　　&#x2F;&#x2F;值＝2<br/>x&#x3D;执行属性　　&#x2F;&#x2F;值＝1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x,g+w f01　　<span class="comment"># 为文件f01设置自己可以执行，组员可以写入的权限</span></span><br><span class="line"><span class="built_in">chmod</span> u=rwx,g=rw,o=r f01</span><br><span class="line"><span class="built_in">chmod</span> 764 f01</span><br><span class="line"><span class="built_in">chmod</span> a+x f01　　    <span class="comment"># 对文件f01的u,g,o都设置可执行属性</span></span><br></pre></td></tr></table></figure>
<p>文件的属主和属组属性设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> user:market f01　　<span class="comment"># 把文件f01给uesr，添加到market组</span></span><br><span class="line">ll -d f1  查看目录f1的属性</span><br></pre></td></tr></table></figure>
<p>将<code>/home/wwwroot/</code>里的所有文件和文件夹设置为<code>755</code>权限</p>
<p>(1)直接指定路径修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R  755 /home/wwwroot/*</span><br></pre></td></tr></table></figure>
<p>(2)手动进入该目录修改权限（并显示详细过程）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/wwwroot</span><br><span class="line"><span class="built_in">chmod</span> -Rv  755 *       <span class="comment">#注意：“*”表示通配符，指的是所有文件和文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> o+rw /shared <span class="comment">#设置文件夹权限以保证其余用户可以访问它。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（29） -- gzip</title>
    <url>/2018/01/28/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-29/</url>
    <content><![CDATA[<p>用来压缩文件</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>gzip命令</strong> 用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。</p>
<p>gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a或——ascii：使用ASCII文字模式；</span><br><span class="line">-d或--decompress或----uncompress：解开压缩文件；</span><br><span class="line">-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</span><br><span class="line">-h或——help：在线帮助；</span><br><span class="line">-l或——list：列出压缩文件的相关信息；</span><br><span class="line">-L或——license：显示版本与版权信息；</span><br><span class="line">-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；</span><br><span class="line">-N或——name：压缩文件时，保存原来的文件名称及时间戳记；</span><br><span class="line">-q或——quiet：不显示警告信息；</span><br><span class="line">-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；</span><br><span class="line">-S或&amp;lt;压缩字尾字符串&amp;gt;或----suffix&amp;lt;压缩字尾字符串&amp;gt;：更改压缩字尾字符串；</span><br><span class="line">-t或——test：测试压缩文件是否正确无误；</span><br><span class="line">-v或——verbose：显示指令执行过程；</span><br><span class="line">-V或——version：显示版本信息；</span><br><span class="line">-&amp;lt;压缩效率&amp;gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；</span><br><span class="line">--best：此参数的效果和指定“-9”参数相同；</span><br><span class="line">--fast：此参数的效果和指定“-1”参数相同。</span><br><span class="line">-num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件列表：指定要压缩的文件列表。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>把test6目录下的每个文件压缩成.gz文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip *</span><br></pre></td></tr></table></figure>
<p>把上例中每个压缩的文件解压，并列出详细的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip -dv *</span><br></pre></td></tr></table></figure>
<p>详细显示例1中每个压缩的文件的信息，并不解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip -l *</span><br></pre></td></tr></table></figure>
<p>压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip -r log.tar</span><br></pre></td></tr></table></figure>
<p>递归的压缩目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip -rv test6</span><br></pre></td></tr></table></figure>
<p>这样，所有test下面的文件都变成了**.gz，目录依然存在只是目录里面的文件相应变成了**.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。</p>
<p>递归地解压目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip -dr test6</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（3） -- mkdir</title>
    <url>/2018/01/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-3/</url>
    <content><![CDATA[<h2 id="创建空目录"><a href="#创建空目录" class="headerlink" title="创建空目录"></a>创建空目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  Downloads mkdir testdir</span><br><span class="line">➜  Downloads ll</span><br><span class="line">total 540M</span><br><span class="line">-rw-rw-r--  1 atompi atompi 508M Jan  1 20:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">drwxr-xr-x 36 atompi atompi 4.0K Jan  5 05:59 mysql-5.6.38</span><br><span class="line">-rw-rw-r--  1 atompi atompi  31M Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Sep 21 07:20 redis-3.2.11</span><br><span class="line">-rw-rw-r--  1 atompi atompi 1.5M Sep 21 07:20 redis-3.2.11.tar.gz</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  6 04:18 testdir</span><br><span class="line">-rw-rw-r--  1 atompi atompi    0 Jan  6 04:04 test.txt</span><br><span class="line">➜  Downloads ll testdir</span><br><span class="line">total 0</span><br></pre></td></tr></table></figure>
<h2 id="递归创建目录与子目录"><a href="#递归创建目录与子目录" class="headerlink" title="递归创建目录与子目录"></a>递归创建目录与子目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ll Downloads/testdir</span><br><span class="line">total 0</span><br><span class="line">➜  ~ mkdir -p Downloads/testdir/testdir1/testdir2</span><br><span class="line">➜  ~ ll Downloads/testdir</span><br><span class="line">total 4.0K</span><br><span class="line">drwxrwxr-x 3 atompi atompi 4.0K Jan  6 04:19 testdir1</span><br><span class="line">➜  ~ ll Downloads/testdir1</span><br><span class="line">ls: cannot access &#x27;Downloads/testdir1&#x27;: No such file or directory</span><br><span class="line">➜  ~ ll Downloads/testdir/testdir1</span><br><span class="line">total 4.0K</span><br><span class="line">drwxrwxr-x 2 atompi atompi 4.0K Jan  6 04:19 testdir2</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（30） -- gunzip</title>
    <url>/2018/01/29/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-30/</url>
    <content><![CDATA[<p>用来解压缩文件</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>gunzip命令</strong> 用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为.gz。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gunzip (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a或——ascii：使用ASCII文字模式；</span><br><span class="line">-c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；</span><br><span class="line">-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</span><br><span class="line">-h或——help：在线帮助；</span><br><span class="line">-l或——list：列出压缩文件的相关信息；</span><br><span class="line">-L或——license：显示版本与版权信息；</span><br><span class="line">-n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；</span><br><span class="line">-N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；</span><br><span class="line">-q或——quiet：不显示警告信息；</span><br><span class="line">-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；</span><br><span class="line">-S或&amp;lt;压缩字尾字符串&amp;gt;或----suffix&amp;lt;压缩字尾字符串&amp;gt;：更改压缩字尾字符串；</span><br><span class="line">-t或——test：测试压缩文件是否正确无误；</span><br><span class="line">-v或——verbose：显示指令执行过程；</span><br><span class="line">-V或——version：显示版本信息；</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件列表：指定要解压缩的压缩包。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先将<code>/etc</code>目录下的所有文件以及子目录进行压缩，备份压缩包etc.zip到<code>/opt</code>目录，然后对etc.zip文件进行gzip压缩，设置gzip的压缩级别为9。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip –r /opt/etc.zip /etc</span><br><span class="line">gzip -9v /opt/etc.zip</span><br></pre></td></tr></table></figure>
<p>查看上述etc.zip.gz文件的压缩信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip -l /opt/etc.zip.gz</span><br><span class="line">compressed        uncompressed ratio uncompressed_name</span><br><span class="line">11938745            12767265   6.5% /opt/etc.zip</span><br></pre></td></tr></table></figure>
<p>解压上述etc.zip.gz文件到当前目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@mylinux ~]#gzip –d /opt/etc.zip.gz</span><br><span class="line">或者执行</span><br><span class="line">[root@mylinux ~]#gunzip /opt/etc.zip.gz</span><br></pre></td></tr></table></figure>
<p>通过上面的示例可以知道<code>gzip –d</code>等价于<code>gunzip</code>命令。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（31） -- bzip2</title>
    <url>/2018/01/30/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-31/</url>
    <content><![CDATA[<p>将文件压缩成bz2格式</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>bzip2命令</strong> 用于创建和管理（包括解压缩）“.bz2”格式的压缩包。我们遇见Linux压缩打包方法有很多种，以下讲解了Linux压缩打包方法中的Linux bzip2命令的多种范例供大家查看，相信大家看完后会有很多收获。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c或——stdout：将压缩与解压缩的结果送到标准输出；</span><br><span class="line">-d或——decompress：执行解压缩；</span><br><span class="line">-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；</span><br><span class="line">-h或——help：在线帮助；</span><br><span class="line">-k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；</span><br><span class="line">-s或——small：降低程序执行时内存的使用量；</span><br><span class="line">-t或——test：测试.bz2压缩文件的完整性；</span><br><span class="line">-v或——verbose：压缩或解压缩文件时，显示详细的信息；</span><br><span class="line">-z或——compress：强制执行压缩；</span><br><span class="line">-V或——version：显示版本信息；</span><br><span class="line">--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；</span><br><span class="line">--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件：指定要压缩的文件。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> <strong>压缩指定文件filename:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 filename</span><br><span class="line">或</span><br><span class="line">bzip2 -z filename</span><br></pre></td></tr></table></figure>
<p>这里，压缩的时候不会输出，会将原来的文件filename给删除，替换成filename.bz2.如果以前有filename.bz2则不会替换并提示错误（如果想要替换则指定-f选项，例如<code>bzip2 -f filename</code>；如果filename是目录则也提醒错误不做任何操作；如果filename已经是压过的了有bz2后缀就提醒一下，不再压缩，没有bz2后缀会再次压缩。</p>
<p> <strong>解压指定的文件filename.bz2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 -d filename.bz2</span><br><span class="line">或</span><br><span class="line">bunzip2 filename.bz2</span><br></pre></td></tr></table></figure>
<p>这里，解压的时候没标准输出，会将原来的文件filename.bz2给替换成filename。如果以前有filename则不会替换并提示错误（如果想要替换则指定<code>-f</code>选项，例如<code>bzip2 -df filename.bz2</code>。</p>
<p> <strong>压缩解压的时候将结果也输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$bzip2 -v filename</span><br></pre></td></tr></table></figure>
<p>输入之后，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename:  0.119:1, 67.200 bits/byte, -740.00% saved, 5 in, 42 out.</span><br></pre></td></tr></table></figure>
<p>这里，加上<code>-v</code>选项就会输出了,只用压缩举例了，解压的时候同理<code>bzip2 -dv filename.bz2</code>不再举例了。</p>
<p> <strong>模拟解压实际并不解压：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 -tv filename.bz2</span><br></pre></td></tr></table></figure>
<p>输入之后，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename.bz2: ok</span><br></pre></td></tr></table></figure>
<p>这里，<code>-t</code>指定要进行模拟解压，不实际生成结果，也就是说类似检查文件,当然就算目录下面有filename也不会有什么错误输出了，因为它根本不会真的解压文件。为了在屏幕上输出，这里加上<code>-v</code>选项了,如果是真的解压<code>bzip2 -dv filename.bz2</code>则输出的是把”ok”替换成了”done”。</p>
<p> <strong>压缩解压的时候，除了生成结果文件，将原来的文件也保存:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 -k filename</span><br></pre></td></tr></table></figure>
<p>这里，加上<code>-k</code>就保存原始的文件了，否则原始文件会被结果文件替代。只用压缩举例了，解压的时候同理<code>$bzip2 -dk filename.bz2</code>不再举例了。</p>
<p> <strong>解压到标准输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 -dc filename.bz2</span><br></pre></td></tr></table></figure>
<p>输入之后，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hahahhaahahha</span><br></pre></td></tr></table></figure>
<p>这里，使用<code>-c</code>指定到标准输出，输出的是文件filename的内容，不会将filename.bz2删除。</p>
<p> <strong>压缩到标准输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 -c filename</span><br><span class="line">bzip2: I won&#x27;t write compressed data to a terminal.</span><br><span class="line">bzip2: For help, type: `bzip2 --help&#x27;.</span><br></pre></td></tr></table></figure>
<p>这里，使用<code>-c</code>指定压缩到标准输出不删除原有文件，不同的是，压缩后的文件无法输出到标准输出。</p>
<p> <strong>使用bzip2的时候将所有后面的看作文件(即使文件名以’-‘开头)：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 -- -myfilename</span><br></pre></td></tr></table></figure>
<p>这里主要是为了防止文件名中<code>-</code>产生以为是选项的歧义。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（32） -- bunzip2</title>
    <url>/2018/01/31/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-32/</url>
    <content><![CDATA[<p>解压一个bz2文件压缩包</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>bunzip2命令</strong> 解压缩由bzip2指令创建的”.bz2”压缩包。对文件进行压缩与解压缩。此命令类似于“gzip&#x2F;gunzip”命令，只能对文件进行压缩。对于目录只能压缩目录下的所有文件，压缩完成后，在目录下生成以“.bz2”为后缀的压缩包。bunzip2其实是bzip2的符号链接，即软链接，因此压缩解压都可以通过bzip2实现。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bunzip2 (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f或--force：解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件；</span><br><span class="line">-k或——keep：在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数；</span><br><span class="line">-s或——small：降低程序执行时，内存的使用量；</span><br><span class="line">-v或——verbose：解压缩文件时，显示详细的信息；</span><br><span class="line">-l，--license，-V或——version：显示版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>.bz2压缩包：指定需要解压缩的.bz2压缩包。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将<code>/opt</code>目录下的etc.zip、var.zip和backup.zip进行压缩，设置压缩率为最高，同时在压缩完毕后不删除原始文件，显示压缩过程的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bzip2 -9vk /opt/etc.zip /opt/var.zip /opt/backup.zip</span><br></pre></td></tr></table></figure>
<p>压缩完毕后，在<code>/opt</code>下就会生成相应的etc.zip.bz2、var.zip.bz2和backup.zip.bz2文件。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（33） -- tar</title>
    <url>/2018/02/01/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-33/</url>
    <content><![CDATA[<p>Linux下的归档使用工具，用来打包和备份。</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>tar命令</strong> 可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p>
<p>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p>
<p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A或--catenate：新增文件到以存在的备份文件；</span><br><span class="line">-B：设置区块大小；</span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-C &amp;lt;目录&amp;gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">-d：记录文件的差别；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-t或--list：列出备份文件的内容；</span><br><span class="line">-z或--gzip或--ungzip：通过gzip指令处理备份文件；</span><br><span class="line">-Z或--compress或--uncompress：通过compress指令处理备份文件；</span><br><span class="line">-f&amp;lt;备份文件&amp;gt;或--file=&amp;lt;备份文件&amp;gt;：指定备份文件；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-r：添加文件到已经压缩的文件；</span><br><span class="line">-u：添加改变了和现有的文件到已经存在的压缩文件；</span><br><span class="line">-j：支持bzip2解压文件；</span><br><span class="line">-v：显示操作过程；</span><br><span class="line">-l：文件系统边界设置；</span><br><span class="line">-k：保留原有文件不覆盖；</span><br><span class="line">-m：保留文件不被覆盖；</span><br><span class="line">-w：确认压缩文件的正确性；</span><br><span class="line">-p或--same-permissions：用原来的文件权限还原文件；</span><br><span class="line">-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；</span><br><span class="line">-N &amp;lt;日期格式&amp;gt; 或 --newer=&amp;lt;日期时间&amp;gt;：只将较指定日期更新的文件保存到备份文件里；</span><br><span class="line">--exclude=&amp;lt;范本样式&amp;gt;：排除符合范本样式的文件。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件或目录：指定要打包的文件或目录列表。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- z：有gzip属性的</span><br><span class="line">- j：有bz2属性的</span><br><span class="line">- Z：有compress属性的</span><br><span class="line">- v：显示所有过程</span><br><span class="line">- O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>
<p>下面的参数-f是必须的</p>
<p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cf all.tar *.jpg</span><br><span class="line"><span class="comment"># 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</span></span><br><span class="line"></span><br><span class="line">tar -rf all.tar *.gif</span><br><span class="line"><span class="comment"># 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</span></span><br><span class="line"></span><br><span class="line">tar -uf all.tar logo.gif</span><br><span class="line"><span class="comment"># 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</span></span><br><span class="line"></span><br><span class="line">tar -tf all.tar</span><br><span class="line"><span class="comment"># 这条命令是列出all.tar包中所有文件，-t是列出文件的意思</span></span><br></pre></td></tr></table></figure>
<h3 id="zip格式"><a href="#zip格式" class="headerlink" title="zip格式"></a>zip格式</h3><p>压缩： zip -r [目标文件名].zip [原文件&#x2F;目录名]<br/>解压： unzip [原文件名].zip<br/>注：-r参数代表递归</p>
<h3 id="tar格式（该格式仅仅打包，不压缩）"><a href="#tar格式（该格式仅仅打包，不压缩）" class="headerlink" title="tar格式（该格式仅仅打包，不压缩）"></a>tar格式（该格式仅仅打包，不压缩）</h3><p>打包：tar -cvf [目标文件名].tar [原文件名&#x2F;目录名]<br/>解包：tar -xvf [原文件名].tar<br/>注：c参数代表create（创建），x参数代表extract（解包），v参数代表verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。</p>
<h3 id="tar-gz格式"><a href="#tar-gz格式" class="headerlink" title="tar.gz格式"></a>tar.gz格式</h3><p>方式一：利用前面已经打包好的tar文件，直接用压缩命令。</p>
<p>压缩：gzip [原文件名].tar<br/>解压：gunzip [原文件名].tar.gz</p>
<p>方式二：一次性打包并压缩、解压并解包</p>
<p>打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名&#x2F;目录名]<br/>解压并解包： tar -zxvf [原文件名].tar.gz<br/>注：z代表用gzip算法来压缩&#x2F;解压。</p>
<h3 id="tar-bz2格式"><a href="#tar-bz2格式" class="headerlink" title="tar.bz2格式"></a>tar.bz2格式</h3><p>方式一：利用已经打包好的tar文件，直接执行压缩命令：</p>
<p>压缩：bzip2 [原文件名].tar<br/>解压：bunzip2 [原文件名].tar.bz2<br/>方式二：一次性打包并压缩、解压并解包</p>
<p>打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名&#x2F;目录名]<br/>解压并解包： tar -jxvf [原文件名].tar.bz2<br/>注：小写j代表用bzip2算法来压缩&#x2F;解压。</p>
<h3 id="tar-xz格式"><a href="#tar-xz格式" class="headerlink" title="tar.xz格式"></a>tar.xz格式</h3><p>方式一：利用已经打包好的tar文件，直接用压缩命令：</p>
<p>压缩：xz [原文件名].tar<br/>解压：unxz [原文件名].tar.xz<br/>方式二：一次性打包并压缩、解压并解包</p>
<p>打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名&#x2F;目录名]<br/>解压并解包： tar -Jxvf [原文件名].tar.xz<br/>注：大写J代表用xz算法来压缩&#x2F;解压。</p>
<h3 id="tar-Z格式（已过时）"><a href="#tar-Z格式（已过时）" class="headerlink" title="tar.Z格式（已过时）"></a>tar.Z格式（已过时）</h3><p>方式一：利用已经打包好的tar文件，直接用压缩命令：</p>
<p>压缩：compress [原文件名].tar<br/>解压：uncompress [原文件名].tar.Z<br/>方式二：一次性打包并压缩、解压并解包</p>
<p>打包并压缩： tar -Zcvf [目标文件名].tar.Z [原文件名&#x2F;目录名]<br/>解压并解包： tar -Zxvf [原文件名].tar.Z<br/>注：大写Z代表用ncompress算法来压缩&#x2F;解压。另，ncompress是早期Unix系统的压缩格式，但由于ncompress的压缩率太低，现已过时。</p>
<h3 id="jar格式"><a href="#jar格式" class="headerlink" title="jar格式"></a>jar格式</h3><p>压缩：jar -cvf [目标文件名].jar [原文件名&#x2F;目录名]<br/>解压：jar -xvf [原文件名].jar<br/>注：如果是打包的是Java类库，并且该类库中存在主类，那么需要写一个META-INF&#x2F;MANIFEST.MF配置文件，内容如下：</p>
<p>Manifest-Version: 1.0<br/>Created-By: 1.6.0_27 (Sun Microsystems Inc.)<br/>Main-class: the_name_of_the_main_class_should_be_put_here<br/>然后用如下命令打包：</p>
<p>jar -cvfm [目标文件名].jar META-INF&#x2F;MANIFEST.MF [原文件名&#x2F;目录名]<br/>这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static void main方法了。</p>
<h3 id="7z格式"><a href="#7z格式" class="headerlink" title="7z格式"></a>7z格式</h3><p>压缩：7z a [目标文件名].7z [原文件名&#x2F;目录名]<br/>解压：7z x [原文件名].7z<br/>注：这个7z解压命令支持rar格式，即：</p>
<p>7z x [原文件名].rar</p>
<h3 id="其它例子"><a href="#其它例子" class="headerlink" title="其它例子"></a>其它例子</h3><p> <strong>将文件全部打包成tar包</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cvf log.tar log2012.log    仅打包，不压缩！</span><br><span class="line">tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩</span><br><span class="line">tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩</span><br></pre></td></tr></table></figure>
<p>在选项<code>f</code>之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加<code>z</code>选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加<code>j</code>选项，则以.tar.bz2来作为tar包名。</p>
<p> <strong>查阅上述tar包内有哪些文件</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -ztvf log.tar.gz</span><br></pre></td></tr></table></figure>
<p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上<code>z</code>这个选项了。</p>
<p> <strong>将tar包解压缩</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf /opt/soft/test/log.tar.gz</span><br></pre></td></tr></table></figure>
<p>在预设的情况下，我们可以将压缩档在任何地方解开的</p>
<p> <strong>只将tar内的部分文件解压出来</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf /opt/soft/test/log30.tar.gz log2013.log</span><br></pre></td></tr></table></figure>
<p>我可以透过<code>tar -ztvf</code>来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！</p>
<p> <strong>文件备份下来，并且保存其权限</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log</span><br></pre></td></tr></table></figure>
<p>这个<code>-p</code>的属性是很重要的，尤其是当您要保留原本文件的属性时。</p>
<p> <strong>在文件夹当中，比某个日期新的文件才备份</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -N &quot;2012/11/13&quot; -zcvf log17.tar.gz test</span><br></pre></td></tr></table></figure>
<p> <strong>备份文件夹内容是排除部分文件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar --exclude scf/service -zcvf scf.tar.gz scf/*</span><br></pre></td></tr></table></figure>
<p> <strong>其实最简单的使用 tar 就只要记忆底下的方式即可：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</span><br><span class="line">查　询：tar -jtv -f filename.tar.bz2</span><br><span class="line">解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（34） -- locate</title>
    <url>/2018/02/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-34/</url>
    <content><![CDATA[<p>Linux 档案定位工具</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。</p>
<p>locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc&#x2F;crontab)</p>
<p>locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”<strong>” 或”?”等）来指定范本样式，如指定范本为kcpa</strong>ner, locate 会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。</p>
<p>locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate [选择参数] [样式]</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e 将排除在寻找的范围之外。</span><br><span class="line">-1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的  权限资料。</span><br><span class="line">-f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案  放在资料库中。</span><br><span class="line">-q 安静模式，不会显示任何错误讯息。</span><br><span class="line">-n 至多显示 n个输出。</span><br><span class="line">-r 使用正规运算式 做寻找的条件。</span><br><span class="line">-o 指定资料库存的名称。</span><br><span class="line">-d 指定资料库的路径</span><br><span class="line">-h 显示辅助讯息</span><br><span class="line">-V 显示程式的版本讯息</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实例1：查找和pwd相关的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root ~ # locate pwd</span><br><span class="line">/bin/pwd</span><br><span class="line">/etc/.pwd.lock</span><br><span class="line">/sbin/unix_chkpwd</span><br><span class="line">/usr/bin/pwdx</span><br><span class="line">/usr/include/pwd.h</span><br><span class="line">/usr/lib/python2.7/dist-packages/twisted/python/fakepwd.py</span><br><span class="line">/usr/lib/python2.7/dist-packages/twisted/python/fakepwd.pyc</span><br><span class="line">/usr/lib/python2.7/dist-packages/twisted/python/test/test_fakepwd.py</span><br><span class="line">/usr/lib/python2.7/dist-packages/twisted/python/test/test_fakepwd.pyc</span><br><span class="line">/usr/lib/syslinux/pwd.c32</span><br><span class="line">/usr/share/help/C/empathy/irc-join-pwd.page</span><br><span class="line">/usr/share/help/ca/empathy/irc-join-pwd.page</span><br><span class="line">/usr/share/help/cs/empathy/irc-join-pwd.page</span><br><span class="line">/usr/share/help/de/empathy/irc-join-pwd.page</span><br><span class="line">/usr/share/help/el/empathy/irc-join-pwd.page</span><br></pre></td></tr></table></figure>
<p>实例2： 搜索etc目录下所有以sh开头的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root ~ # locate /etc/sh</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/shadow-</span><br><span class="line">/etc/shells</span><br></pre></td></tr></table></figure>
<p>实例3：搜索etc目录下，所有以m开头的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root ~ # locate /etc/m</span><br><span class="line">/etc/magic</span><br><span class="line">/etc/magic.mime</span><br><span class="line">/etc/mailcap</span><br><span class="line">/etc/mailcap.order</span><br><span class="line">/etc/manpath.config</span><br><span class="line">/etc/mate-settings-daemon</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（35） -- updatedb</title>
    <url>/2018/02/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-35/</url>
    <content><![CDATA[<p>创建或更新slocate命令所必需的数据库文件</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>updatedb命令</strong> 用来创建或更新slocate命令所必需的数据库文件。updatedb命令的执行过程较长，因为在执行时它会遍历整个系统的目录树，并将所有的文件信息写入slocate数据库文件中。</p>
<p>补充说明 2：slocate本身具有一个数据库，里面存放了系统中文件与目录的相关信息。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatedb (选项)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-o&amp;lt;文件&amp;gt;：忽略默认的数据库文件，使用指定的slocate数据库文件；</span><br><span class="line">-U&amp;lt;目录&amp;gt;：更新指定目录的slocate数据库；</span><br><span class="line">-v：显示执行的详细过程。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实用updatedb命令的<code>-U</code>选项可以指定要更新slocate数据库的目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatedb -U /usr/local/  更新指定命令的slocate数据库</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（36） -- grep</title>
    <url>/2018/02/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-36/</url>
    <content><![CDATA[<p>强大的文本搜索工具</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>grep</strong> （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤&#x2F;搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a --text  <span class="comment"># 不要忽略二进制数据。</span></span><br><span class="line">-A &amp;lt;显示行数&amp;gt;   --after-context=&amp;lt;显示行数&amp;gt;   <span class="comment"># 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span></span><br><span class="line">-b --byte-offset                           <span class="comment"># 在显示符合范本样式的那一行之外，并显示该行之前的内容。</span></span><br><span class="line">-B&amp;lt;显示行数&amp;gt;   --before-context=&amp;lt;显示行数&amp;gt;   <span class="comment"># 除了显示符合样式的那一行之外，并显示该行之前的内容。</span></span><br><span class="line">-c --count    <span class="comment"># 计算符合范本样式的列数。</span></span><br><span class="line">-C&amp;lt;显示行数&amp;gt; --context=&amp;lt;显示行数&amp;gt;或-&amp;lt;显示行数&amp;gt; <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line">-d&amp;lt;进行动作&amp;gt; --directories=&amp;lt;动作&amp;gt;  <span class="comment"># 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</span></span><br><span class="line">-e&amp;lt;范本样式&amp;gt; --regexp=&amp;lt;范本样式&amp;gt;   <span class="comment"># 指定字符串作为查找文件内容的范本样式。</span></span><br><span class="line">-E --extended-regexp             <span class="comment"># 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span></span><br><span class="line">-f&amp;lt;范本文件&amp;gt; --file=&amp;lt;规则文件&amp;gt;     <span class="comment"># 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</span></span><br><span class="line">-F --fixed-regexp   <span class="comment"># 将范本样式视为固定字符串的列表。</span></span><br><span class="line">-G --basic-regexp   <span class="comment"># 将范本样式视为普通的表示法来使用。</span></span><br><span class="line">-h --no-filename    <span class="comment"># 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line">-H --with-filename  <span class="comment"># 在显示符合范本样式的那一列之前，标示该列的文件名称。</span></span><br><span class="line">-i --ignore-case    <span class="comment"># 忽略字符大小写的差别。</span></span><br><span class="line">-l --file-with-matches   <span class="comment"># 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line">-L --files-without-match <span class="comment"># 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line">-n --line-number         <span class="comment"># 在显示符合范本样式的那一列之前，标示出该列的编号。</span></span><br><span class="line">-q --quiet或--silent     <span class="comment"># 不显示任何信息。</span></span><br><span class="line">-R/-r  --recursive       <span class="comment"># 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line">-s --no-messages  <span class="comment"># 不显示错误信息。</span></span><br><span class="line">-v --revert-match <span class="comment"># 反转查找。</span></span><br><span class="line">-V --version      <span class="comment"># 显示版本信息。</span></span><br><span class="line">-w --word-regexp  <span class="comment"># 只显示全字符合的列。</span></span><br><span class="line">-x --line-regexp  <span class="comment"># 只显示全列符合的列。</span></span><br><span class="line">-y <span class="comment"># 此参数效果跟“-i”相同。</span></span><br><span class="line">-o <span class="comment"># 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure>
<h2 id="规则表达式"><a href="#规则表达式" class="headerlink" title="规则表达式"></a>规则表达式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^    <span class="comment"># 锚定行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。</span></span><br><span class="line">$    <span class="comment"># 锚定行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。</span></span><br><span class="line">.    <span class="comment"># 匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。</span></span><br><span class="line">*    <span class="comment"># 匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。</span></span><br><span class="line">.*   <span class="comment"># 一起用代表任意字符。</span></span><br><span class="line">[]   <span class="comment"># 匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。</span></span><br><span class="line">[^]  <span class="comment"># 匹配一个不在指定范围内的字符，如：&#x27;[^A-FH-Z]rep&#x27;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。</span></span><br><span class="line">\(..\)  <span class="comment"># 标记匹配字符，如&#x27;\(love\)&#x27;，love被标记为1。</span></span><br><span class="line">\&amp;lt;      <span class="comment"># 锚定单词的开始，如:&#x27;\&lt;grep&#x27;匹配包含以grep开头的单词的行。 &lt;=&quot;&quot; span=&quot;&quot;&gt;&lt;/grep&#x27;匹配包含以grep开头的单词的行。&gt;</span></span><br><span class="line">\&amp;gt;      <span class="comment"># 锚定单词的结束，如&#x27;grep\&amp;gt;&#x27;匹配包含以grep结尾的单词的行。</span></span><br><span class="line">x\&#123;m\&#125;  <span class="comment"># 重复字符x，m次，如：&#x27;0\&#123;5\&#125;&#x27;匹配包含5个o的行。</span></span><br><span class="line">x\&#123;m,\&#125;   <span class="comment"># 重复字符x,至少m次，如：&#x27;o\&#123;5,\&#125;&#x27;匹配至少有5个o的行。</span></span><br><span class="line">x\&#123;m,n\&#125;  <span class="comment"># 重复字符x，至少m次，不多于n次，如：&#x27;o\&#123;5,10\&#125;&#x27;匹配5--10个o的行。</span></span><br><span class="line">\w    <span class="comment"># 匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#x27;G\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。</span></span><br><span class="line">\W    <span class="comment"># \w的反置形式，匹配一个或多个非单词字符，如点号句号等。</span></span><br><span class="line">\b    <span class="comment"># 单词锁定符，如: &#x27;\bgrep\b&#x27;只匹配grep。</span></span><br></pre></td></tr></table></figure>
<h2 id="grep命令常见用法"><a href="#grep命令常见用法" class="headerlink" title="grep命令常见用法"></a>grep命令常见用法</h2><p>在文件中搜索一个单词，命令会返回一个包含 <strong>“match_pattern”</strong> 的文本行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep match_pattern file_name</span><br><span class="line">grep &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure>
<p>在多个文件中查找：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &quot;match_pattern&quot; file_1 file_2 file_3 ...</span><br></pre></td></tr></table></figure>
<p>输出除之外的所有行  <strong>-v</strong>  选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -v &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure>
<p>标记匹配颜色  <strong>–color&#x3D;auto</strong>  选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &quot;match_pattern&quot; file_name --color=auto</span><br></pre></td></tr></table></figure>
<p>使用正则表达式  <strong>-E</strong>  选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -E &quot;[1-9]+&quot;</span><br><span class="line">或</span><br><span class="line">egrep &quot;[1-9]+&quot;</span><br></pre></td></tr></table></figure>
<p>只输出文件中匹配到的部分  <strong>-o</strong>  选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo this is a test line. | grep -o -E &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line">echo this is a test line. | egrep -o &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br></pre></td></tr></table></figure>
<p>统计文件或者文本中包含匹配字符串的行数  <strong>-c</strong>  选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -c &quot;text&quot; file_name</span><br></pre></td></tr></table></figure>
<p>输出包含匹配字符串的行数  <strong>-n</strong>  选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &quot;text&quot; -n file_name</span><br><span class="line">或</span><br><span class="line">cat file_name | grep &quot;text&quot; -n</span><br><span class="line"></span><br><span class="line">#多个文件</span><br><span class="line">grep &quot;text&quot; -n file_1 file_2</span><br></pre></td></tr></table></figure>
<p>打印样式匹配所位于的字符或字节偏移：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo gun is not unix | grep -b -o &quot;not&quot;</span><br><span class="line">7:not</span><br><span class="line"></span><br><span class="line">#一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项  **-b -o**  一般总是配合使用。</span><br></pre></td></tr></table></figure>
<p>搜索多个文件并查找匹配文本在哪些文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -l &quot;text&quot; file1 file2 file3...</span><br></pre></td></tr></table></figure>
<h2 id="grep递归搜索文件"><a href="#grep递归搜索文件" class="headerlink" title="grep递归搜索文件"></a>grep递归搜索文件</h2><p>在多级目录中对文本进行递归搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &quot;text&quot; . -r -n</span><br><span class="line"># .表示当前目录。</span><br></pre></td></tr></table></figure>
<p>忽略匹配样式中的字符大小写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello world&quot; | grep -i &quot;HELLO&quot;</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>选项  <strong>-e</strong>  制动多个匹配样式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -o</span><br><span class="line">is</span><br><span class="line">line</span><br><span class="line"></span><br><span class="line">#也可以使用 **-f** 选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。</span><br><span class="line">cat patfile</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"></span><br><span class="line">echo aaa bbb ccc ddd eee | grep -f patfile -o</span><br></pre></td></tr></table></figure>
<p>在grep搜索结果中包括或者排除指定文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#只在目录中所有的.php和.html文件中递归搜索字符&quot;main()&quot;</span><br><span class="line">grep &quot;main()&quot; . -r --include *.&#123;php,html&#125;</span><br><span class="line"></span><br><span class="line">#在搜索结果中排除所有README文件</span><br><span class="line">grep &quot;main()&quot; . -r --exclude &quot;README&quot;</span><br><span class="line"></span><br><span class="line">#在搜索结果中排除filelist文件列表里的文件</span><br><span class="line">grep &quot;main()&quot; . -r --exclude-from filelist</span><br></pre></td></tr></table></figure>
<p>使用0值字节后缀的grep与xargs：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试文件：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;aaa&quot;</span> &amp;gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bbb&quot;</span> &amp;gt; file2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;aaa&quot;</span> &amp;gt; file3</span><br><span class="line"></span><br><span class="line">grep <span class="string">&quot;aaa&quot;</span> file* -lZ | xargs -0 <span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。</span></span><br></pre></td></tr></table></figure>
<p>grep静默输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -q <span class="string">&quot;test&quot;</span> filename</span><br><span class="line"><span class="comment"># 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span></span><br></pre></td></tr></table></figure>
<p>打印出匹配文本之前或者之后的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示匹配某个结果之后的3行，使用 -A 选项：</span></span><br><span class="line"><span class="built_in">seq</span> 10 | grep <span class="string">&quot;5&quot;</span> -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示匹配某个结果之前的3行，使用 -B 选项：</span></span><br><span class="line"><span class="built_in">seq</span> 10 | grep <span class="string">&quot;5&quot;</span> -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示匹配某个结果的前三行和后三行，使用 -C 选项：</span></span><br><span class="line"><span class="built_in">seq</span> 10 | grep <span class="string">&quot;5&quot;</span> -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc\na\nb\nc&quot;</span> | grep a -A 1</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（37） -- egrep</title>
    <url>/2018/02/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-37/</url>
    <content><![CDATA[<p>在文件内查找指定的字符串</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>egrep命令</strong> 用于在文件内查找指定的字符串。egrep执行效果与<code>grep -E</code>相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。egrep是用extended regular expression语法来解读的，而grep则用basic regular expression 语法解读，extended regular expression比basic regular expression的表达更规范。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egrep (选项) (查找模式) (文件名1，文件名2，……)</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>显示文件中符合条件的字符。例如，查找当前目录下所有文件中包含字符串”Linux”的文件，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egrep Linux *</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#以下五行为 testfile 中包含Linux字符的行</span><br><span class="line">testfile:hello Linux!</span><br><span class="line">testfile:Linux is a free Unix-type operating system.</span><br><span class="line">testfile:This is a Linux testfile!</span><br><span class="line">testfile:Linux</span><br><span class="line">testfile:Linux</span><br><span class="line"></span><br><span class="line">#以下两行为testfile1中含Linux字符的行</span><br><span class="line">testfile1:helLinux!</span><br><span class="line">testfile1:This a Linux testfile!</span><br><span class="line"></span><br><span class="line">#以下两行为 testfile_2 中包含Linux字符的行</span><br><span class="line">testfile_2:Linux is a free unix-type opterating system</span><br><span class="line">testfile_2:Linux test</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（38） -- fgrep</title>
    <url>/2018/02/06/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-38/</url>
    <content><![CDATA[<p>为文件搜索文字字符串</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>fgrep命令</strong> 是用来搜索 file 参数指定的输入文件（缺省为标准输入）中的匹配模式的行。fgrep 命令特别搜索 Pattern 参数，它们是固定的字符串。如果在 File 参数中指定一个以上的文件 fgrep 命令将显示包含匹配行的文件。</p>
<p>fgrep 命令于 grep 和 egrep 命令不同，因为它搜索字符串而不是搜索匹配表达式的模式。fgrep 命令使用快速的压缩算法。<code>$, *, [, |, (, )</code>和<code>\</code>等字符串被 fgrep 命令按字面意思解释。这些字符并不解释为正则表达式，但它们在 grep 和 egrep 命令中解释为正则表达式。因为这些字符对于 shell 有特定的含义，完整的字符串应该加上单引号<code>‘ ... ’</code>。. 如果没有指定文件， fgrep 命令假定标准输入。一般，找到的每行都复制到标准输出中去。如果不止一个输入文件，则在找到的每行前打印文件名。</p>
<ol>
<li>fgrep 命令和带 -F 标志的 grep命令是一样的但出错和用法消息不同-s 标志功能也不同。</li>
<li>每行限制在 2048 个字节。</li>
<li>段落（-p 标志下）目前限制在5000个字符的长度。</li>
<li>不要在特定的文件中运行 grep 命令，因为会产生不可预料的结果。</li>
<li>输入行不能包含空字符。</li>
<li>输入文件应该以换行字符结尾。</li>
<li>虽然可以同时指定很多标志，但某些标志会覆盖其余的标志。例如，如果同时指定 -l 和 -n ，只有文件名写入到标准输出中去。</li>
</ol>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fgrep (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b：在找到的每行之前添加行所在的块编号。使用此标志有助于按照上下文查找磁盘块号码。-b 标志不能用于标准输入或者管道输入。</span><br><span class="line">-c：仅显示匹配行的计数。</span><br><span class="line">-e 模式：指定模式。这个工作模式很简单，但当此模式以 a-(减号) 开头时却是很有用的。</span><br><span class="line">-f StringFile：指定包含字符串的文件。</span><br><span class="line">-h：当多个文件被处理时隐藏文件名。</span><br><span class="line">-i：当进行比较时忽略字母的大小写。</span><br><span class="line">-l：只列出包含匹配行的文件名（一次）。文件名之间用换行符分隔。</span><br><span class="line">n：将文件中每行的相对行号置于行前。</span><br><span class="line">-pSeparator：显示包含匹配行的整个段落。段落之间将按照Separator参数指定的段落分隔符加以分隔，这些分隔符是与搜索模式有着相同格式的模式。包含段落分隔符的行将仅用作分隔符；它们不会被包含在输出中。缺省的段落分隔符是空白行。</span><br><span class="line">-q：禁止所有写入到标准输出的操作，不管是否为匹配行。如果选中输入行，以 0 状态退出。</span><br><span class="line">-s：仅显示出错消息。这在检查状态时很有用。</span><br><span class="line">-v：显示除了匹配特定模式的行以外的所有行。</span><br><span class="line">-w：执行单词搜索。</span><br><span class="line">-x：显示匹配模式的行，要求无额外的字符。</span><br><span class="line">-y：当进行比较时忽略字符的大小写。</span><br></pre></td></tr></table></figure>
<p>此命令返回以下出口值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0    找到匹配项。</span><br><span class="line">1    未找到匹配项。</span><br><span class="line">&amp;gt;1   发现语法错误，或者文件不可访问（即使找到了匹配项）。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> <strong>搜索几个文件中的一个简单字符串：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fgrep strcpy *.c</span><br></pre></td></tr></table></figure>
<p>在当前目录下所有以 .c 字符串结尾的文件中搜索字符串 strcpy。</p>
<p> <strong>计数匹配某模式的行数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fgrep -c 『&#123;』pgm.cfgrep -c 『&#125;』pgm.c</span><br></pre></td></tr></table></figure>
<p>显示在 pgm.c 中包含左括号和右括号的行的数目。</p>
<p>如果在您的 C 程序中一行中没有包含多于一个 { (左括号) 或者 } (右括号)，并且括号正确匹配，那么这两个数字将是一样的。如果这两个数字不一样，您可以将包含括号的行按照他们在文件中的位置顺序显示出来，使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egrep &#123;\|&#125; pgm.c</span><br></pre></td></tr></table></figure>
<p> <strong>显示包含某模式的文件名：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fgrep -l strcpy *.c</span><br></pre></td></tr></table></figure>
<p>搜索当前目录下以 .c 结尾的文件，然后显示包含 strcpy 字符串的文件名。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（39） -- find</title>
    <url>/2018/02/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-39/</url>
    <content><![CDATA[<p>在指定目录下查找文件</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>find命令</strong> 用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-amin&amp;lt;分钟&amp;gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；</span><br><span class="line">-anewer&amp;lt;参考文件或目录&amp;gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；</span><br><span class="line">-atime&amp;lt;24小时数&amp;gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；</span><br><span class="line">-cmin&amp;lt;分钟&amp;gt;：查找在指定时间之时被更改过的文件或目录；</span><br><span class="line">-cnewer&amp;lt;参考文件或目录&amp;gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</span><br><span class="line">-ctime&amp;lt;24小时数&amp;gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；</span><br><span class="line">-daystart：从本日开始计算时间；</span><br><span class="line">-depth：从指定目录下最深层的子目录开始查找；</span><br><span class="line">-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；</span><br><span class="line">-exec&amp;lt;执行指令&amp;gt;：假设find指令的回传值为True，就执行该指令；</span><br><span class="line">-false：将find指令的回传值皆设为False；</span><br><span class="line">-fls&amp;lt;列表文件&amp;gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；</span><br><span class="line">-follow：排除符号连接；</span><br><span class="line">-fprint&amp;lt;列表文件&amp;gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">-fprint0&amp;lt;列表文件&amp;gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">-fprintf&amp;lt;列表文件&amp;gt;&amp;lt;输出格式&amp;gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">-fstype&amp;lt;文件系统类型&amp;gt;：只寻找该文件系统类型下的文件或目录；</span><br><span class="line">-gid&amp;lt;群组识别码&amp;gt;：查找符合指定之群组识别码的文件或目录；</span><br><span class="line">-group&amp;lt;群组名称&amp;gt;：查找符合指定之群组名称的文件或目录；</span><br><span class="line">-help或——help：在线帮助；</span><br><span class="line">-ilname&amp;lt;范本样式&amp;gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；</span><br><span class="line">-iname&amp;lt;范本样式&amp;gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；</span><br><span class="line">-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；&lt;/inode编号&gt;</span><br><span class="line">-ipath&amp;lt;范本样式&amp;gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；</span><br><span class="line">-iregex&amp;lt;范本样式&amp;gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；</span><br><span class="line">-links&amp;lt;连接数目&amp;gt;：查找符合指定的硬连接数目的文件或目录；</span><br><span class="line">-iname&amp;lt;范本样式&amp;gt;：指定字符串作为寻找符号连接的范本样式；</span><br><span class="line">-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；</span><br><span class="line">-maxdepth&amp;lt;目录层级&amp;gt;：设置最大目录层级；</span><br><span class="line">-mindepth&amp;lt;目录层级&amp;gt;：设置最小目录层级；</span><br><span class="line">-mmin&amp;lt;分钟&amp;gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；</span><br><span class="line">-mount：此参数的效果和指定“-xdev”相同；</span><br><span class="line">-mtime&amp;lt;24小时数&amp;gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；</span><br><span class="line">-name&amp;lt;范本样式&amp;gt;：指定字符串作为寻找文件或目录的范本样式；</span><br><span class="line">-newer&amp;lt;参考文件或目录&amp;gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</span><br><span class="line">-nogroup：找出不属于本地主机群组识别码的文件或目录；</span><br><span class="line">-noleaf：不去考虑目录至少需拥有两个硬连接存在；</span><br><span class="line">-nouser：找出不属于本地主机用户识别码的文件或目录；</span><br><span class="line">-ok&amp;lt;执行指令&amp;gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；</span><br><span class="line">-path&amp;lt;范本样式&amp;gt;：指定字符串作为寻找目录的范本样式；</span><br><span class="line">-perm&amp;lt;权限数值&amp;gt;：查找符合指定的权限数值的文件或目录；</span><br><span class="line">-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；</span><br><span class="line">-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；</span><br><span class="line">-printf&amp;lt;输出格式&amp;gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；</span><br><span class="line">-prune：不寻找字符串作为寻找文件或目录的范本样式;</span><br><span class="line">-regex&amp;lt;范本样式&amp;gt;：指定字符串作为寻找文件或目录的范本样式；</span><br><span class="line">-size&amp;lt;文件大小&amp;gt;：查找符合指定的文件大小的文件；</span><br><span class="line">-true：将find指令的回传值皆设为True；</span><br><span class="line">-typ&amp;lt;文件类型&amp;gt;：只寻找符合指定的文件类型的文件；</span><br><span class="line">-uid&amp;lt;用户识别码&amp;gt;：查找符合指定的用户识别码的文件或目录；</span><br><span class="line">-used&amp;lt;日数&amp;gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；</span><br><span class="line">-user&amp;lt;拥有者名称&amp;gt;：查找符和指定的拥有者名称的文件或目录；</span><br><span class="line">-version或——version：显示版本信息；</span><br><span class="line">-xdev：将范围局限在先行的文件系统中；</span><br><span class="line">-xtype&amp;lt;文件类型&amp;gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>起始目录：查找文件的起始目录。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前目录搜索所有文件，文件内容 包含 “140.206.111.111” 的内容</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*&quot;</span> | xargs grep <span class="string">&quot;140.206.111.111&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="根据文件或者正则表达式进行匹配"><a href="#根据文件或者正则表达式进行匹配" class="headerlink" title="根据文件或者正则表达式进行匹配"></a>根据文件或者正则表达式进行匹配</h3><p>列出当前目录及子目录下所有文件和文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find .</span><br></pre></td></tr></table></figure>
<p>在<code>/home</code>目录下查找以.txt结尾的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>
<p>同上，但忽略大小写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home -iname &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>
<p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br></pre></td></tr></table></figure>
<p>匹配文件路径或者文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure>
<p>基于正则表达式匹配文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>
<p>同上，但忽略大小写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>
<h3 id="否定参数"><a href="#否定参数" class="headerlink" title="否定参数"></a>否定参数</h3><p>找出&#x2F;home下不是以.txt结尾的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>
<h4 id="根据文件类型进行搜索"><a href="#根据文件类型进行搜索" class="headerlink" title="根据文件类型进行搜索"></a>根据文件类型进行搜索</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type 类型参数</span><br></pre></td></tr></table></figure>
<p>类型参数列表：</p>
<ul>
<li><strong>f</strong>  普通文件</li>
<li><strong>l</strong>  符号连接</li>
<li><strong>d</strong>  目录</li>
<li><strong>c</strong>  字符设备</li>
<li><strong>b</strong>  块设备</li>
<li><strong>s</strong>  套接字</li>
<li><strong>p</strong>  Fifo</li>
</ul>
<h3 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h3><p>向下最大深度限制为3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -maxdepth 3 -type f</span><br></pre></td></tr></table></figure>
<p>搜索出深度距离当前目录至少2个子目录的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -mindepth 2 -type f</span><br></pre></td></tr></table></figure>
<h3 id="根据文件时间戳进行搜索"><a href="#根据文件时间戳进行搜索" class="headerlink" title="根据文件时间戳进行搜索"></a>根据文件时间戳进行搜索</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f 时间戳</span><br></pre></td></tr></table></figure>
<p>UNIX&#x2F;Linux文件系统每个文件都有三种时间戳：</p>
<ul>
<li><strong>访问时间</strong> （-atime&#x2F;天，-amin&#x2F;分钟）：用户最近一次访问时间。</li>
<li><strong>修改时间</strong> （-mtime&#x2F;天，-mmin&#x2F;分钟）：文件最后一次修改时间。</li>
<li><strong>变化时间</strong> （-ctime&#x2F;天，-cmin&#x2F;分钟）：文件数据元（例如权限等）最后一次修改时间。</li>
</ul>
<p>搜索最近七天内被访问过的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -atime -7</span><br></pre></td></tr></table></figure>
<p>搜索恰好在七天前被访问过的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -atime 7</span><br></pre></td></tr></table></figure>
<p>搜索超过七天内被访问过的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -atime +7</span><br></pre></td></tr></table></figure>
<p>搜索访问时间超过10分钟的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -amin +10</span><br></pre></td></tr></table></figure>
<p>找出比file.log修改时间更长的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -newer file.log</span><br></pre></td></tr></table></figure>
<h3 id="根据文件大小进行匹配"><a href="#根据文件大小进行匹配" class="headerlink" title="根据文件大小进行匹配"></a>根据文件大小进行匹配</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size 文件大小单元</span><br></pre></td></tr></table></figure>
<p>文件大小单元：</p>
<ul>
<li><strong>b</strong>  —— 块（512字节）</li>
<li><strong>c</strong>  —— 字节</li>
<li><strong>w</strong>  —— 字（2字节）</li>
<li><strong>k</strong>  —— 千字节</li>
<li><strong>M</strong>  —— 兆字节</li>
<li><strong>G</strong>  —— 吉字节</li>
</ul>
<p>搜索大于10KB的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size +10k</span><br></pre></td></tr></table></figure>
<p>搜索小于10KB的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size -10k</span><br></pre></td></tr></table></figure>
<p>搜索等于10KB的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size 10k</span><br></pre></td></tr></table></figure>
<h3 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h3><p>删除当前目录下所有.txt文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -delete</span><br></pre></td></tr></table></figure>
<h3 id="根据文件权限-所有权进行匹配"><a href="#根据文件权限-所有权进行匹配" class="headerlink" title="根据文件权限&#x2F;所有权进行匹配"></a>根据文件权限&#x2F;所有权进行匹配</h3><p>当前目录下搜索出权限为777的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -perm 777</span><br></pre></td></tr></table></figure>
<p>找出当前目录下权限不是644的php文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.php&quot; ! -perm 644</span><br></pre></td></tr></table></figure>
<p>找出当前目录用户tom拥有的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -user tom</span><br></pre></td></tr></table></figure>
<p>找出当前目录用户组sunk拥有的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -group sunk</span><br></pre></td></tr></table></figure>
<h3 id="借助-exec选项与其他命令结合使用"><a href="#借助-exec选项与其他命令结合使用" class="headerlink" title="借助-exec选项与其他命令结合使用"></a>借助-exec选项与其他命令结合使用</h3><p>找出当前目录下所有root的文件，并把所有权更改为用户tom</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find .-type f -user root -exec chown tom &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>上例中， <strong>{}</strong>  用于与 <strong>-exec</strong> 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</p>
<p>找出自己家目录下所有的.txt文件并删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find $HOME/. -name &quot;*.txt&quot; -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>上例中， <strong>-ok</strong> 和 <strong>-exec</strong> 行为一样，不过它会给出提示，是否执行相应的操作。</p>
<p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&amp;gt; all.txt</span><br></pre></td></tr></table></figure>
<p>将30天前的.log文件移动到old目录中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br></pre></td></tr></table></figure>
<p>找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-exec ./text.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h3 id="搜索但跳出指定的目录"><a href="#搜索但跳出指定的目录" class="headerlink" title="搜索但跳出指定的目录"></a>搜索但跳出指定的目录</h3><p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>
<h3 id="find其他技巧收集"><a href="#find其他技巧收集" class="headerlink" title="find其他技巧收集"></a>find其他技巧收集</h3><p>要列出所有长度为零的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -empty</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（4） -- cp</title>
    <url>/2018/01/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-4/</url>
    <content><![CDATA[<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ touch test.txt</span><br><span class="line">➜  ~ cp test.txt test-copy.txt</span><br><span class="line">➜  ~ cp test.txt ~/Downloads</span><br><span class="line">➜  ~ ll ~/Downloads</span><br><span class="line">total 540M</span><br><span class="line">-rw-rw-r--  1 atompi atompi 508M Jan  1 20:38 Anaconda2-5.0.1-Linux-x86_64.sh</span><br><span class="line">drwxr-xr-x 36 atompi atompi 4.0K Jan  5 05:59 mysql-5.6.38</span><br><span class="line">-rw-rw-r--  1 atompi atompi  31M Sep 13 06:58 mysql-5.6.38.tar.gz</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Sep 21 07:20 redis-3.2.11</span><br><span class="line">-rw-rw-r--  1 atompi atompi 1.5M Sep 21 07:20 redis-3.2.11.tar.gz</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Jan  6 04:19 testdir</span><br><span class="line">-rw-rw-r--  1 atompi atompi    0 Jan  6 04:23 test.txt</span><br></pre></td></tr></table></figure>
<h2 id="显示复制的文件"><a href="#显示复制的文件" class="headerlink" title="显示复制的文件"></a>显示复制的文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ cp -v test.txt ~/Downloads</span><br><span class="line">&#x27;test.txt&#x27; -&amp;gt; &#x27;/home/atompi/Downloads/test.txt&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="覆盖时提示，以防覆盖重要文件"><a href="#覆盖时提示，以防覆盖重要文件" class="headerlink" title="覆盖时提示，以防覆盖重要文件"></a>覆盖时提示，以防覆盖重要文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ echo &quot;1&quot; &amp;gt; test.txt</span><br><span class="line">➜  ~ echo &quot;2&quot; &amp;gt; ~/Downloads/test.txt</span><br><span class="line">➜  ~ cat test.txt</span><br><span class="line">1</span><br><span class="line">➜  ~ cp -i test.txt ~/Downloads</span><br><span class="line">cp: overwrite &#x27;/home/atompi/Downloads/test.txt&#x27;? no</span><br><span class="line">➜  ~ cat ~/Downloads/test.txt</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="递归复制目录"><a href="#递归复制目录" class="headerlink" title="递归复制目录"></a>递归复制目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ cp testdir-home ~/Downloads/testdir-Downloads</span><br><span class="line">cp: omitting directory &#x27;testdir-home&#x27;</span><br><span class="line">➜  ~ cp -r testdir-home ~/Downloads/testdir-Downloads</span><br><span class="line">➜  ~ ll ~/Downloads/testdir-Downloads</span><br><span class="line">total 4.0K</span><br><span class="line">drwxrwxr-x 2 atompi atompi 4.0K Jan  6 04:28 testdir-home</span><br><span class="line"></span><br><span class="line">➜  ~ mkdir testdir-home/testdir-home-2</span><br><span class="line">➜  ~ cp -R testdir-home ~/Downloads/testdir/</span><br><span class="line">➜  ~ ll Downloads/testdir</span><br><span class="line">total 8.0K</span><br><span class="line">drwxrwxr-x 3 atompi atompi 4.0K Jan  6 04:19 testdir1</span><br><span class="line">drwxrwxr-x 3 atompi atompi 4.0K Jan  6 04:31 testdir-home</span><br><span class="line">➜  ~ ll Downloads/testdir/testdir-home</span><br><span class="line">total 4.0K</span><br><span class="line">drwxrwxr-x 2 atompi atompi 4.0K Jan  6 04:31 testdir-home-2</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（40） -- history</title>
    <url>/2018/02/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-40/</url>
    <content><![CDATA[<p>用于显示历史命令</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>history命令</strong> 用于显示指定数目的指令命令，读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。</p>
<p>该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号<code>!</code>执行指定序号的历史命令。例如，要执行第2个历史命令，则输入<code>!2</code>。</p>
<p>历史命令是被保存在内存中的，当退出或者登录shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量<code>HISTSIZE</code>进行控制。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c：清空当前历史命令；</span><br><span class="line">-a：将历史命令缓冲区中命令写入历史命令文件中；</span><br><span class="line">-r：将历史命令文件中的命令读入当前历史命令缓冲区；</span><br><span class="line">-w：将当前历史命令缓冲区命令写入历史命令文件中。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>n：打印最近的n条历史命令。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>使用history命令显示最近使用的10条历史命令，输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# history 10</span><br><span class="line">   92  ls</span><br><span class="line">   93  cd ..</span><br><span class="line">   94  ls</span><br><span class="line">   95  exit</span><br><span class="line">   96  ls -a</span><br><span class="line">   97  cd .ssh/</span><br><span class="line">   98  ls</span><br><span class="line">   99  cat known_hosts</span><br><span class="line">  100  exit</span><br><span class="line">  101  history 10</span><br></pre></td></tr></table></figure>
<p>列出最近3条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# history 3</span><br><span class="line">   15  2017-08-26 11:44:35  root history 3</span><br><span class="line">   16  2017-08-26 11:44:37  root history n</span><br><span class="line">   17  2017-08-26 11:44:40  root history 3</span><br></pre></td></tr></table></figure>
<p>清空历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# history -c</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（41） -- ps</title>
    <url>/2018/02/09/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-41/</url>
    <content><![CDATA[<p>报告当前系统的进程状态</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>ps命令</strong> 用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps (选项)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a：显示所有终端机下执行的程序，除了阶段作业领导者之外。</span><br><span class="line">a：显示现行终端机下的所有程序，包括其他用户的程序。</span><br><span class="line">-A：显示所有程序。</span><br><span class="line">-c：显示CLS和PRI栏位。</span><br><span class="line">c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。</span><br><span class="line">-C&amp;lt;指令名称&amp;gt;：指定执行指令的名称，并列出该指令的程序的状况。</span><br><span class="line">-d：显示所有程序，但不包括阶段作业领导者的程序。</span><br><span class="line">-e：此选项的效果和指定&quot;A&quot;选项相同。</span><br><span class="line">e：列出程序时，显示每个程序所使用的环境变量。</span><br><span class="line">-f：显示UID,PPIP,C与STIME栏位。</span><br><span class="line">f：用ASCII字符显示树状结构，表达程序间的相互关系。</span><br><span class="line">-g&amp;lt;群组名称&amp;gt;：此选项的效果和指定&quot;-G&quot;选项相同，当亦能使用阶段作业领导者的名称来指定。</span><br><span class="line">g：显示现行终端机下的所有程序，包括群组领导者的程序。</span><br><span class="line">-G&amp;lt;群组识别码&amp;gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。</span><br><span class="line">h：不显示标题列。</span><br><span class="line">-H：显示树状结构，表示程序间的相互关系。</span><br><span class="line">-j或j：采用工作控制的格式显示程序状况。</span><br><span class="line">-l或l：采用详细的格式来显示程序状况。</span><br><span class="line">L：列出栏位的相关信息。</span><br><span class="line">-m或m：显示所有的执行绪。</span><br><span class="line">n：以数字来表示USER和WCHAN栏位。</span><br><span class="line">-N：显示所有的程序，除了执行ps指令终端机下的程序之外。</span><br><span class="line">-p&amp;lt;程序识别码&amp;gt;：指定程序识别码，并列出该程序的状况。</span><br><span class="line">p&amp;lt;程序识别码&amp;gt;：此选项的效果和指定&quot;-p&quot;选项相同，只在列表格式方面稍有差异。</span><br><span class="line">r：只列出现行终端机正在执行中的程序。</span><br><span class="line">-s&amp;lt;阶段作业&amp;gt;：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。</span><br><span class="line">s：采用程序信号的格式显示程序状况。</span><br><span class="line">S：列出程序时，包括已中断的子程序资料。</span><br><span class="line">-t&amp;lt;终端机编号&amp;gt;：指定终端机编号，并列出属于该终端机的程序的状况。</span><br><span class="line">t&amp;lt;终端机编号&amp;gt;：此选项的效果和指定&quot;-t&quot;选项相同，只在列表格式方面稍有差异。</span><br><span class="line">-T：显示现行终端机下的所有程序。</span><br><span class="line">-u&amp;lt;用户识别码&amp;gt;：此选项的效果和指定&quot;-U&quot;选项相同。</span><br><span class="line">u：以用户为主的格式来显示程序状况。</span><br><span class="line">-U&amp;lt;用户识别码&amp;gt;：列出属于该用户的程序的状况，也可使用用户名称来指定。</span><br><span class="line">U&amp;lt;用户名称&amp;gt;：列出属于该用户的程序的状况。</span><br><span class="line">v：采用虚拟内存的格式显示程序状况。</span><br><span class="line">-V或V：显示版本信息。</span><br><span class="line">-w或w：采用宽阔的格式来显示程序状况。　</span><br><span class="line">x：显示所有程序，不以终端机来区分。</span><br><span class="line">X：采用旧式的Linux i386登陆格式显示程序状况。</span><br><span class="line">-y：配合选项&quot;-l&quot;使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。</span><br><span class="line">-&amp;lt;程序识别码&amp;gt;：此选项的效果和指定&quot;p&quot;选项相同。</span><br><span class="line">--cols&amp;lt;每列字符数&amp;gt;：设置每列的最大字符数。</span><br><span class="line">--columns&amp;lt;每列字符数&amp;gt;：此选项的效果和指定&quot;--cols&quot;选项相同。</span><br><span class="line">--cumulative：此选项的效果和指定&quot;S&quot;选项相同。</span><br><span class="line">--deselect：此选项的效果和指定&quot;-N&quot;选项相同。</span><br><span class="line">--forest：此选项的效果和指定&quot;f&quot;选项相同。</span><br><span class="line">--headers：重复显示标题列。</span><br><span class="line">--help：在线帮助。</span><br><span class="line">--info：显示排错信息。</span><br><span class="line">--lines&amp;lt;显示列数&amp;gt;：设置显示画面的列数。</span><br><span class="line">--no-headers：此选项的效果和指定&quot;h&quot;选项相同，只在列表格式方面稍有差异。</span><br><span class="line">--group&amp;lt;群组名称&amp;gt;：此选项的效果和指定&quot;-G&quot;选项相同。</span><br><span class="line">--Group&amp;lt;群组识别码&amp;gt;：此选项的效果和指定&quot;-G&quot;选项相同。</span><br><span class="line">--pid&amp;lt;程序识别码&amp;gt;：此选项的效果和指定&quot;-p&quot;选项相同。</span><br><span class="line">--rows&amp;lt;显示列数&amp;gt;：此选项的效果和指定&quot;--lines&quot;选项相同。</span><br><span class="line">--sid&amp;lt;阶段作业&amp;gt;：此选项的效果和指定&quot;-s&quot;选项相同。</span><br><span class="line">--tty&amp;lt;终端机编号&amp;gt;：此选项的效果和指定&quot;-t&quot;选项相同。</span><br><span class="line">--user&amp;lt;用户名称&amp;gt;：此选项的效果和指定&quot;-U&quot;选项相同。</span><br><span class="line">--User&amp;lt;用户识别码&amp;gt;：此选项的效果和指定&quot;-U&quot;选项相同。</span><br><span class="line">--version：此选项的效果和指定&quot;-V&quot;选项相同。</span><br><span class="line">--widty&amp;lt;每列字符数&amp;gt;：此选项的效果和指定&quot;-cols&quot;选项相同。</span><br></pre></td></tr></table></figure>
<p>由于ps命令能够支持的系统类型相当的多，所以选项多的离谱！</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>按内存资源的使用量对进程进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux | sort -rnk 4</span><br></pre></td></tr></table></figure>
<p>按 CPU 资源的使用量对进程进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux | sort -nk 3</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（42） -- top</title>
    <url>/2018/02/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-42/</url>
    <content><![CDATA[<p>显示或管理执行中的程序</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>top命令</strong> 可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过top命令所提供的互动式界面，用热键可以管理。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top (选项)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b：以批处理模式操作；</span><br><span class="line">-c：显示完整的治命令；</span><br><span class="line">-d：屏幕刷新间隔时间；</span><br><span class="line">-I：忽略失效过程；</span><br><span class="line">-s：保密模式；</span><br><span class="line">-S：累积模式；</span><br><span class="line">-i&amp;lt;时间&amp;gt;：设置间隔时间；</span><br><span class="line">-u&amp;lt;用户名&amp;gt;：指定用户名；</span><br><span class="line">-p&amp;lt;进程号&amp;gt;：指定进程；</span><br><span class="line">-n&amp;lt;次数&amp;gt;：循环显示的次数。</span><br></pre></td></tr></table></figure>
<h2 id="top交互命令"><a href="#top交互命令" class="headerlink" title="top交互命令"></a>top交互命令</h2><p>在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h：显示帮助画面，给出一些简短的命令总结说明；</span><br><span class="line">k：终止一个进程；</span><br><span class="line">i：忽略闲置和僵死进程，这是一个开关式命令；</span><br><span class="line">q：退出程序；</span><br><span class="line">r：重新安排一个进程的优先级别；</span><br><span class="line">S：切换到累计模式；</span><br><span class="line">s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；</span><br><span class="line">f或者F：从当前显示中添加或者删除项目；</span><br><span class="line">o或者O：改变显示项目的顺序；</span><br><span class="line">l：切换显示平均负载和启动时间信息；</span><br><span class="line">m：切换显示内存信息；</span><br><span class="line">t：切换显示进程和CPU状态信息；</span><br><span class="line">c：切换显示命令名称和完整命令行；</span><br><span class="line">M：根据驻留内存大小进行排序；</span><br><span class="line">P：根据CPU使用百分比大小进行排序；</span><br><span class="line">T：根据时间/累计时间进行排序；</span><br><span class="line">w：将当前设置写入~/.toprc文件中。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top - 09:44:56 up 16 days, 21:23,  1 user,  load average: 9.59, 4.75, 1.92</span><br><span class="line">Tasks: 145 total,   2 running, 143 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s): 99.8%us,  0.1%sy,  0.0%ni,  0.2%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:   4147888k total,  2493092k used,  1654796k free,   158188k buffers</span><br><span class="line">Swap:  5144568k total,       56k used,  5144512k free,  2013180k cached</span><br></pre></td></tr></table></figure>
<p> <strong>解释：</strong></p>
<ul>
<li>top - 09:44:56[当前系统时间],</li>
<li>16 days[系统已经运行了16天],</li>
<li>1 user[个用户当前登录],</li>
<li>load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度]</li>
<li>Tasks: 145 total[总进程数],</li>
<li>2 running[正在运行的进程数],</li>
<li>143 sleeping[睡眠的进程数],</li>
<li>0 stopped[停止的进程数],</li>
<li>0 zombie[冻结进程数],</li>
<li>Cpu(s): 99.8%us[用户空间占用CPU百分比],</li>
<li>0.1%sy[内核空间占用CPU百分比],</li>
<li>0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比],</li>
<li>0.2%id[空闲CPU百分比], 0.0%wa[等待输入输出的CPU时间百分比],</li>
<li>0.0%hi[],</li>
<li>0.0%st[],</li>
<li>Mem: 4147888k total[物理内存总量],</li>
<li>2493092k used[使用的物理内存总量],</li>
<li>1654796k free[空闲内存总量],</li>
<li>158188k buffers[用作内核缓存的内存量]</li>
<li>Swap:  5144568k total[交换区总量],</li>
<li>56k used[使用的交换区总量],</li>
<li>5144512k free[空闲交换区总量],</li>
<li>2013180k cached[缓冲的交换区总量],</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（43） -- curl</title>
    <url>/2018/02/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-43/</url>
    <content><![CDATA[<p>利用URL规则在命令行下工作的文件传输工具</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>curl命令</strong> 是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>|选项|说明<br>|——<br>|-a&#x2F;–append|上传文件时，附加到目标文件<br>|-A&#x2F;–user-agent|设置用户代理发送给服务器<br>|-anyauth|可以使用“任何”身份验证方法<br>|-b&#x2F;–cookie|cookie字符串或文件读取位置<br>|–basic|使用HTTP基本验证<br>|-B&#x2F;–use-ascii|使用ASCII &#x2F;文本传输<br>|-c&#x2F;–cookie-jar|操作结束后把cookie写入到这个文件中<br>|-C&#x2F;–continue-at|断点续传<br>|-d&#x2F;–data|HTTP POST方式传送数据<br>|–data-ascii|以ascii的方式post数据<br>|–data-binary|以二进制的方式post数据<br>|–negotiate|使用HTTP身份验证<br>|–digest|使用数字身份验证<br>|–disable-eprt|禁止使用EPRT或LPRT<br>|–disable-epsv|禁止使用EPSV<br>|-D&#x2F;–dump-header|把header信息写入到该文件中<br>|–egd-file|为随机数据(SSL)设置EGD socket路径<br>|–tcp-nodelay|使用TCP_NODELAY选项<br>|-e&#x2F;–referer|来源网址<br>|-E&#x2F;–cert|客户端证书文件和密码 (SSL)<br>|–cert-type|证书文件类型 (DER&#x2F;PEM&#x2F;ENG) (SSL)<br>|–key|私钥文件名 (SSL)<br>|–key-type|私钥文件类型 (DER&#x2F;PEM&#x2F;ENG) (SSL)<br>|–pass|私钥密码 (SSL)<br>|–engine|加密引擎使用 (SSL). “–engine list” for list<br>|–cacert|CA证书 (SSL)<br>|–capath|CA目录 (made using c_rehash) to verify peer against (SSL)<br>|–ciphers|SSL密码<br>|–compressed|要求返回是压缩的形势 (using deflate or gzip)<br>|–connect-timeout|设置最大请求时间<br>|–create-dirs|建立本地目录的目录层次结构<br>|–crlf|上传是把LF转变成CRLF<br>|-f&#x2F;–fail|连接失败时不显示http错误<br>|–ftp-create-dirs|如果远程目录不存在，创建远程目录<br>|–ftp-method [multicwd&#x2F;nocwd&#x2F;singlecwd]|控制CWD的使用<br>|–ftp-pasv|使用 PASV&#x2F;EPSV 代替端口<br>|–ftp-skip-pasv-ip|使用PASV的时候,忽略该IP地址<br>|–ftp-ssl|尝试用 SSL&#x2F;TLS 来进行ftp数据传输<br>|–ftp-ssl-reqd|要求用 SSL&#x2F;TLS 来进行ftp数据传输<br>|-F&#x2F;–form|模拟http表单提交数据<br>|–form-string|模拟http表单提交数据<br>|-g&#x2F;–globoff|禁用网址序列和范围使用{}和[]<br>|-G&#x2F;–get|以get的方式来发送数据<br>|-H&#x2F;–header|自定义头信息传递给服务器<br>|–ignore-content-length|忽略的HTTP头信息的长度<br>|-i&#x2F;–include|输出时包括protocol头信息<br>|-I&#x2F;–head|只显示请求头信息<br>|-j&#x2F;–junk-session-cookies|读取文件进忽略session cookie<br>|–interface|使用指定网络接口&#x2F;地址<br>|–krb4|使用指定安全级别的krb4<br>|-k&#x2F;–insecure|允许不使用证书到SSL站点<br>|-K&#x2F;–config|指定的配置文件读取<br>|-l&#x2F;–list-only|列出ftp目录下的文件名称<br>|–limit-rate|设置传输速度<br>|–local-port|强制使用本地端口号<br>|-m&#x2F;–max-time|设置最大传输时间<br>|–max-redirs|设置最大读取的目录数<br>|–max-filesize|设置最大下载的文件总量<br>|-M&#x2F;–manual|显示全手动<br>|-n&#x2F;–netrc|从netrc文件中读取用户名和密码<br>|–netrc-optional|使用 .netrc 或者 URL来覆盖-n<br>|–ntlm|使用 HTTP NTLM 身份验证<br>|-N&#x2F;–no-buffer|禁用缓冲输出<br>|-o&#x2F;–output|把输出写到该文件中<br>|-O&#x2F;–remote-name|把输出写到该文件中，保留远程文件的文件名<br>|-p&#x2F;–proxytunnel|使用HTTP代理<br>|–proxy-anyauth|选择任一代理身份验证方法<br>|–proxy-basic|在代理上使用基本身份验证<br>|–proxy-digest|在代理上使用数字身份验证<br>|–proxy-ntlm|在代理上使用ntlm身份验证<br>|-P&#x2F;–ftp-port|使用端口地址，而不是使用PASV<br>|-q|作为第一个参数，关闭 .curlrc<br>|-Q&#x2F;–quote|文件传输前，发送命令到服务器<br>|-r&#x2F;–range|检索来自HTTP&#x2F;1.1或FTP服务器字节范围<br>|–range-file|读取（SSL）的随机文件<br>|-R&#x2F;–remote-time|在本地生成文件时，保留远程文件时间<br>|–retry|传输出现问题时，重试的次数<br>|–retry-delay|传输出现问题时，设置重试间隔时间<br>|–retry-max-time|传输出现问题时，设置最大重试时间<br>|-s&#x2F;–silent|静默模式。不输出任何东西<br>|-S&#x2F;–show-error|显示错误<br>|–socks4|用socks4代理给定主机和端口<br>|–socks5|用socks5代理给定主机和端口<br>|–stderr|<br>|-t&#x2F;–telnet-option|Telnet选项设置<br>|–trace|对指定文件进行debug<br>|–trace-ascii|Like –跟踪但没有hex输出<br>|–trace-time|跟踪&#x2F;详细输出时，添加时间戳<br>|-T&#x2F;–upload-file|上传文件<br>|–url|Spet URL to work with<br>|-u&#x2F;–user|设置服务器的用户和密码<br>|-U&#x2F;–proxy-user|设置代理用户名和密码<br>|-w&#x2F;–write-out [format]|什么输出完成后<br>|-x&#x2F;–proxy|在给定的端口上使用HTTP代理<br>|-X&#x2F;–request|指定什么命令<br>|-y&#x2F;–speed-time|放弃限速所要的时间，默认为30<br>|-Y&#x2F;–speed-limit|停止传输速度的限制，速度时间</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>文件下载</strong></p>
<p>curl命令可以用来执行下载、发送各种HTTP请求，指定HTTP头部等操作。如果系统没有curl可以使用<code>yum install curl</code>安装，也可以下载安装。curl是将下载文件输出到stdout，将进度信息输出到stderr，不显示进度信息使用<code>--silent</code>选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl URL --silent</span><br></pre></td></tr></table></figure>
<p>这条命令是将下载文件输出到终端，所有下载的数据都被写入到stdout。</p>
<p>使用选项<code>-O</code>将下载的数据写入到文件，必须使用文件的绝对地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://man.linuxde.net/text.iso --silent -O</span><br></pre></td></tr></table></figure>
<p>选项<code>-o</code>将下载数据写入到指定名称的文件中，并使用<code>--progress</code>显示进度条：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://man.linuxde.net/test.iso -o filename.iso --progress</span><br><span class="line">######################################### 100.0%</span><br></pre></td></tr></table></figure>
<p><strong>断点续传</strong></p>
<p>curl能够从特定的文件偏移处继续下载，它可以通过指定一个便宜量来下载部分文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl URL/File -C 偏移量</span><br><span class="line"></span><br><span class="line">#偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -：</span><br><span class="line">curl -C -URL</span><br></pre></td></tr></table></figure>
<p><strong>使用curl设置参照页字符串</strong></p>
<p>参照页是位于HTTP头部中的一个字符串，用来表示用户是从哪个页面到达当前页面的，如果用户点击网页A中的某个连接，那么用户就会跳转到B网页，网页B头部的参照页字符串就包含网页A的URL。</p>
<p>使用<code>--referer</code>选项指定参照页字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --referer http://www.google.com http://man.linuxde.net</span><br></pre></td></tr></table></figure>
<p><strong>用curl设置cookies</strong></p>
<p>使用<code>--cookie &quot;COKKIES&quot;</code>选项来指定cookie，多个cookie使用分号分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://man.linuxde.net --cookie &quot;user=root;pass=123456&quot;</span><br></pre></td></tr></table></figure>
<p>将cookie另存为一个文件，使用<code>--cookie-jar</code>选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl URL --cookie-jar cookie_file</span><br></pre></td></tr></table></figure>
<p><strong>用curl设置用户代理字符串</strong></p>
<p>有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用<code>--user-agent</code>或者<code>-A</code>选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl URL --user-agent &quot;Mozilla/5.0&quot;</span><br><span class="line">curl URL -A &quot;Mozilla/5.0&quot;</span><br></pre></td></tr></table></figure>
<p>其他HTTP头部信息也可以使用curl来发送，使用<code>-H</code>“头部信息” 传递多个头部信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Host:man.linuxde.net&quot; -H &quot;accept-language:zh-cn&quot; URL</span><br></pre></td></tr></table></figure>
<p><strong>curl的带宽控制和下载配额</strong></p>
<p>使用<code>--limit-rate</code>限制curl的下载速度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl URL --limit-rate 50k</span><br></pre></td></tr></table></figure>
<p>命令中用k（千字节）和m（兆字节）指定下载速度限制。</p>
<p>使用<code>--max-filesize</code>指定可下载的最大文件大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl URL --max-filesize bytes</span><br></pre></td></tr></table></figure>
<p>如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。</p>
<p><strong>用curl进行认证</strong></p>
<p>使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -u user:pwd http://man.linuxde.net</span><br><span class="line">curl -u user http://man.linuxde.net</span><br></pre></td></tr></table></figure>
<p><strong>只打印响应头部信息</strong></p>
<p>通过<code>-I</code>或者<code>-head</code>可以只打印出HTTP头部信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost text]# curl -I http://man.linuxde.net</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.2.5</span><br><span class="line">date: Mon, 10 Dec 2012 09:24:34 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Pingback: http://man.linuxde.net/xmlrpc.php</span><br></pre></td></tr></table></figure>
<p><strong>get请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;http://www.wangchujiang.com&quot;    # 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span><br><span class="line">curl -i &quot;http://www.wangchujiang.com&quot; # 显示全部信息</span><br><span class="line">curl -l &quot;http://www.wangchujiang.com&quot; # 只显示头部信息</span><br><span class="line">curl -v &quot;http://www.wangchujiang.com&quot; # 显示get请求全过程解析</span><br></pre></td></tr></table></figure>
<p><strong>post请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &quot;param1=value1¶m2=value2&quot; &quot;http://www.wangchujiang.com&quot;</span><br></pre></td></tr></table></figure>
<p><strong>json格式的post请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -l -H &quot;Content-type: application/json&quot; -X POST -d &#x27;&#123;&quot;phone&quot;:&quot;13521389587&quot;,&quot;password&quot;:&quot;test&quot;&#125;&#x27; http://wangchujiang.com/apis/users.json</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（45） -- bind</title>
    <url>/2018/02/13/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-45/</url>
    <content><![CDATA[<p>显示或设置键盘按键与其相关的功能</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>bind命令</strong> 用于显示和设置命令行的键盘序列绑定功能。通过这一命令，可以提高命令行中操作效率。您可以利用bind命令了解有哪些按键组合与其功能，也可以自行指定要用哪些按键组合。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind (选项)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d：显示按键配置的内容；</span><br><span class="line">-f&amp;lt;按键配置文件&amp;gt;：载入指定的按键配置文件；</span><br><span class="line">-l：列出所有的功能；</span><br><span class="line">-m&amp;lt;按键配置&amp;gt;：指定按键配置；</span><br><span class="line">-q&amp;lt;功能&amp;gt;：显示指定功能的按键；</span><br><span class="line">-v：列出目前的按键配置与其功能。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind -x &#x27;&quot;\C-l&quot;:ls -l&#x27;    #直接按 CTRL+L 就列出目录</span><br></pre></td></tr></table></figure>
<p>其中keyseq可以使用<code>showkey -a</code>命令来获取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# showkey -a</span><br><span class="line"></span><br><span class="line">Press any keys - Ctrl-D will terminate this program</span><br><span class="line"></span><br><span class="line">^[[A     27 0033 0x1b  上</span><br><span class="line">         91 0133 0x5b</span><br><span class="line">         65 0101 0x41</span><br><span class="line">^[[B     27 0033 0x1b  下</span><br><span class="line">         91 0133 0x5b</span><br><span class="line">         66 0102 0x42</span><br><span class="line">^[[D     27 0033 0x1b  左</span><br><span class="line">         91 0133 0x5b</span><br><span class="line">         68 0104 0x44</span><br><span class="line">^[[C     27 0033 0x1b 右</span><br><span class="line">         91 0133 0x5b</span><br><span class="line">         67 0103 0x43</span><br><span class="line">         32 0040 0x20</span><br><span class="line">^M       13 0015 0x0d 字母M</span><br><span class="line">^C        3 0003 0x03 Ctrl-C</span><br><span class="line">^D        4 0004 0x04 Ctrl-D 退出</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（46） -- unset</title>
    <url>/2018/02/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-46/</url>
    <content><![CDATA[<p>删除指定的shell变量或函数</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>unset命令</strong> 用于删除已定义的shell变量（包括环境变量）和shell函数。unset命令不能够删除具有只读属性的shell变量和环境变量。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f：仅删除函数；</span><br><span class="line">-v：仅删除变量。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>shell变量或函数：指定要删除的shell变量或shell函数。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>使用unset命令将前面所创建的环境变量mylove及其对应的值进行删除，输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset -v mylove         #删除指定的环境变量</span><br></pre></td></tr></table></figure>
<p>执行以上命令后，系统将删除指定的环境变量。用户可以使用env命令和grep命令对其进行查询。已经删除的环境变量再次使用指令查询时，将出现查询不到指定环境变量的输出信息。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（44） -- lsof</title>
    <url>/2018/02/12/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-44/</url>
    <content><![CDATA[<p>显示Linux系统当前已打开的所有文件列表</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>lsof命令</strong> 用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回&#x2F;恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。</p>
<p>在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof (选项)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a：列出打开文件存在的进程；</span><br><span class="line">-c&amp;lt;进程名&amp;gt;：列出指定进程所打开的文件；</span><br><span class="line">-g：列出GID号进程详情；</span><br><span class="line">-d&amp;lt;文件号&amp;gt;：列出占用该文件号的进程；</span><br><span class="line">+d&amp;lt;目录&amp;gt;：列出目录下被打开的文件；</span><br><span class="line">+D&amp;lt;目录&amp;gt;：递归列出目录下被打开的文件；</span><br><span class="line">-n&amp;lt;目录&amp;gt;：列出使用NFS的文件；</span><br><span class="line">-i&amp;lt;条件&amp;gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）</span><br><span class="line">-p&amp;lt;进程号&amp;gt;：列出指定进程号所打开的文件；</span><br><span class="line">-u：列出UID号进程详情；</span><br><span class="line">-h：显示帮助信息；</span><br><span class="line">-v：显示版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof</span><br><span class="line">command     PID USER   FD      type             DEVICE     SIZE       NODE NAME</span><br><span class="line">init          1 root  cwd       DIR                8,2     4096          2 /</span><br><span class="line">init          1 root  rtd       DIR                8,2     4096          2 /</span><br><span class="line">init          1 root  txt       REG                8,2    43496    6121706 /sbin/init</span><br><span class="line">init          1 root  mem       REG                8,2   143600    7823908 /lib64/ld-2.5.so</span><br><span class="line">init          1 root  mem       REG                8,2  1722304    7823915 /lib64/libc-2.5.so</span><br><span class="line">init          1 root  mem       REG                8,2    23360    7823919 /lib64/libdl-2.5.so</span><br><span class="line">init          1 root  mem       REG                8,2    95464    7824116 /lib64/libselinux.so.1</span><br><span class="line">init          1 root  mem       REG                8,2   247496    7823947 /lib64/libsepol.so.1</span><br><span class="line">init          1 root   10u     FIFO               0,17                1233 /dev/initctl</span><br><span class="line">migration     2 root  cwd       DIR                8,2     4096          2 /</span><br><span class="line">migration     2 root  rtd       DIR                8,2     4096          2 /</span><br><span class="line">migration     2 root  txt   unknown                                        /proc/2/exe</span><br><span class="line">ksoftirqd     3 root  cwd       DIR                8,2     4096          2 /</span><br><span class="line">ksoftirqd     3 root  rtd       DIR                8,2     4096          2 /</span><br><span class="line">ksoftirqd     3 root  txt   unknown                                        /proc/3/exe</span><br><span class="line">migration     4 root  cwd       DIR                8,2     4096          2 /</span><br><span class="line">migration     4 root  rtd       DIR                8,2     4096          2 /</span><br><span class="line">migration     4 root  txt   unknown                                        /proc/4/exe</span><br><span class="line">ksoftirqd     5 root  cwd       DIR                8,2     4096          2 /</span><br><span class="line">ksoftirqd     5 root  rtd       DIR                8,2     4096          2 /</span><br><span class="line">ksoftirqd     5 root  txt   unknown                                        /proc/5/exe</span><br><span class="line">events/0      6 root  cwd       DIR                8,2     4096          2 /</span><br><span class="line">events/0      6 root  rtd       DIR                8,2     4096          2 /</span><br><span class="line">events/0      6 root  txt   unknown                                        /proc/6/exe</span><br><span class="line">events/1      7 root  cwd       DIR                8,2     4096          2 /</span><br></pre></td></tr></table></figure>
<p> <strong>lsof输出各列信息的意义如下：</strong></p>
<ul>
<li>COMMAND：进程的名称</li>
<li>PID：进程标识符</li>
<li>PPID：父进程标识符（需要指定-R参数）</li>
<li>USER：进程所有者</li>
<li>PGID：进程所属组</li>
<li>FD：文件描述符，应用程序通过文件描述符识别该文件。</li>
</ul>
<p>文件描述符列表：</p>
<ol>
<li>cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</li>
<li>txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序</li>
<li>lnn：library references (AIX);</li>
<li>er：FD information error (see NAME column);</li>
<li>jld：jail directory (FreeBSD);</li>
<li>ltx：shared library text (code and data);</li>
<li>mxx ：hex memory-mapped type number xx.</li>
<li>m86：DOS Merge mapped file;</li>
<li>mem：memory-mapped file;</li>
<li>mmap：memory-mapped device;</li>
<li>pd：parent directory;</li>
<li>rtd：root directory;</li>
<li>tr：kernel trace file (OpenBSD);</li>
<li>v86  VP&#x2F;ix mapped file;</li>
<li>0：表示标准输出</li>
<li>1：表示标准输入</li>
<li>2：表示标准错误</li>
</ol>
<p>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：</p>
<ol>
<li>u：表示该文件被打开并处于读取&#x2F;写入模式。</li>
<li>r：表示该文件被打开并处于只读模式。</li>
<li>w：表示该文件被打开并处于。</li>
<li>空格：表示该文件的状态模式为unknow，且没有锁定。</li>
<li>-：表示该文件的状态模式为unknow，且被锁定。</li>
</ol>
<p>同时在文件状态模式后面，还跟着相关的锁：</p>
<ol>
<li>N：for a Solaris NFS lock of unknown type;</li>
<li>r：for read lock on part of the file;</li>
<li>R：for a read lock on the entire file;</li>
<li>w：for a write lock on part of the file;（文件的部分写锁）</li>
<li>W：for a write lock on the entire file;（整个文件的写锁）</li>
<li>u：for a read and write lock of any length;</li>
<li>U：for a lock of unknown type;</li>
<li>x：for an SCO OpenServer Xenix lock on part      of the file;</li>
<li>X：for an SCO OpenServer Xenix lock on the      entire file;</li>
<li>space：if there is no lock.</li>
</ol>
<p>文件类型：</p>
<ol>
<li>DIR：表示目录。</li>
<li>CHR：表示字符类型。</li>
<li>BLK：块设备类型。</li>
<li>UNIX： UNIX 域套接字。</li>
<li>FIFO：先进先出 (FIFO) 队列。</li>
<li>IPv4：网际协议 (IP) 套接字。</li>
<li>DEVICE：指定磁盘的名称</li>
<li>SIZE：文件的大小</li>
<li>NODE：索引节点（文件在磁盘上的标识）</li>
<li>NAME：打开文件的确切名称</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（47） -- uptime</title>
    <url>/2018/02/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-47/</url>
    <content><![CDATA[<p>查看Linux系统负载信息</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>uptime命令</strong> 能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uptime (选项)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-V：显示指令的版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>使用uptime命令查看系统负载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@LinServ-1 ~]# uptime -V    #显示uptime命令版本信息</span><br><span class="line">procps version 3.2.7</span><br><span class="line"></span><br><span class="line">[root@LinServ-1 ~]# uptime</span><br><span class="line"> 15:31:30 up 127 days,  3:00,  1 user,  load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure>
<p> <strong>显示内容说明：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15:31:30             //系统当前时间</span><br><span class="line">up 127 days,  3:00   //主机已运行时间,时间越大，说明你的机器越稳定。</span><br><span class="line">1 user               //用户连接数，是总连接数而不是用户数</span><br><span class="line">load average: 0.00, 0.00, 0.00         // 系统平均负载，统计最近1，5，15分钟的系统平均负载</span><br></pre></td></tr></table></figure>
<p>那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。</p>
<p>如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。</p>
<p>如果你的linux主机是1个双核CPU的话，当Load Average 为6的时候说明机器已经被充分使用了。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（48） -- free</title>
    <url>/2018/02/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-48/</url>
    <content><![CDATA[<p>显示内存的使用情况</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>free命令</strong> 可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free (选项)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-b <span class="comment"># 以Byte为单位显示内存使用情况；</span></span><br><span class="line">-k <span class="comment"># 以KB为单位显示内存使用情况；</span></span><br><span class="line">-m <span class="comment"># 以MB为单位显示内存使用情况；</span></span><br><span class="line">-g <span class="comment"># 以GB为单位显示内存使用情况。</span></span><br><span class="line">-o <span class="comment"># 不显示缓冲区调节列；</span></span><br><span class="line">-s&amp;lt;间隔秒数&amp;gt; <span class="comment"># 持续观察内存使用状况；</span></span><br><span class="line">-t <span class="comment"># 显示内存总和列；</span></span><br><span class="line">-V <span class="comment"># 显示版本信息。</span></span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -t    <span class="comment"># 以总和的形式显示内存的使用信息</span></span><br><span class="line">free -s 10 <span class="comment"># 周期性的查询内存使用信息，每10s 执行一次命令</span></span><br></pre></td></tr></table></figure>
<p>显示内存使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          2016       1973         42          0        163       1497</span><br><span class="line">-/+ buffers/cache:        312       1703</span><br><span class="line">Swap:         4094          0       4094</span><br></pre></td></tr></table></figure>
<p> <strong>第一部分Mem行解释：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">total：内存总数；</span><br><span class="line">used：已经使用的内存数；</span><br><span class="line">free：空闲的内存数；</span><br><span class="line">shared：当前已经废弃不用；</span><br><span class="line">buffers Buffer：缓存内存数；</span><br><span class="line">cached Page：缓存内存数。</span><br></pre></td></tr></table></figure>
<p>关系：total &#x3D; used + free</p>
<p> <strong>第二部分(-&#x2F;+ buffers&#x2F;cache)解释:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(-buffers/cache) used内存数：第一部分Mem行中的 used – buffers – cached</span><br><span class="line">(+buffers/cache) free内存数: 第一部分Mem行中的 free + buffers + cached</span><br></pre></td></tr></table></figure>
<p>可见-buffers&#x2F;cache反映的是被程序实实在在吃掉的内存，而+buffers&#x2F;cache反映的是可以挪用的内存总数。</p>
<p>第三部分是指交换分区。</p>
<p>输出结果的第四行是交换分区SWAP的，也就是我们通常所说的虚拟内存。<br/>区别：第二行(mem)的used&#x2F;free与第三行(-&#x2F;+ buffers&#x2F;cache) used&#x2F;free的区别。 这两个的区别在于使用的角度来看，第一行是从OS的角度来看，因为对于OS，buffers&#x2F;cached 都是属于被使用，所以他的可用内存是2098428KB,已用内存是30841684KB,其中包括，内核（OS）使用+Application(X, oracle,etc)使用的+buffers+cached.</p>
<p>第三行所指的是从应用程序角度来看，对于应用程序来说，buffers&#x2F;cached 是等于可用的，因为buffer&#x2F;cached是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer&#x2F;cached会很快地被回收。</p>
<p>所以从应用程序的角度来说，可用内存&#x3D;系统free memory+buffers+cached。<br/>如本机情况的可用内存为：</p>
<p>18007156&#x3D;2098428KB+4545340KB+11363424KB</p>
<p>接下来解释什么时候内存会被交换，以及按什么方交换。</p>
<p>当可用内存少于额定值的时候，就会开会进行交换。如何看额定值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/meminfo</span><br><span class="line"></span><br><span class="line">MemTotal:       16140816 kB</span><br><span class="line">MemFree:          816004 kB</span><br><span class="line">MemAvailable:    2913824 kB</span><br><span class="line">Buffers:           17912 kB</span><br><span class="line">Cached:          2239076 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">Active:         12774804 kB</span><br><span class="line">Inactive:        1594328 kB</span><br><span class="line">Active(anon):   12085544 kB</span><br><span class="line">Inactive(anon):    94572 kB</span><br><span class="line">Active(file):     689260 kB</span><br><span class="line">Inactive(file):  1499756 kB</span><br><span class="line">Unevictable:      116888 kB</span><br><span class="line">Mlocked:          116888 kB</span><br><span class="line">SwapTotal:       8191996 kB</span><br><span class="line">SwapFree:        8191996 kB</span><br><span class="line">Dirty:                56 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:      12229228 kB</span><br><span class="line">Mapped:           117136 kB</span><br><span class="line">Shmem:             58736 kB</span><br><span class="line">Slab:             395568 kB</span><br><span class="line">SReclaimable:     246700 kB</span><br><span class="line">SUnreclaim:       148868 kB</span><br><span class="line">KernelStack:       30496 kB</span><br><span class="line">PageTables:       165104 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:    16262404 kB</span><br><span class="line">Committed_AS:   27698600 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">VmallocUsed:      311072 kB</span><br><span class="line">VmallocChunk:   34350899200 kB</span><br><span class="line">HardwareCorrupted:     0 kB</span><br><span class="line">AnonHugePages:   3104768 kB</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br><span class="line">DirectMap4k:      225536 kB</span><br><span class="line">DirectMap2M:    13279232 kB</span><br><span class="line">DirectMap1G:     5242880 kB</span><br></pre></td></tr></table></figure>
<p>交换将通过三个途径来减少系统中使用的物理页面的个数：　</p>
<ol>
<li>减少缓冲与页面cache的大小，</li>
<li>将系统V类型的内存页面交换出去，　</li>
<li>换出或者丢弃页面。(Application 占用的内存页，也就是物理内存不足）。</li>
</ol>
<p>事实上，少量地使用swap是不是影响到系统性能的。</p>
<p>那buffers和cached都是缓存，两者有什么区别呢？</p>
<p>为了提高磁盘存取效率, Linux做了一些精心的设计, 除了对dentry进行缓存(用于VFS,加速文件路径名到inode的转换), 还采取了两种主要Cache方式：</p>
<p>Buffer Cache和Page Cache。前者针对磁盘块的读写，后者针对文件inode的读写。这些Cache有效缩短了 I&#x2F;O系统调用(比如read,write,getdents)的时间。<br/>磁盘的操作有逻辑级（文件系统）和物理级（磁盘块），这两种Cache就是分别缓存逻辑和物理级数据的。</p>
<p>Page cache实际上是针对文件系统的，是文件的缓存，在文件层面上的数据会缓存到page cache。文件的逻辑层需要映射到实际的物理磁盘，这种映射关系由文件系统来完成。当page cache的数据需要刷新时，page cache中的数据交给buffer cache，因为Buffer Cache就是缓存磁盘块的。但是这种处理在2.6版本的内核之后就变的很简单了，没有真正意义上的cache操作。</p>
<p>Buffer cache是针对磁盘块的缓存，也就是在没有文件系统的情况下，直接对磁盘进行操作的数据会缓存到buffer cache中，例如，文件系统的元数据都会缓存到buffer cache中。</p>
<p>简单说来，page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。</p>
<p>所以我们看linux,只要不用swap的交换空间,就不用担心自己的内存太少.如果常常swap用很多,可能你就要考虑加物理内存了.这也是linux看内存是否够用的标准.</p>
<p>如果是应用服务器的话，一般只看第二行，+buffers&#x2F;cache,即对应用程序来说free的内存太少了，也是该考虑优化程序或加内存了。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（49） -- df</title>
    <url>/2018/02/17/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-49/</url>
    <content><![CDATA[<p>显示磁盘的相关信息</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>df命令</strong> 用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a或--all：包含全部的文件系统；</span><br><span class="line">--block-size=&amp;lt;区块大小&amp;gt;：以指定的区块大小来显示区块数目；</span><br><span class="line">-h或--human-readable：以可读性较高的方式来显示信息；</span><br><span class="line">-H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；</span><br><span class="line">-i或--inodes：显示inode的信息；</span><br><span class="line">-k或--kilobytes：指定区块大小为1024字节；</span><br><span class="line">-l或--local：仅显示本地端的文件系统；</span><br><span class="line">-m或--megabytes：指定区块大小为1048576字节；</span><br><span class="line">--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；</span><br><span class="line">-P或--portability：使用POSIX的输出格式；</span><br><span class="line">--sync：在取得磁盘使用信息前，先执行sync指令；</span><br><span class="line">-t&amp;lt;文件系统类型&amp;gt;或--type=&amp;lt;文件系统类型&amp;gt;：仅显示指定文件系统类型的磁盘信息；</span><br><span class="line">-T或--print-type：显示文件系统的类型；</span><br><span class="line">-x&amp;lt;文件系统类型&amp;gt;或--exclude-type=&amp;lt;文件系统类型&amp;gt;：不要显示指定文件系统类型的磁盘信息；</span><br><span class="line">--help：显示帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>文件：指定文件系统上的文件。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>查看系统磁盘设备，默认是KB为单位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@LinServ-1 ~]# df</span><br><span class="line">文件系统               1K-块        已用     可用 已用% 挂载点</span><br><span class="line">/dev/sda2            146294492  28244432 110498708  21% /</span><br><span class="line">/dev/sda1              1019208     62360    904240   7% /boot</span><br><span class="line">tmpfs                  1032204         0   1032204   0% /dev/shm</span><br><span class="line">/dev/sdb1            2884284108 218826068 2518944764   8% /data1</span><br></pre></td></tr></table></figure>
<p>使用<code>-h</code>选项以KB以上的单位来显示，可读性高：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@LinServ-1 ~]# df -h</span><br><span class="line">文件系统              容量  已用 可用 已用% 挂载点</span><br><span class="line">/dev/sda2             140G   27G  106G  21% /</span><br><span class="line">/dev/sda1             996M   61M  884M   7% /boot</span><br><span class="line">tmpfs                1009M     0 1009M   0% /dev/shm</span><br><span class="line">/dev/sdb1             2.7T  209G  2.4T   8% /data1</span><br></pre></td></tr></table></figure>
<p>查看全部文件系统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@LinServ-1 ~]# df -a</span><br><span class="line">文件系统               1K-块        已用     可用 已用% 挂载点</span><br><span class="line">/dev/sda2            146294492  28244432 110498708  21% /</span><br><span class="line">proc                         0         0         0   -  /proc</span><br><span class="line">sysfs                        0         0         0   -  /sys</span><br><span class="line">devpts                       0         0         0   -  /dev/pts</span><br><span class="line">/dev/sda1              1019208     62360    904240   7% /boot</span><br><span class="line">tmpfs                  1032204         0   1032204   0% /dev/shm</span><br><span class="line">/dev/sdb1            2884284108 218826068 2518944764   8% /data1</span><br><span class="line">none                         0         0         0   -  /proc/sys/fs/binfmt_misc</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（5） -- mv</title>
    <url>/2018/01/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-5/</url>
    <content><![CDATA[<h2 id="重命名文件、文件夹"><a href="#重命名文件、文件夹" class="headerlink" title="重命名文件、文件夹"></a>重命名文件、文件夹</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ll</span><br><span class="line">total 4.0K</span><br><span class="line">drwxrwxr-x 2 atompi atompi 4.0K Jan  6 04:31 testdir-home-2</span><br><span class="line">➜  mv testdir-home-1 testdir-home-2</span><br><span class="line">➜  ll</span><br><span class="line">total 4.0K</span><br><span class="line">drwxrwxr-x 2 atompi atompi 4.0K Jan  6 04:31 testdir-home-2</span><br></pre></td></tr></table></figure>
<h2 id="移动文件、文件夹"><a href="#移动文件、文件夹" class="headerlink" title="移动文件、文件夹"></a>移动文件、文件夹</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ cd testdir-home</span><br><span class="line">➜  testdir-home ll</span><br><span class="line">total 4.0K</span><br><span class="line">drwxrwxr-x 2 atompi atompi 4.0K Jan  6 04:31 testdir-home-2</span><br><span class="line">➜  testdir-home mv testdir-home-2 ~/</span><br><span class="line">➜  testdir-home ll</span><br><span class="line">total 0</span><br><span class="line">➜  testdir-home ll ~/</span><br><span class="line">total 44K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br><span class="line">drwxrwxr-x  5 atompi atompi 4.0K Jan  5 22:02 atomsrc</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Dec 28 20:26 Documents</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Jan  6 04:28 Downloads</span><br><span class="line">drwxrwxr-x  4 atompi atompi 4.0K Jan  5 05:27 gitee</span><br><span class="line">drwxrwxr-x  8 atompi atompi 4.0K Jan  3 20:25 mayun-ee-p</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 18:50 shadowsocks</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 05:26 Templates</span><br><span class="line">-rw-rw-r--  1 atompi atompi    0 Jan  6 04:23 test-copy.txt</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  6 04:34 testdir-home</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  6 04:31 testdir-home-2</span><br><span class="line">-rw-rw-r--  1 atompi atompi    2 Jan  6 04:26 test.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（51） -- fdisk</title>
    <url>/2018/02/19/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-51/</url>
    <content><![CDATA[<p>查看磁盘使用情况和磁盘分区</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>fdisk命令</strong> 用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答式界面，而非类似DOS fdisk的cfdisk互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdisk (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b &amp;lt;大小&amp;gt;             扇区大小(512、1024、2048或4096)</span><br><span class="line">-c[=&amp;lt;模式&amp;gt;]           兼容模式：“dos”或“nondos”(默认)</span><br><span class="line">-h                    打印此帮助文本</span><br><span class="line">-u[=&amp;lt;单位&amp;gt;]           显示单位：“cylinders”(柱面)或“sectors”(扇区，默认)</span><br><span class="line">-v                    打印程序版本</span><br><span class="line">-C &amp;lt;数字&amp;gt;             指定柱面数</span><br><span class="line">-H &amp;lt;数字&amp;gt;             指定磁头数</span><br><span class="line">-S &amp;lt;数字&amp;gt;             指定每个磁道的扇区数</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>设备文件：指定要进行分区或者显示分区的硬盘设备文件。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先选择要进行操作的磁盘：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk /dev/sdb</span><br></pre></td></tr></table></figure>
<p>输入<code>m</code>列出可以执行的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command (m for help): m</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition&#x27;s system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   x   extra functionality (experts only)</span><br></pre></td></tr></table></figure>
<p>输入<code>p</code>列出磁盘目前的分区情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1               1           1        8001   8e  Linux LVM</span><br><span class="line">/dev/sdb2               2          26      200812+  83  Linux</span><br></pre></td></tr></table></figure>
<p>输入<code>d</code>然后选择分区，删除现有分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): d</span><br><span class="line">Partition number (1-4): 1</span><br><span class="line"></span><br><span class="line">Command (m for help): d</span><br><span class="line">Selected partition 2</span><br></pre></td></tr></table></figure>
<p>查看分区情况，确认分区已经删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): print</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line"></span><br><span class="line">Command (m for help):</span><br></pre></td></tr></table></figure>
<p>输入<code>n</code>建立新的磁盘分区，首先建立两个主磁盘分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Command action</span><br><span class="line">   e   extended</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">p    //建立主分区</span><br><span class="line">Partition number (1-4): 1  //分区号</span><br><span class="line">First cylinder (1-391, default 1):  //分区起始位置</span><br><span class="line">Using default value 1</span><br><span class="line">last cylinder or +size or +sizeM or +sizeK (1-391, default 391): 100  //分区结束位置，单位为扇区</span><br><span class="line"></span><br><span class="line">Command (m for help): n  //再建立一个分区</span><br><span class="line">Command action</span><br><span class="line">   e   extended</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">p</span><br><span class="line">Partition number (1-4): 2  //分区号为2</span><br><span class="line">First cylinder (101-391, default 101):</span><br><span class="line">Using default value 101</span><br><span class="line">Last cylinder or +size or +sizeM or +sizeK (101-391, default 391): +200M  //分区结束位置，单位为M</span><br></pre></td></tr></table></figure>
<p>确认分区建立成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1               1         100      803218+  83  Linux</span><br><span class="line">/dev/sdb2             101         125      200812+  83  Linux</span><br></pre></td></tr></table></figure>
<p>再建立一个逻辑分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Command action</span><br><span class="line">   e   extended</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">e  //选择扩展分区</span><br><span class="line">Partition number (1-4): 3</span><br><span class="line">First cylinder (126-391, default 126):</span><br><span class="line">Using default value 126</span><br><span class="line">Last cylinder or +size or +sizeM or +sizeK (126-391, default 391):</span><br><span class="line">Using default value 391</span><br></pre></td></tr></table></figure>
<p>确认扩展分区建立成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1               1         100      803218+  83  Linux</span><br><span class="line">/dev/sdb2             101         125      200812+  83  Linux</span><br><span class="line">/dev/sdb3             126         391     2136645    5  Extended</span><br></pre></td></tr></table></figure>
<p>在扩展分区上建立两个逻辑分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Command action</span><br><span class="line">   l   logical (5 or over)</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">l //选择逻辑分区</span><br><span class="line">First cylinder (126-391, default 126):</span><br><span class="line">Using default value 126</span><br><span class="line">Last cylinder or +size or +sizeM or +sizeK (126-391, default 391): +400M</span><br><span class="line"></span><br><span class="line">Command (m for help): n</span><br><span class="line">Command action</span><br><span class="line">   l   logical (5 or over)</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">l</span><br><span class="line">First cylinder (176-391, default 176):</span><br><span class="line">Using default value 176</span><br><span class="line">Last cylinder or +size or +sizeM or +sizeK (176-391, default 391):</span><br><span class="line">Using default value 391</span><br></pre></td></tr></table></figure>
<p>确认逻辑分区建立成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1               1         100      803218+  83  Linux</span><br><span class="line">/dev/sdb2             101         125      200812+  83  Linux</span><br><span class="line">/dev/sdb3             126         391     2136645    5  Extended</span><br><span class="line">/dev/sdb5             126         175      401593+  83  Linux</span><br><span class="line">/dev/sdb6             176         391     1734988+  83  Linux</span><br><span class="line"></span><br><span class="line">Command (m for help):</span><br></pre></td></tr></table></figure>
<p>从上面的结果我们可以看到，在硬盘sdb我们建立了2个主分区（sdb1，sdb2），1个扩展分区（sdb3），2个逻辑分区（sdb5，sdb6）</p>
<p>注意：主分区和扩展分区的磁盘号位1-4，也就是说最多有4个主分区或者扩展分区，逻辑分区开始的磁盘号为5，因此在这个实验中试没有sdb4的。</p>
<p>最后对分区操作进行保存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>
<p>建立好分区之后我们还需要对分区进行格式化才能在系统中使用磁盘。</p>
<p>在sdb1上建立ext2分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkfs.ext2 /dev/sdb1</span><br><span class="line">mke2fs 1.39 (29-May-2006)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS type: Linux</span><br><span class="line">Block size=4096 (log=2)</span><br><span class="line">Fragment size=4096 (log=2)</span><br><span class="line">100576 inodes, 200804 blocks</span><br><span class="line">10040 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=209715200</span><br><span class="line">7 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">14368 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">        32768, 98304, 163840</span><br><span class="line"></span><br><span class="line">Writing inode tables: done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br><span class="line"></span><br><span class="line">This filesystem will be automatically checked every 32 mounts or</span><br><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span><br></pre></td></tr></table></figure>
<p>在sdb6上建立ext3分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkfs.ext3 /dev/sdb6</span><br><span class="line">mke2fs 1.39 (29-May-2006)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS type: Linux</span><br><span class="line">Block size=4096 (log=2)</span><br><span class="line">Fragment size=4096 (log=2)</span><br><span class="line">217280 inodes, 433747 blocks</span><br><span class="line">21687 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=444596224</span><br><span class="line">14 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">15520 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">        32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (8192 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br><span class="line"></span><br><span class="line">This filesystem will be automatically checked every 32 mounts or</span><br><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>
<p>建立两个目录<code>/oracle</code>和<code>/web</code>，将新建好的两个分区挂载到系统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /oracle</span><br><span class="line">[root@localhost ~]# mkdir /web</span><br><span class="line">[root@localhost ~]# mount /dev/sdb1 /oracle</span><br><span class="line">[root@localhost ~]# mount /dev/sdb6 /web</span><br></pre></td></tr></table></figure>
<p>查看分区挂载情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统              容量  已用 可用 已用% 挂载点</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00</span><br><span class="line">                      6.7G  2.8G  3.6G  44% /</span><br><span class="line">/dev/sda1              99M   12M   82M  13% /boot</span><br><span class="line">tmpfs                 125M     0  125M   0% /dev/shm</span><br><span class="line">/dev/sdb1             773M  808K  733M   1% /oracle</span><br><span class="line">/dev/sdb6             1.7G   35M  1.6G   3% /web</span><br></pre></td></tr></table></figure>
<p>如果需要每次开机自动挂载则需要修改<code>/etc/fstab</code>文件，加入两行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line"></span><br><span class="line">/dev/VolGroup00/LogVol00 /                       ext3    defaults        1 1</span><br><span class="line">LABEL=/boot             /boot                   ext3    defaults        1 2</span><br><span class="line">tmpfs                   /dev/shm                tmpfs   defaults        0 0</span><br><span class="line">devpts                  /dev/pts                devpts  gid=5,mode=620  0 0</span><br><span class="line">sysfs                   /sys                    sysfs   defaults        0 0</span><br><span class="line">proc                    /proc                   proc    defaults        0 0</span><br><span class="line">/dev/VolGroup00/LogVol01 swap                    swap    defaults        0 0</span><br><span class="line">/dev/sdb1               /oracle                 ext2    defaults        0 0</span><br><span class="line">/dev/sdb6               /web                    ext3    defaults        0 0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（52） -- ifconfig</title>
    <url>/2018/02/20/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-52/</url>
    <content><![CDATA[<p>配置和显示Linux系统网卡的网络参数</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>ifconfig命令</strong> 被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig (参数)</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add&amp;lt;地址&amp;gt;：设置网络设备IPv6的ip地址；</span><br><span class="line">del&amp;lt;地址&amp;gt;：删除网络设备IPv6的IP地址；</span><br><span class="line">down：关闭指定的网络设备；</span><br><span class="line">&lt;hw&lt;网络设备类型&gt;&amp;lt;硬件地址&amp;gt;：设置网络设备的类型与硬件地址；&lt;/hw&lt;网络设备类型&gt;</span><br><span class="line">io_addr&lt;i o地址=&quot;&quot;&gt;：设置网络设备的I/O地址；&lt;/i&gt;&lt;i o地址=&quot;&quot;&gt;</span><br><span class="line">irq&lt;irq地址&gt;：设置网络设备的IRQ；&lt;/irq地址&gt;</span><br><span class="line">media&amp;lt;网络媒介类型&amp;gt;：设置网络设备的媒介类型；</span><br><span class="line">mem_start&amp;lt;内存地址&amp;gt;：设置网络设备在主内存所占用的起始地址；</span><br><span class="line">metric&amp;lt;数目&amp;gt;：指定在计算数据包的转送次数时，所要加上的数目；</span><br><span class="line">mtu&amp;lt;字节&amp;gt;：设置网络设备的MTU；</span><br><span class="line">netmask&amp;lt;子网掩码&amp;gt;：设置网络设备的子网掩码；</span><br><span class="line">tunnel&amp;lt;地址&amp;gt;：建立IPv4与IPv6之间的隧道通信地址；</span><br><span class="line">up：启动指定的网络设备；</span><br><span class="line">-broadcast&amp;lt;地址&amp;gt;：将要送往指定地址的数据包当成广播数据包来处理；</span><br><span class="line">-pointopoint&amp;lt;地址&amp;gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能；</span><br><span class="line">-promisc：关闭或启动指定网络设备的promiscuous模式；</span><br><span class="line">IP地址：指定网络设备的IP地址；</span><br><span class="line">网络设备：指定网络设备的名称。</span><br><span class="line">&lt;/i&gt;```</span><br><span class="line">### 实例</span><br><span class="line"></span><br><span class="line"> **显示网络设备信息（激活状态的）：**</span><br><span class="line"></span><br><span class="line">``` plain</span><br><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51</span><br><span class="line">          inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:56103 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p> <strong>eth0</strong> 表示第一块网卡，其中<code>HWaddr</code>表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是<code>00:16:3E:00:1E:51</code>。</p>
<p> <strong>inet addr</strong> 用来表示网卡的IP地址，此网卡的IP地址是<code>10.160.7.81</code>，广播地址<code>Bcast:10.160.15.255</code>，掩码地址<code>Mask:255.255.240.0</code>。</p>
<p> <strong>lo</strong> 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回坏地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。</p>
<li>第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）。
</li>
<li>第二行：网卡的IP地址、子网、掩码。
</li>
<li>第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节。
</li>
<li>第四、五行：接收、发送数据包情况统计。
</li>
<li>第七行：接收、发送数据字节数统计信息。
**启动关闭指定网卡：**
</li>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure>
<p><code>ifconfig eth0 up</code>为启动网卡eth0，<code>ifconfig eth0 down</code>为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。</p>
<p> <strong>为网卡配置和删除IPv6地址：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 add 33ffe:3240:800:1005::2/64    #为网卡eth0配置IPv6地址</span><br><span class="line">ifconfig eth0 del 33ffe:3240:800:1005::2/64    #为网卡eth0删除IPv6地址</span><br></pre></td></tr></table></figure>
<p> <strong>用ifconfig修改MAC地址：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE</span><br></pre></td></tr></table></figure>
<p> <strong>配置IP地址：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255</span><br></pre></td></tr></table></figure>
<p> <strong>启用和关闭arp协议：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 arp    #开启网卡eth0 的arp协议</span><br><span class="line">ifconfig eth0 -arp   #关闭网卡eth0 的arp协议</span><br></pre></td></tr></table></figure>
<p> <strong>设置最大传输单元：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 mtu 1500    #设置能通过的最大数据包大小为 1500 bytes</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（50） -- du</title>
    <url>/2018/02/18/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-50/</url>
    <content><![CDATA[<p>显示每个文件和目录的磁盘使用空间</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>du命令</strong> 也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du [选项][文件]</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a或-all 显示目录中个别文件的大小。</span><br><span class="line">-b或-bytes 显示目录或文件大小时，以byte为单位。</span><br><span class="line">-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</span><br><span class="line">-k或--kilobytes 以KB(1024bytes)为单位输出。</span><br><span class="line">-m或--megabytes 以MB为单位输出。</span><br><span class="line">-s或--summarize 仅显示总计，只列出最后加总的值。</span><br><span class="line">-h或--human-readable 以K，M，G为单位，提高信息的可读性。</span><br><span class="line">-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</span><br><span class="line">-L&amp;lt;符号链接&amp;gt;或--dereference&amp;lt;符号链接&amp;gt; 显示选项中所指定符号链接的源文件大小。</span><br><span class="line">-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</span><br><span class="line">-X&amp;lt;文件&amp;gt;或--exclude-from=&amp;lt;文件&amp;gt; 在&amp;lt;文件&amp;gt;指定目录或文件。</span><br><span class="line">--exclude=&amp;lt;目录或文件&amp;gt; 略过指定的目录或文件。</span><br><span class="line">-D或--dereference-args 显示指定符号链接的源文件大小。</span><br><span class="line">-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。</span><br><span class="line">-l或--count-links 重复计算硬件链接的文件。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>显示目录或者文件所占空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@localhost [test]# du</span><br><span class="line">608 ./test6</span><br><span class="line">308 ./test4</span><br><span class="line">4 ./scf/lib</span><br><span class="line">4 ./scf/service/deploy/product</span><br><span class="line">4 ./scf/service/deploy/info</span><br><span class="line">12 ./scf/service/deploy</span><br><span class="line">16 ./scf/service</span><br><span class="line">4 ./scf/doc</span><br><span class="line">4 ./scf/bin</span><br><span class="line">32 ./scf</span><br><span class="line">8 ./test3</span><br><span class="line">1288 .</span><br></pre></td></tr></table></figure>
<p>只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小</p>
<p>显示指定文件所占空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# du log2012.log</span><br><span class="line">300 log2012.log</span><br></pre></td></tr></table></figure>
<p>查看指定目录的所占空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# du scf</span><br><span class="line">4 scf/lib</span><br><span class="line">4 scf/service/deploy/product</span><br><span class="line">4 scf/service/deploy/info</span><br><span class="line">12 scf/service/deploy</span><br><span class="line">16 scf/service</span><br><span class="line">4 scf/doc</span><br><span class="line">4 scf/bin</span><br><span class="line">32 scf</span><br></pre></td></tr></table></figure>
<p>显示多个文件所占空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# du log30.tar.gz log31.tar.gz</span><br><span class="line">4 log30.tar.gz</span><br><span class="line">4 log31.tar.gz</span><br></pre></td></tr></table></figure>
<p>只显示总和的大小:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# du -s</span><br><span class="line">1288 .</span><br><span class="line"></span><br><span class="line">[root@localhost test]# du -s scf</span><br><span class="line">32 scf</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cd ..</span><br><span class="line">[root@localhost soft]# du -s test</span><br><span class="line">1288 test</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（54） -- ping</title>
    <url>/2018/02/22/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-54/</url>
    <content><![CDATA[<p>测试主机之间网络的连通性</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>ping命令</strong> 用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d：使用Socket的SO_DEBUG功能；</span><br><span class="line">-c&amp;lt;完成次数&amp;gt;：设置完成要求回应的次数；</span><br><span class="line">-f：极限检测；</span><br><span class="line">-i&amp;lt;间隔秒数&amp;gt;：指定收发信息的间隔时间；</span><br><span class="line">-I&amp;lt;网络界面&amp;gt;：使用指定的网络界面送出数据包；</span><br><span class="line">-l&amp;lt;前置载入&amp;gt;：设置在送出要求信息之前，先行发出的数据包；</span><br><span class="line">-n：只输出数值；</span><br><span class="line">-p&amp;lt;范本样式&amp;gt;：设置填满数据包的范本样式；</span><br><span class="line">-q：不显示指令执行过程，开头和结尾的相关信息除外；</span><br><span class="line">-r：忽略普通的Routing Table，直接将数据包送到远端主机上；</span><br><span class="line">-R：记录路由过程；</span><br><span class="line">-s&amp;lt;数据包大小&amp;gt;：设置数据包的大小；</span><br><span class="line">-t&amp;lt;存活数值&amp;gt;：设置存活数值TTL的大小；</span><br><span class="line">-v：详细显示指令的执行过程。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>目的主机：指定发送ICMP报文的目的主机。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@AY1307311912260196fcZ ~]# ping www.jsdig.com</span><br><span class="line">PING host.1.jsdig.com (100.42.212.8) 56(84) bytes of data.</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=1 ttl=50 time=177 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=2 ttl=50 time=178 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=3 ttl=50 time=174 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=4 ttl=50 time=177 ms</span><br><span class="line">...按Ctrl+C结束</span><br><span class="line"></span><br><span class="line">--- host.1.jsdig.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 2998ms</span><br><span class="line">rtt min/avg/max/mdev = 174.068/176.916/178.182/1.683 ms</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（55） -- traceroute</title>
    <url>/2018/02/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-55/</url>
    <content><![CDATA[<p>显示数据包到主机间的路径</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>traceroute命令</strong> 用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是40字节。</p>
<p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。</p>
<p>traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其ip地址。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">traceroute (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d：使用Socket层级的排错功能；</span><br><span class="line">-f&amp;lt;存活数值&amp;gt;：设置第一个检测数据包的存活数值TTL的大小；</span><br><span class="line">-F：设置勿离断位；</span><br><span class="line">-g&amp;lt;网关&amp;gt;：设置来源路由网关，最多可设置8个；</span><br><span class="line">-i&amp;lt;网络界面&amp;gt;：使用指定的网络界面送出数据包；</span><br><span class="line">-I：使用ICMP回应取代UDP资料信息；</span><br><span class="line">-m&amp;lt;存活数值&amp;gt;：设置检测数据包的最大存活数值TTL的大小；</span><br><span class="line">-n：直接使用IP地址而非主机名称；</span><br><span class="line">-p&amp;lt;通信端口&amp;gt;：设置UDP传输协议的通信端口；</span><br><span class="line">-r：忽略普通的Routing Table，直接将数据包送到远端主机上。</span><br><span class="line">-s&amp;lt;来源地址&amp;gt;：设置本地主机送出数据包的IP地址；</span><br><span class="line">-t&amp;lt;服务类型&amp;gt;：设置检测数据包的TOS数值；</span><br><span class="line">-v：详细显示指令的执行过程；</span><br><span class="line">-w&amp;lt;超时秒数&amp;gt;：设置等待远端主机回报的时间；</span><br><span class="line">-x：开启或关闭数据包的正确性检验。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>主机：指定目的主机IP地址或主机名。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">traceroute www.58.com</span><br><span class="line">traceroute to www.58.com (211.151.111.30), 30 hops max, 40 byte packets</span><br><span class="line"> 1  unknown (192.168.2.1)  3.453 ms  3.801 ms  3.937 ms</span><br><span class="line"> 2  221.6.45.33 (221.6.45.33)  7.768 ms  7.816 ms  7.840 ms</span><br><span class="line"> 3  221.6.0.233 (221.6.0.233)  13.784 ms  13.827 ms 221.6.9.81 (221.6.9.81)  9.758 ms</span><br><span class="line"> 4  221.6.2.169 (221.6.2.169)  11.777 ms 122.96.66.13 (122.96.66.13)  34.952 ms 221.6.2.53 (221.6.2.53)  41.372 ms</span><br><span class="line"> 5  219.158.96.149 (219.158.96.149)  39.167 ms  39.210 ms  39.238 ms</span><br><span class="line"> 6  123.126.0.194 (123.126.0.194)  37.270 ms 123.126.0.66 (123.126.0.66)  37.163 ms  37.441 ms</span><br><span class="line"> 7  124.65.57.26 (124.65.57.26)  42.787 ms  42.799 ms  42.809 ms</span><br><span class="line"> 8  61.148.146.210 (61.148.146.210)  30.176 ms 61.148.154.98 (61.148.154.98)  32.613 ms  32.675 ms</span><br><span class="line"> 9  202.106.42.102 (202.106.42.102)  44.563 ms  44.600 ms  44.627 ms</span><br><span class="line">10  210.77.139.150 (210.77.139.150)  53.302 ms  53.233 ms  53.032 ms</span><br><span class="line">11  211.151.104.6 (211.151.104.6)  39.585 ms  39.502 ms  39.598 ms</span><br><span class="line">12  211.151.111.30 (211.151.111.30)  35.161 ms  35.938 ms  36.005 ms</span><br></pre></td></tr></table></figure>
<p>记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是ms，其实就是<code>-q</code>的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果用<code>traceroute -q 4 www.58.com</code>，表示向每个网关发送4个数据包。</p>
<p>有时我们traceroute一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。</p>
<p>有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加<code>-n</code>参数来避免DNS解析，以IP格式输出数据。</p>
<p>如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。</p>
<p><strong>跳数设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# traceroute -m 10 www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (61.135.169.105), 10 hops max, 40 byte packets</span><br><span class="line"> 1  192.168.74.2 (192.168.74.2)  1.534 ms  1.775 ms  1.961 ms</span><br><span class="line"> 2  211.151.56.1 (211.151.56.1)  0.508 ms  0.514 ms  0.507 ms</span><br><span class="line"> 3  211.151.227.206 (211.151.227.206)  0.571 ms  0.558 ms  0.550 ms</span><br><span class="line"> 4  210.77.139.145 (210.77.139.145)  0.708 ms  0.729 ms  0.785 ms</span><br><span class="line"> 5  202.106.42.101 (202.106.42.101)  7.978 ms  8.155 ms  8.311 ms</span><br><span class="line"> 6  bt-228-037.bta.net.cn (202.106.228.37)  772.460 ms bt-228-025.bta.net.cn (202.106.228.25)  2.152 ms 61.148.154.97 (61.148.154.97)  772.107 ms</span><br><span class="line"> 7  124.65.58.221 (124.65.58.221)  4.875 ms 61.148.146.29 (61.148.146.29)  2.124 ms 124.65.58.221 (124.65.58.221)  4.854 ms</span><br><span class="line"> 8  123.126.6.198 (123.126.6.198)  2.944 ms 61.148.156.6 (61.148.156.6)  3.505 ms 123.126.6.198 (123.126.6.198)  2.885 ms</span><br><span class="line"> 9  * * *</span><br><span class="line">10  * * *</span><br></pre></td></tr></table></figure>
<p>其它一些实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">traceroute -m 10 www.baidu.com # 跳数设置</span><br><span class="line">traceroute -n www.baidu.com    # 显示IP地址，不查主机名</span><br><span class="line">traceroute -p 6888 www.baidu.com  # 探测包使用的基本UDP端口设置6888</span><br><span class="line">traceroute -q 4 www.baidu.com  # 把探测包的个数设置为值4</span><br><span class="line">traceroute -r www.baidu.com    # 绕过正常的路由表，直接发送到网络相连的主机</span><br><span class="line">traceroute -w 3 www.baidu.com  # 把对外发探测包的等待响应时间设置为3秒</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（56） -- host</title>
    <url>/2018/02/24/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-56/</url>
    <content><![CDATA[<p>常用的分析域名查询工具</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>host命令</strong> 是常用的分析域名查询工具，可以用来测试域名系统工作是否正常。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a：显示详细的DNS信息；</span><br><span class="line">-c&amp;lt;类型&amp;gt;：指定查询类型，默认值为“IN“；</span><br><span class="line">-C：查询指定主机的完整的SOA记录；</span><br><span class="line">-r：在查询域名时，不使用递归的查询方式；</span><br><span class="line">-t&amp;lt;类型&amp;gt;：指定查询的域名信息类型；</span><br><span class="line">-v：显示指令执行的详细信息；</span><br><span class="line">-w：如果域名服务器没有给出应答信息，则总是等待，直到域名服务器给出应答；</span><br><span class="line">-W&amp;lt;时间&amp;gt;：指定域名查询的最长时间，如果在指定时间内域名服务器没有给出应答信息，则退出指令；</span><br><span class="line">-4：使用IPv4；</span><br><span class="line">-6：使用IPv6.</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>主机：指定要查询信息的主机信息。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# host www.jsdig.com</span><br><span class="line">www.jsdig.com is an alias for host.1.jsdig.com.</span><br><span class="line">host.1.jsdig.com has address 100.42.212.8</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# host -a www.jsdig.com</span><br><span class="line">Trying &quot;www.jsdig.com&quot;</span><br><span class="line">;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 34671</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.jsdig.com.               IN      ANY</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.jsdig.com.        463     IN      CNAME   host.1.jsdig.com.</span><br><span class="line"></span><br><span class="line">Received 54 bytes from 202.96.104.15#53 in 0 ms</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（57） -- dig</title>
    <url>/2018/02/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-57/</url>
    <content><![CDATA[<p>域名查询工具</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>dig命令</strong> 是常用的域名查询工具，可以用来测试域名系统工作是否正常。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@&amp;lt;服务器地址&amp;gt;：指定进行域名解析的域名服务器；</span><br><span class="line">-b&lt;ip地址&gt;：当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求；&lt;/ip地址&gt;</span><br><span class="line">-f&amp;lt;文件名称&amp;gt;：指定dig以批处理的方式运行，指定的文件中保存着需要批处理查询的DNS任务信息；</span><br><span class="line">-P：指定域名服务器所使用端口号；</span><br><span class="line">-t&amp;lt;类型&amp;gt;：指定要查询的DNS数据类型；</span><br><span class="line">-x&lt;ip地址&gt;：执行逆向域名查询；&lt;/ip地址&gt;</span><br><span class="line">-4：使用IPv4；</span><br><span class="line">-6：使用IPv6；</span><br><span class="line">-h：显示指令帮助信息。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>主机：指定要查询域名主机；</li>
<li>查询类型：指定DNS查询的类型；</li>
<li>查询类：指定查询DNS的class；</li>
<li>查询选项：指定查询选项。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# dig www.jsdig.com</span><br><span class="line"></span><br><span class="line">; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.3.6-P1-RedHat-9.3.6-20.P1.el5_8.1 &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.jsdig.com</span><br><span class="line">;; global options:  printcmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 2115</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.jsdig.com.               IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.jsdig.com.        0       IN      CNAME   host.1.jsdig.com.</span><br><span class="line">host.1.jsdig.com.     0       IN      A       100.42.212.8</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">jsdig.com.            8       IN      NS      f1g1ns2.dnspod.net.</span><br><span class="line">jsdig.com.            8       IN      NS      f1g1ns1.dnspod.net.</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 202.96.104.15#53(202.96.104.15)</span><br><span class="line">;; WHEN: Thu Dec 26 11:14:37 2013</span><br><span class="line">;; MSG SIZE  rcvd: 121</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（53） -- ip</title>
    <url>/2018/02/21/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-53/</url>
    <content><![CDATA[<p>网络配置工具</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>ip命令</strong> 用来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip (选项) (参数)</span><br><span class="line">Usage: ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</span><br><span class="line">       ip [ -force ] -batch filename</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OBJECT := &#123; link | address | addrlabel | route | rule | neigh | ntable |</span><br><span class="line">       tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm |</span><br><span class="line">       netns | l2tp | macsec | tcp_metrics | token &#125;</span><br><span class="line"></span><br><span class="line">-V：显示指令版本信息；</span><br><span class="line">-s：输出更详细的信息；</span><br><span class="line">-f：强制使用指定的协议族；</span><br><span class="line">-4：指定使用的网络层协议是IPv4协议；</span><br><span class="line">-6：指定使用的网络层协议是IPv6协议；</span><br><span class="line">-0：输出信息每条记录输出一行，即使内容较多也不换行显示；</span><br><span class="line">-r：显示主机时，不使用IP地址，而使用主机的域名。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS := &#123; -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |</span><br><span class="line">        -h[uman-readable] | -iec |</span><br><span class="line">        -f[amily] &#123; inet | inet6 | ipx | dnet | bridge | link &#125; |</span><br><span class="line">        -4 | -6 | -I | -D | -B | -0 |</span><br><span class="line">        -l[oops] &#123; maximum-addr-flush-attempts &#125; |</span><br><span class="line">        -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] |</span><br><span class="line">        -rc[vbuf] [size] | -n[etns] name | -a[ll] &#125;</span><br><span class="line"></span><br><span class="line">网络对象：指定要管理的网络对象；</span><br><span class="line">具体操作：对指定的网络对象完成具体操作；</span><br><span class="line">help：显示网络对象支持的操作命令的帮助信息。</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show                     <span class="comment"># 显示网络接口信息</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 upi             <span class="comment"># 开启网卡</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down            <span class="comment"># 关闭网卡</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc on      <span class="comment"># 开启网卡的混合模式</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc offi    <span class="comment"># 关闭网卡的混个模式</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 txqueuelen 1200 <span class="comment"># 设置网卡队列长度</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 mtu 1400        <span class="comment"># 设置网卡最大传输单元</span></span><br><span class="line">ip addr show     <span class="comment"># 显示网卡IP信息</span></span><br><span class="line">ip addr add 192.168.0.1/24 dev eth0 <span class="comment"># 设置eth0网卡IP地址192.168.0.1</span></span><br><span class="line">ip addr del 192.168.0.1/24 dev eth0 <span class="comment"># 删除eth0网卡IP地址</span></span><br><span class="line"></span><br><span class="line">ip route show <span class="comment"># 显示系统路由</span></span><br><span class="line">ip route add default via 192.168.1.254   <span class="comment"># 设置系统默认路由</span></span><br><span class="line">ip route list                 <span class="comment"># 查看路由信息</span></span><br><span class="line">ip route add 192.168.4.0/24  via  192.168.0.254 dev eth0 <span class="comment"># 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口</span></span><br><span class="line">ip route add default via  192.168.0.254  dev eth0        <span class="comment"># 设置默认网关为192.168.0.254</span></span><br><span class="line">ip route del 192.168.4.0/24   <span class="comment"># 删除192.168.4.0网段的网关</span></span><br><span class="line">ip route del default          <span class="comment"># 删除默认路由</span></span><br><span class="line">ip route delete 192.168.1.0/24 dev eth0 <span class="comment"># 删除路由</span></span><br></pre></td></tr></table></figure>
<p><strong>用ip命令显示网络设备的运行状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ip link list</span><br><span class="line">1: lo: &lt;loopback,up,lower_up&gt; mtu 16436 qdisc noqueue&lt;/loopback,up,lower_up&gt;</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;broadcast,multicast,up,lower_up&gt; mtu 1500 qdisc pfifo_fast qlen 1000&lt;/broadcast,multicast,up,lower_up&gt;</span><br><span class="line">    link/ether 00:16:3e:00:1e:51 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: eth1: &lt;broadcast,multicast,up,lower_up&gt; mtu 1500 qdisc pfifo_fast qlen 1000&lt;/broadcast,multicast,up,lower_up&gt;</span><br><span class="line">    link/ether 00:16:3e:00:1e:52 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
<p><strong>显示更加详细的设备信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ip -s link list</span><br><span class="line">1: lo: &lt;loopback,up,lower_up&gt; mtu 16436 qdisc noqueue&lt;/loopback,up,lower_up&gt;</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast</span><br><span class="line">    5082831    56145    0       0       0       0</span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns</span><br><span class="line">    5082831    56145    0       0       0       0</span><br><span class="line">2: eth0: &lt;broadcast,multicast,up,lower_up&gt; mtu 1500 qdisc pfifo_fast qlen 1000&lt;/broadcast,multicast,up,lower_up&gt;</span><br><span class="line">    link/ether 00:16:3e:00:1e:51 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast</span><br><span class="line">    3641655380 62027099 0       0       0       0</span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns</span><br><span class="line">    6155236    89160    0       0       0       0</span><br><span class="line">3: eth1: &lt;broadcast,multicast,up,lower_up&gt; mtu 1500 qdisc pfifo_fast qlen 1000&lt;/broadcast,multicast,up,lower_up&gt;</span><br><span class="line">    link/ether 00:16:3e:00:1e:52 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast</span><br><span class="line">    2562136822 488237847 0       0       0       0</span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns</span><br><span class="line">    3486617396 9691081  0       0       0       0</span><br></pre></td></tr></table></figure>
<p><strong>显示核心路由表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ip route list</span><br><span class="line">112.124.12.0/22 dev eth1  proto kernel  scope link  src 112.124.15.130</span><br><span class="line">10.160.0.0/20 dev eth0  proto kernel  scope link  src 10.160.7.81</span><br><span class="line">192.168.0.0/16 via 10.160.15.247 dev eth0</span><br><span class="line">172.16.0.0/12 via 10.160.15.247 dev eth0</span><br><span class="line">10.0.0.0/8 via 10.160.15.247 dev eth0</span><br><span class="line">default via 112.124.15.247 dev eth1</span><br></pre></td></tr></table></figure>
<p><strong>显示邻居表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ip neigh list</span><br><span class="line">112.124.15.247 dev eth1 lladdr 00:00:0c:9f:f3:88 REACHABLE</span><br><span class="line">10.160.15.247 dev eth0 lladdr 00:00:0c:9f:f2:c0 STALE</span><br></pre></td></tr></table></figure>
<p><strong>获取主机所有网络接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link | grep ^[0-9] | awk -F: &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（59） -- route</title>
    <url>/2018/02/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-59/</url>
    <content><![CDATA[<p>显示并设置Linux中静态路由表</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>route命令</strong> 用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。</p>
<p>在Linux系统中设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的ip地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在<code>/etc/rc.local</code>中添加route命令来保证该路由设置永久有效。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A：设置地址类型；</span><br><span class="line">-C：打印将Linux核心的路由缓存；</span><br><span class="line">-v：详细信息模式；</span><br><span class="line">-n：不执行DNS反向查找，直接显示数字形式的IP地址；</span><br><span class="line">-e：netstat格式显示路由表；</span><br><span class="line">-net：到一个网络的路由表；</span><br><span class="line">-host：到一个主机的路由表。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add：增加指定的路由记录；</span><br><span class="line">Del：删除指定的路由记录；</span><br><span class="line">Target：目的网络或目的主机；</span><br><span class="line">gw：设置默认网关；</span><br><span class="line">mss：设置TCP的最大区块长度（MSS），单位MB；</span><br><span class="line">window：指定通过路由表的TCP连接的TCP窗口大小；</span><br><span class="line">dev：路由记录所表示的网络接口。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> <strong>显示当前路由：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">112.124.12.0    *               255.255.252.0   U     0      0        0 eth1</span><br><span class="line">10.160.0.0      *               255.255.240.0   U     0      0        0 eth0</span><br><span class="line">192.168.0.0     10.160.15.247   255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">172.16.0.0      10.160.15.247   255.240.0.0     UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        10.160.15.247   255.0.0.0       UG    0      0        0 eth0</span><br><span class="line">default         112.124.15.247  0.0.0.0         UG    0      0        0 eth1</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">112.124.12.0    0.0.0.0         255.255.252.0   U     0      0        0 eth1</span><br><span class="line">10.160.0.0      0.0.0.0         255.255.240.0   U     0      0        0 eth0</span><br><span class="line">192.168.0.0     10.160.15.247   255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">172.16.0.0      10.160.15.247   255.240.0.0     UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        10.160.15.247   255.0.0.0       UG    0      0        0 eth0</span><br><span class="line">0.0.0.0         112.124.15.247  0.0.0.0         UG    0      0        0 eth1</span><br></pre></td></tr></table></figure>
<p>其中Flags为路由标志，标记当前网络节点的状态，Flags标志说明：</p>
<li>U Up表示此路由当前为启动状态。
</li>
<li>H Host，表示此网关为一主机。
</li>
<li>G Gateway，表示此网关为一路由器。
</li>
<li>R Reinstate Route，使用动态路由重新初始化的路由。
</li>
<li>D Dynamically,此路由是动态性地写入。
</li>
<li>M Modified，此路由是由路由守护程序或导向器动态修改。
</li>
<li>! 表示此路由当前为关闭状态。
**添加网关/设置网关：**
</li>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0    #增加一条到达244.0.0.0的路由。</span><br></pre></td></tr></table></figure>
<p> <strong>屏蔽一条路由：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject     #增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝。</span><br></pre></td></tr></table></figure>
<p> <strong>删除路由记录：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure>
<p> <strong>删除和添加设置默认网关：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route del default gw 192.168.120.240</span><br><span class="line">route add default gw 192.168.120.240</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（6） -- ln</title>
    <url>/2018/01/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-6/</url>
    <content><![CDATA[<p>Unix 系统的链接非常有趣，在此转发<a href="https://www.jianshu.com/p/dde6a01c4094">简书的一篇文章</a>，写得非常棒。</p>
<h1 id="什么是链接？"><a href="#什么是链接？" class="headerlink" title="什么是链接？"></a>什么是链接？</h1><p>链接简单说实际上是一种文件共享的方式，是 <strong>POSIX</strong> 中的概念，主流文件系统都支持链接文件。</p>
<h1 id="它是用来干什么的？"><a href="#它是用来干什么的？" class="headerlink" title="它是用来干什么的？"></a>它是用来干什么的？</h1><p>你可以将链接简单地理解为 Windows 中常见的快捷方式（或是 OS X 中的替身），Linux 中常用它来解决一些库版本的问题，通常也会将一些目录层次较深的文件链接到一个更易访问的目录中。在这些用途上，我们通常会使用到<strong>软链接</strong>（也称<strong>符号链接</strong>）。</p>
<h1 id="软链接和硬链接的区别是？"><a href="#软链接和硬链接的区别是？" class="headerlink" title="软链接和硬链接的区别是？"></a>软链接和硬链接的区别是？</h1><p>下面我们进入正题，来探讨一下软硬两种链接到底有什么区别？</p>
<p>首先，从使用的角度讲，两者没有任何区别，都与正常的文件访问方式一样，支持读写，如果是可执行文件的话也可以直接执行。</p>
<p>那区别在哪呢？在底层的原理上。</p>
<p>为了解释清楚，我们首先在自己的一个工作目录下创建一个文件，然后对这个文件进行链接的创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch myfile &amp;amp;&amp;amp; echo &quot;This is a plain text file.&quot; &amp;gt; myfile</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br></pre></td></tr></table></figure>

<p>现在我们创建了一个普通地不能再普通的文件了。然后我们对它创建一个硬链接，并查看一下当前目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ln myfile hard</span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r--  2 unixzii  staff  27  7  8 17:39 hard</span><br><span class="line">25869085 -rw-r--r--  2 unixzii  staff  27  7  8 17:39 myfile</span><br></pre></td></tr></table></figure>

<p>在 <code>ls</code> 结果的最左边一列，是文件的 <code>inode</code> 值，你可以简单把它想成 C 语言中的指针。它指向了物理硬盘的一个区块，事实上文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。</p>
<p>你也看到了，这两个文件就如同一个文件一样，<code>inode</code> 值相同，都指向同一个区块。</p>
<p>然后我们修改一下刚才创建的 <strong>hard</strong> 链接文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;New line&quot; &amp;gt;&amp;gt; hard</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure>

<p>可以看到，这两个文件果真就是一个文件。<br/>下面我们看看软链接（也就是符号链接）和它有什么区别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ln -s myfile soft</span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r--  2 unixzii  staff  36  7  8 17:45 hard</span><br><span class="line">25869085 -rw-r--r--  2 unixzii  staff  36  7  8 17:45 myfile</span><br><span class="line">25869216 lrwxr-xr-x  1 unixzii  staff   6  7  8 17:47 soft -&amp;gt; myfile</span><br></pre></td></tr></table></figure>

<p>诶，你会发现，这个软链接的 <code>inode</code> 竟然不一样啊，并且它的文件属性上也有一个 <code>l</code> 的 flag，这就说明它与之前我们创建的两个文件根本不是一个类型。</p>
<p>下面我们试着删除 <strong>myfile</strong> 文件，然后分别输出软硬链接的文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm myfile</span><br><span class="line">$ cat hard</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br><span class="line"></span><br><span class="line">$ cat soft</span><br><span class="line"></span><br><span class="line">cat: soft: No such file or directory</span><br></pre></td></tr></table></figure>

<p>之前的硬链接没有丝毫地影响，因为它 <code>inode</code> 所指向的区块由于有一个硬链接在指向它，所以这个区块仍然有效，并且可以访问到。<br/>然而软链接的 <code>inode</code> 所指向的内容实际上是保存了一个绝对路径，当用户访问这个文件时，系统会自动将其替换成其所指的文件路径，然而这个文件已经被删除了，所以自然就会显示无法找到该文件了。</p>
<p>为验证这一猜想，我们再向这个软链接写点东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;Something&quot; &amp;gt;&amp;gt; soft</span><br><span class="line">$ ls</span><br><span class="line"></span><br><span class="line">hard   myfile soft</span><br></pre></td></tr></table></figure>

<p>可以看到，刚才删除的 <strong>myfile</strong> 文件竟然又出现了！这就说明，当我们写入访问软链接时，系统自动将其路径替换为其所代表的绝对路径，并直接访问那个路径了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里我们其实可以总结一下了：</p>
<ul>
<li>硬链接： 与普通文件没什么不同，<code>inode</code> 都指向同一个文件在硬盘中的区块</li>
<li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（60） -- ifup 、 ifdown</title>
    <url>/2018/02/28/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-60/</url>
    <content><![CDATA[<h2 id="ifup"><a href="#ifup" class="headerlink" title="ifup"></a>ifup</h2><p>激活指定的网络接口</p>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p><strong>ifup命令</strong> 用于激活指定的网络接口。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifup (参数)</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>网络接口：要激活的网络接口。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifup eth0   #激活eth0</span><br></pre></td></tr></table></figure>
<h2 id="ifdown"><a href="#ifdown" class="headerlink" title="ifdown"></a>ifdown</h2><p>禁用指定的网络接口</p>
<h3 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h3><p><strong>ifdown命令</strong> 用于禁用指定的网络接口。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifdown (参数)</span><br></pre></td></tr></table></figure>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>网络接口：要禁用的网络接口。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifdown eth0  #禁用eth0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（58） -- dhclient</title>
    <url>/2018/02/26/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-58/</url>
    <content><![CDATA[<p>动态获取或释放IP地址</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>dhclient命令</strong> 使用动态主机配置协议动态的配置网络接口的网络参数。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dhclient (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0：指定dhcp客户端监听的端口号；</span><br><span class="line">-d：总是以前台方式运行程序；</span><br><span class="line">-q：安静模式，不打印任何错误的提示信息；</span><br><span class="line">-r：释放ip地址。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>网络接口：操作的网络接口。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dhclient -r     #释放IP</span><br><span class="line">dhclient        #获取IP</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（61） -- apt-get</title>
    <url>/2018/03/01/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-61/</url>
    <content><![CDATA[<p>Debian Linux发行版中的APT软件包管理工具</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>apt-get命令</strong> 是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c：指定配置文件。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>管理指令：对APT软件包的管理操作；</li>
<li>软件包：指定要操纵的软件包。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>使用apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。&#x2F;etc&#x2F;apt&#x2F;sources.list是存放这些地址列表的配置文件，其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb web或[ftp地址] [发行版名字] main/contrib/non-[free]</span><br></pre></td></tr></table></figure>
<p>我们常用的Ubuntu就是一个基于Debian的发行，我们使用apt-get命令获取这个列表，以下是我整理的常用命令：</p>
<p>在修改<code>/etc/apt/sources.list</code>或者<code>/etc/apt/preferences</code>之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>
<p>安装一个新软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install packagename</span><br></pre></td></tr></table></figure>
<p>卸载一个已安装的软件包（保留配置文件）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get remove packagename</span><br></pre></td></tr></table></figure>
<p>卸载一个已安装的软件包（删除配置文件）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get –purge remove packagename</span><br></pre></td></tr></table></figure>
<p>会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get autoclean apt</span><br></pre></td></tr></table></figure>
<p>这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get clean</span><br></pre></td></tr></table></figure>
<p>更新所有已安装的软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>将系统升级到新版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></table></figure>
<p>定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，您可以释放大量的磁盘空间。如果您的需求十分迫切，可以使用<code>apt-get clean</code>以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。大多数情况下您不会再用到这些.debs文件，因此如果您为磁盘空间不足 而感到焦头烂额，这个办法也许值得一试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get autoclean</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（62） -- apt-key</title>
    <url>/2018/03/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-62/</url>
    <content><![CDATA[<p>管理Debian Linux系统中的软件包密钥</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>apt-key命令</strong> 用于管理Debian Linux系统中的软件包密钥。每个发布的deb包，都是通过密钥认证的，apt-key用来管理密钥。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-key (参数)</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>操作指令：APT密钥操作指令。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-key list          #列出已保存在系统中key。</span><br><span class="line">apt-key add keyname   #把下载的key添加到本地trusted数据库中。</span><br><span class="line">apt-key del keyname   #从本地trusted数据库删除key。</span><br><span class="line">apt-key update        #更新本地trusted数据库，删除过期没用的key。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（63） -- yum</title>
    <url>/2018/03/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-63/</url>
    <content><![CDATA[<p>基于RPM的软件包管理器</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>yum命令</strong> 是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
<p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h：显示帮助信息；</span><br><span class="line">-y：对所有的提问都回答“yes”；</span><br><span class="line">-c：指定配置文件；</span><br><span class="line">-q：安静模式；</span><br><span class="line">-v：详细模式；</span><br><span class="line">-d：设置调试等级（0-10）；</span><br><span class="line">-e：设置错误等级（0-10）；</span><br><span class="line">-R：设置yum处理一个命令的最大等待时间；</span><br><span class="line">-C：完全从缓存中运行，而不去下载或者更新任何头文件。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install：安装rpm软件包；</span><br><span class="line">update：更新rpm软件包；</span><br><span class="line">check-update：检查是否有可用的更新rpm软件包；</span><br><span class="line">remove：删除指定的rpm软件包；</span><br><span class="line">list：显示软件包的信息；</span><br><span class="line">search：检查软件包的信息；</span><br><span class="line">info：显示指定的rpm软件包的描述信息和概要信息；</span><br><span class="line">clean：清理yum过期的缓存；</span><br><span class="line">shell：进入yum的shell提示符；</span><br><span class="line">resolvedep：显示rpm软件包的依赖关系；</span><br><span class="line">localinstall：安装本地的rpm软件包；</span><br><span class="line">localupdate：显示本地rpm软件包进行更新；</span><br><span class="line">deplist：显示rpm软件包的所有依赖关系。</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>部分常用的命令包括：</p>
<ul>
<li>自动搜索最快镜像插件：<code>yum install yum-fastestmirror</code></li>
<li>安装yum图形窗口插件：<code>yum install yumex</code></li>
<li>查看可能批量安装的列表：<code>yum grouplist</code></li>
</ul>
<p><strong>安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install              <span class="comment">#全部安装</span></span><br><span class="line">yum install package1     <span class="comment">#安装指定的安装包package1</span></span><br><span class="line">yum groupinsall group1   <span class="comment">#安装程序组group1</span></span><br></pre></td></tr></table></figure>
<p><strong>更新和升级</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update               <span class="comment">#全部更新</span></span><br><span class="line">yum update package1      <span class="comment">#更新指定程序包package1</span></span><br><span class="line">yum check-update         <span class="comment">#检查可更新的程序</span></span><br><span class="line">yum upgrade package1     <span class="comment">#升级指定程序包package1</span></span><br><span class="line">yum groupupdate group1   <span class="comment">#升级程序组group1</span></span><br></pre></td></tr></table></figure>
<p><strong>查找和显示</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查 MySQL 是否已安装</span></span><br><span class="line">yum list installed | grep mysql</span><br><span class="line">yum list installed mysql*</span><br><span class="line"></span><br><span class="line">yum info package1      <span class="comment">#显示安装包信息package1</span></span><br><span class="line">yum list               <span class="comment">#显示所有已经安装和可以安装的程序包</span></span><br><span class="line">yum list package1      <span class="comment">#显示指定程序包安装情况package1</span></span><br><span class="line">yum groupinfo group1   <span class="comment">#显示程序组group1信息yum search string 根据关键字string查找安装包</span></span><br></pre></td></tr></table></figure>
<p><strong>删除程序</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove &amp;amp;#124; erase package1   <span class="comment">#删除程序包package1</span></span><br><span class="line">yum groupremove group1             <span class="comment">#删除程序组group1</span></span><br><span class="line">yum deplist package1               <span class="comment">#查看程序package1依赖情况</span></span><br></pre></td></tr></table></figure>
<p><strong>清除缓存</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean packages       <span class="comment">#清除缓存目录下的软件包</span></span><br><span class="line">yum clean headers        <span class="comment">#清除缓存目录下的 headers</span></span><br><span class="line">yum clean oldheaders     <span class="comment">#清除缓存目录下旧的 headers</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（64） -- iostat</title>
    <url>/2018/03/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-64/</url>
    <content><![CDATA[<p>监视系统输入输出设备和CPU的使用情况</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>iostat命令</strong> 被用于监视系统输入输出设备和CPU的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iostat (选项) (参数)</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c：仅显示CPU使用情况；</span><br><span class="line">-d：仅显示设备利用率；</span><br><span class="line">-k：显示状态以千字节每秒为单位，而不使用块每秒；</span><br><span class="line">-m：显示状态以兆字节每秒为单位；</span><br><span class="line">-p：仅显示块设备和所有被使用的其他分区的状态；</span><br><span class="line">-t：显示每个报告产生时的时间；</span><br><span class="line">-V：显示版号并退出；</span><br><span class="line">-x：显示扩展状态。</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>间隔时间：每次报告的间隔时间（秒）；</li>
<li>次数：显示报告的次数。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>用<code>iostat -x /dev/sda1</code>来观看磁盘I&#x2F;O的详细情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iostat -x /dev/sda1</span><br><span class="line">Linux 2.6.18-164.el5xen (localhost.localdomain)</span><br><span class="line">2010年03月26日</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait</span><br><span class="line">%steal   %idle</span><br><span class="line">            0.11    0.02    0.18    0.35</span><br><span class="line">0.03    99.31</span><br><span class="line"></span><br><span class="line">Device:         tps   Blk_read/s    Blk_wrtn/s</span><br><span class="line">Blk_read   Blk_wrtn</span><br><span class="line">sda1                0.02          0.08</span><br><span class="line">0.00          2014               4</span><br></pre></td></tr></table></figure>
<p>详细说明：第二行是系统信息和监测时间，第三行和第四行显示CPU使用情况（具体内容和mpstat命令相同）。这里主要关注后面I&#x2F;O输出的信息，如下所示：</p>
<p>|标示|说明<br>|——<br>|Device|监测设备名称<br>|rrqm&#x2F;s|每秒需要读取需求的数量<br>|wrqm&#x2F;s|每秒需要写入需求的数量<br>|r&#x2F;s|每秒实际读取需求的数量<br>|w&#x2F;s|每秒实际写入需求的数量<br>|rsec&#x2F;s|每秒读取区段的数量<br>|wsec&#x2F;s|每秒写入区段的数量<br>|rkB&#x2F;s|每秒实际读取的大小，单位为KB<br>|wkB&#x2F;s|每秒实际写入的大小，单位为KB<br>|avgrq-sz|需求的平均大小区段<br>|avgqu-sz|需求的平均队列长度<br>|await|等待I&#x2F;O平均的时间（milliseconds）<br>|svctm|I&#x2F;O需求完成的平均时间<br>|%util|被I&#x2F;O需求消耗的CPU百分比</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（7） -- rm</title>
    <url>/2018/01/06/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-7/</url>
    <content><![CDATA[<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ll</span><br><span class="line">total 40K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br><span class="line">-rw-rw-r--  1 atompi atompi    2 Jan  6 04:26 test.txt</span><br><span class="line">➜  ~ rm test.txt</span><br><span class="line">➜  ~ ll</span><br><span class="line">total 36K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br></pre></td></tr></table></figure>
<h2 id="删除时提示，防止删除关键文件"><a href="#删除时提示，防止删除关键文件" class="headerlink" title="删除时提示，防止删除关键文件"></a>删除时提示，防止删除关键文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ll</span><br><span class="line">total 36K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br><span class="line">drwxrwxr-x  5 atompi atompi 4.0K Jan  6 19:07 atomsrc</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Dec 28 20:26 Documents</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Jan  6 04:28 Downloads</span><br><span class="line">drwxrwxr-x  4 atompi atompi 4.0K Jan  5 05:27 gitee</span><br><span class="line">drwxrwxr-x  8 atompi atompi 4.0K Jan  3 20:25 mayun-ee-p</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 18:50 shadowsocks</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 05:26 Templates</span><br><span class="line">-rw-rw-r--  1 atompi atompi    0 Jan  6 04:23 test-copy.txt</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Jan  6 04:36 testdir-home</span><br><span class="line">➜  ~ rm -i test-copy.txt</span><br><span class="line">rm: remove regular empty file &#x27;test-copy.txt&#x27;? no</span><br><span class="line">➜  ~ ll</span><br><span class="line">total 36K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br><span class="line">drwxrwxr-x  5 atompi atompi 4.0K Jan  6 19:07 atomsrc</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Dec 28 20:26 Documents</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Jan  6 04:28 Downloads</span><br><span class="line">drwxrwxr-x  4 atompi atompi 4.0K Jan  5 05:27 gitee</span><br><span class="line">drwxrwxr-x  8 atompi atompi 4.0K Jan  3 20:25 mayun-ee-p</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 18:50 shadowsocks</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 05:26 Templates</span><br><span class="line">-rw-rw-r--  1 atompi atompi    0 Jan  6 04:23 test-copy.txt</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Jan  6 04:36 testdir-home</span><br></pre></td></tr></table></figure>
<h2 id="删除空目录"><a href="#删除空目录" class="headerlink" title="删除空目录"></a>删除空目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ll</span><br><span class="line">total 36K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br><span class="line">drwxrwxr-x  5 atompi atompi 4.0K Jan  6 19:07 atomsrc</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Dec 28 20:26 Documents</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Jan  6 04:28 Downloads</span><br><span class="line">drwxrwxr-x  4 atompi atompi 4.0K Jan  5 05:27 gitee</span><br><span class="line">drwxrwxr-x  8 atompi atompi 4.0K Jan  3 20:25 mayun-ee-p</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 18:50 shadowsocks</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 05:26 Templates</span><br><span class="line">-rw-rw-r--  1 atompi atompi    0 Jan  6 04:23 test-copy.txt</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Jan  6 04:36 testdir-home</span><br><span class="line">➜  ~ cd testdir-home</span><br><span class="line">➜  testdir-home ll</span><br><span class="line">total 4.0K</span><br><span class="line">drwxrwxr-x 2 atompi atompi 4.0K Jan  6 04:31 testdir-home-2</span><br><span class="line">➜  testdir-home ll testdir-home-2</span><br><span class="line">total 0</span><br><span class="line">➜  testdir-home rm testdir-home-2</span><br><span class="line">rm: cannot remove &#x27;testdir-home-2&#x27;: Is a directory</span><br><span class="line">➜  testdir-home rmdir testdir-home-2</span><br><span class="line">➜  testdir-home ll</span><br><span class="line">total 0</span><br></pre></td></tr></table></figure>
<h2 id="删除文件和非空目录"><a href="#删除文件和非空目录" class="headerlink" title="删除文件和非空目录"></a>删除文件和非空目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ ll testdir</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r-- 1 atompi atompi 0 Jan  6 04:23 test-copy.txt</span><br><span class="line">➜  ~ rmdir testdir</span><br><span class="line">rmdir: failed to remove &#x27;testdir&#x27;: Directory not empty</span><br><span class="line">➜  ~ rm -rf testdir</span><br><span class="line">➜  ~ ll</span><br><span class="line">total 32K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br><span class="line">drwxrwxr-x  5 atompi atompi 4.0K Jan  6 19:07 atomsrc</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Dec 28 20:26 Documents</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Jan  6 04:28 Downloads</span><br><span class="line">drwxrwxr-x  4 atompi atompi 4.0K Jan  5 05:27 gitee</span><br><span class="line">drwxrwxr-x  8 atompi atompi 4.0K Jan  3 20:25 mayun-ee-p</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 18:50 shadowsocks</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 05:26 Templates</span><br></pre></td></tr></table></figure>
<h2 id="删除文件名开头特殊的文件"><a href="#删除文件名开头特殊的文件" class="headerlink" title="删除文件名开头特殊的文件"></a>删除文件名开头特殊的文件</h2><p>比如以 <code>-</code> 开头的文件或文件夹，操作之前需要在文件名前加 <code>--</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ touch -- -testfile.txt</span><br><span class="line">➜  ~ ll</span><br><span class="line">total 32K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br><span class="line">drwxrwxr-x  5 atompi atompi 4.0K Jan  6 19:07 atomsrc</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Dec 28 20:26 Documents</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Jan  6 04:28 Downloads</span><br><span class="line">drwxrwxr-x  4 atompi atompi 4.0K Jan  5 05:27 gitee</span><br><span class="line">drwxrwxr-x  8 atompi atompi 4.0K Jan  3 20:25 mayun-ee-p</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 18:50 shadowsocks</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 05:26 Templates</span><br><span class="line">-rw-rw-r--  1 atompi atompi    0 Jan  7 04:15 -testfile.txt</span><br><span class="line">➜  ~</span><br><span class="line">➜  ~</span><br><span class="line">➜  ~ rm -testfile.txt</span><br><span class="line">rm: invalid option -- &#x27;t&#x27;</span><br><span class="line">Try &#x27;rm ./-testfile.txt&#x27; to remove the file &#x27;-testfile.txt&#x27;.</span><br><span class="line">Try &#x27;rm --help&#x27; for more information.</span><br><span class="line">➜  ~</span><br><span class="line">➜  ~ rm -- -testfile.txt</span><br><span class="line">➜  ~ ll</span><br><span class="line">total 32K</span><br><span class="line">drwxrwxr-x 22 atompi atompi 4.0K Jan  5 05:42 anaconda2</span><br><span class="line">drwxrwxr-x  5 atompi atompi 4.0K Jan  6 19:07 atomsrc</span><br><span class="line">drwxrwxr-x  3 atompi atompi 4.0K Dec 28 20:26 Documents</span><br><span class="line">drwxrwxr-x  6 atompi atompi 4.0K Jan  6 04:28 Downloads</span><br><span class="line">drwxrwxr-x  4 atompi atompi 4.0K Jan  5 05:27 gitee</span><br><span class="line">drwxrwxr-x  8 atompi atompi 4.0K Jan  3 20:25 mayun-ee-p</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 18:50 shadowsocks</span><br><span class="line">drwxrwxr-x  2 atompi atompi 4.0K Jan  5 05:26 Templates</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>离线安装 Harbor v2</title>
    <url>/2021/02/22/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Harbor_v2/</url>
    <content><![CDATA[<h2 id="什么是-harbor-？"><a href="#什么是-harbor-？" class="headerlink" title="什么是 harbor ？"></a>什么是 harbor ？</h2><p>Harbor 是一个开源、可信、云原生的镜像仓库项目，用于存储，签名和扫描内容。</p>
<p>Harbor 通过添加用户通常需要的功能（如安全性，身份验证和管理）来扩展开源 Docker 镜像分发工具（如 Docker registry）。</p>
<p>Harbor 使 registry 更接近构建和运行环境，并且可以提高镜像传输效率。</p>
<p>Harbor 支持在 registry 之间复制映像，还提供高级安全功能，如用户管理，访问控制和活动审计。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>基于角色的访问控制：用户和存储库通过“项目”进行组织，用户可以对项目下的镜像赋予不同的权限。</li>
<li>基于策略的镜像复制：可以在多个 registry 实例之间复制（同步）映像，并自动重试错误。非常适合负载平衡，高可用性，多数据中心，混合和多云场景。</li>
<li>漏洞扫描：Harbor 定期扫描镜像并警告用户漏洞。</li>
<li>LDAP &#x2F; AD 支持：Harbor 与现有企业 LDAP &#x2F; AD 集成，用于用户身份验证和管理。</li>
<li>镜像删除和垃圾收集：可以删除镜像，并可以回收它们的空间。</li>
<li>公证：可以确保图像的真实性。</li>
<li>图形化界面：用户可以轻松浏览，搜索存储库和管理项目。</li>
<li>审计：跟踪存储库的所有操作。</li>
<li>RESTful API：适用于大多数管理操作的 RESTful API，易于与外部系统集成。</li>
<li>易于部署：提供在线和离线安装程序。</li>
<li>支持 Helm 包管理</li>
</ul>
<h2 id="部署-运行"><a href="#部署-运行" class="headerlink" title="部署 &amp; 运行"></a>部署 &amp; 运行</h2><h3 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a>环境要求：</h3><p>目前只支持在 Linux 操作系统下部署， 安装最新版本的 docker 及 docker-compose，最低版本要求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker engine: Version 17.06.0-ce+ or higher</span><br><span class="line">Docker Compose: Version 1.18.0 or higher</span><br></pre></td></tr></table></figure>

<p>同时需要开放如下端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80: HTTP</span><br><span class="line">443: HTTPS</span><br></pre></td></tr></table></figure>

<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><ul>
<li>下载离线安装程序</li>
</ul>
<p>下载地址：<code>https://github.com/vmware/harbor/releases</code></p>
<p>选择：<code>harbor-offline-installer-.tgz</code></p>
<ul>
<li>解压安装包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xf harbor-offline-installer-.tgz</span><br></pre></td></tr></table></figure>

<ul>
<li>配置 Harbor</li>
</ul>
<p>配置文件模板为：<code>harbor.yml.tmpl</code></p>
<p>复制模板文件，并命名为 <code>harbor.yml</code></p>
<p>在 <code>harbor.yml</code> 中有两类参数：必需参数和可选参数。</p>
<ul>
<li>必选参数：需要在配置文件中设置这些参数。如果用户在 <code>harbor.yml</code> 中更新它们并运行 <code>install.sh</code> 脚本以重新安装 Harbor，它们将生效。</li>
<li>可选参数：这些参数对于更新是可选的，即用户可以将它们保留为默认值，并在启动 Harbour 后在 Web UI 上更新它们。如果它们设置在 <code>harbor.yml</code> 中，它们只会在第一次启动 Harbour 时生效。后续在 Web UI 中的更新将忽略 <code>harbor.yml</code> 中这些参数。</li>
</ul>
<p>在这里，我只列出部分必选参数的配置，具体参数说明见文章末尾处给出的官方安装文档连接</p>
<ol>
<li>必选参数：</li>
</ol>
<ul>
<li><code>hostname</code>: 访问 harbor 的域名，可以使用主机 IP，但建议使用域名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname = reg.atompi.com</span><br></pre></td></tr></table></figure>

<ul>
<li><code>http / https</code>: 访问 harbor 的 url 协议，若只使用 <code>http</code>，则注释掉 <code>https</code> 项即可（如下），若启用 <code>https</code> 请参考 <a href="https://goharbor.io/docs/2.0.0/install-config/configure-https/">Configuring Harbor with HTTPS Access</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># http related config</span><br><span class="line">http:</span><br><span class="line">  # port for http, default is 80. If https enabled, this port will redirect to https port</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line"># https related config</span><br><span class="line">#https:</span><br><span class="line">  # https port for harbor, default is 443</span><br><span class="line">  #port: 443</span><br><span class="line">  # The path of cert and key files for nginx</span><br><span class="line">  #certificate: /your/certificate/path</span><br><span class="line">  #private_key: /your/private/key/path</span><br></pre></td></tr></table></figure>

<ul>
<li><code>harbor_admin_password</code>: 超级管理员用户 <code>admin</code> 的登录密码</li>
<li><code>database.password</code>: 数据库 root 用户密码，用于指定 Harbor 默认数据库 root 用户密码，生产环境建议修改这个值为复杂密码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database:</span><br><span class="line">  # The password for the root user of Harbor DB. Change this before any production use.</span><br><span class="line">  password: root123</span><br></pre></td></tr></table></figure>

<ul>
<li><code>data_volume</code>: 由于 Harbor 所有组件都使用 docker 容器化部署，所以需要将容器数据持久化到宿主机目录，该配置项就是指定持久化目录的挂载点，建议在某目录下创建 <code>harbor</code> 文件夹，并作为挂载点，便于统一管理和迁移。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data_volume: /data/harbor</span><br></pre></td></tr></table></figure>

<h2 id="执行-install-sh-开始安装"><a href="#执行-install-sh-开始安装" class="headerlink" title="执行 install.sh 开始安装"></a>执行 install.sh 开始安装</h2><p>默认情况下，不带任何参数的 <code>install.sh</code> 脚本只安装 Harbor 主服务，如果需要安装其他附加服务，可带指定参数安装，可安装的附加服务有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Harbor with Notary （ --with-notary ）：一个允许任何人信任任意数据集合的项目，用于运行和与可信集合交互。</span><br><span class="line">Harbor with Clair （--with-clair）：Docker 镜像安全漏洞扫描工具</span><br><span class="line">Harbor with Chart Repository Service（--with-chartmuseum）：Helm 包管理工具</span><br></pre></td></tr></table></figure>

<p>这里我们安装带 Helm 包管理的 Harbor</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./install.sh --with-chartmuseum</span><br></pre></td></tr></table></figure>

<h2 id="登录-harbor-并配置-Docker-“insecure-registries”"><a href="#登录-harbor-并配置-Docker-“insecure-registries”" class="headerlink" title="登录 harbor 并配置 Docker “insecure-registries”"></a>登录 harbor 并配置 Docker “insecure-registries”</h2><ul>
<li><p>Web UI 地址： <code>http://reg.atompi.com</code></p>
</li>
<li><p>docker login</p>
</li>
</ul>
<p>修改 docker daemon 配置文件 <code>/etc/docker/daemon.json</code>，添加如下配置项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;insecure-registries&quot;: [&quot;reg.atompi.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>docker 登录 registry</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login reg.atompi.com</span><br></pre></td></tr></table></figure>

<h2 id="扩展阅读："><a href="#扩展阅读：" class="headerlink" title="扩展阅读："></a>扩展阅读：</h2><ul>
<li><a href="https://goharbor.io/docs/2.0.0/install-config/">官方安装文档</a></li>
<li><a href="https://goharbor.io/docs/2.0.0/administration/">官方管理文档</a></li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Harbor</tag>
        <tag>Cloud Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下编译安装 Redis 3.x</title>
    <url>/2018/01/07/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Redis/</url>
    <content><![CDATA[<h2 id="下载源码包"><a href="#下载源码包" class="headerlink" title="下载源码包"></a>下载源码包</h2><p>下载地址：<a href="http://download.redis.io/releases/">http://download.redis.io/releases/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="解压源码包"><a href="#解压源码包" class="headerlink" title="解压源码包"></a>解压源码包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxf redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd redis-3.2.11</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="初始化，创建-redis-server"><a href="#初始化，创建-redis-server" class="headerlink" title="初始化，创建 redis server"></a>初始化，创建 redis server</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd utils</span><br><span class="line">sudo ./install_server.sh</span><br><span class="line"># 此处可根据需要进行基础配置，亦可一路回车（ Enter ）完成初始化，然后修改 `/etc/redis/6379.conf` 文件，完成配置</span><br></pre></td></tr></table></figure>
<h2 id="修改一些必要的配置（开发环境）"><a href="#修改一些必要的配置（开发环境）" class="headerlink" title="修改一些必要的配置（开发环境）"></a>修改一些必要的配置（开发环境）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>
<p>禁用保护模式、允许远程连接（可选）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line">#bind 127.0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="关于-3-2-新特性：-protected-mode"><a href="#关于-3-2-新特性：-protected-mode" class="headerlink" title="关于 3.2 新特性： protected-mode"></a>关于 3.2 新特性： protected-mode</h2><p>3.2 后新增 protected-mode 配置，默认是 yes，即开启保护模式。官方说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="line">#</span><br><span class="line"># When protected mode is on and if:</span><br><span class="line">#</span><br><span class="line"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">#    &quot;bind&quot; directive.</span><br><span class="line"># 2) No password is configured.</span><br><span class="line">#</span><br><span class="line"># The server only accepts connections from clients connecting from the</span><br><span class="line"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line"># sockets.</span><br><span class="line">#</span><br><span class="line"># By default protected mode is enabled. You should disable it only if</span><br><span class="line"># you are sure you want clients from other hosts to connect to Redis</span><br><span class="line"># even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line"># are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure>
<p>开启后，若在服务端没有配置 <code>bind ip</code> （注释掉 <code>bind</code> 字段的配置） 或者没有设置 <code>masterauth &lt;master-password&gt;&lt;/master-password&gt;</code> （ server 端连接密码）， client 连接 server 时就出现如下报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.19.128:6379&amp;gt; keys *</span><br><span class="line">(error) DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command &#x27;CONFIG SET protected-mode no&#x27; from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and settingthe protected mode option to &#x27;no&#x27;, and then restarting the server. 3) If you started the server manually just for testing, restart it with the &#x27;--protected-mode no&#x27; option. 4) Setup a bindaddress or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.</span><br></pre></td></tr></table></figure>
<p>强烈建议在生产环境开启 <code>protected-mode</code> 以提高安全性，对于开发环境建议使用 “禁用保护模式、允许远程连接（可选）” 的配置。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（8） -- man</title>
    <url>/2018/01/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-8/</url>
    <content><![CDATA[<h2 id="使用-man-查找命令相关信息：命令的手册"><a href="#使用-man-查找命令相关信息：命令的手册" class="headerlink" title="使用 man 查找命令相关信息：命令的手册"></a>使用 man 查找命令相关信息：命令的手册</h2><p>使用 <code>man name</code> 来查看命令的使用方法、介绍等相关信息，对学习一个命令非常有帮助。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# man man</span><br><span class="line"># 进入如下状态，按 &#x27;q&#x27; 退出</span><br><span class="line">MAN(1)                                               Manual pager utils                                              MAN(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       man - an interface to the on-line reference manuals</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       man  [-C file] [-d] [-D] [--warnings[=warnings]] [-R encoding] [-L locale] [-m system[,...]] [-M path] [-S list] [-e</span><br><span class="line">       extension] [-i|-I] [--regex|--wildcard] [--names-only] [-a] [-u] [--no-subpages] [-P pager]  [-r  prompt]  [-7]  [-E</span><br><span class="line">       encoding]  [--no-hyphenation] [--no-justification] [-p string] [-t] [-T[device]] [-H[browser]] [-X[dpi]] [-Z] [[sec‐</span><br><span class="line">       tion] page ...] ...</span><br><span class="line">       man -k [apropos options] regexp ...</span><br><span class="line">       man -K [-w|-W] [-S list] [-i|-I] [--regex] [section] term ...</span><br><span class="line">       man -f [whatis options] page ...</span><br><span class="line">       man -l [-C file] [-d] [-D] [--warnings[=warnings]] [-R encoding] [-L locale] [-P pager] [-r prompt] [-7] [-E  encod‐</span><br><span class="line">       ing] [-p string] [-t] [-T[device]] [-H[browser]] [-X[dpi]] [-Z] file ...</span><br><span class="line">       man -w|-W [-C file] [-d] [-D] page ...</span><br><span class="line">       man -c [-C file] [-d] [-D] page ...</span><br><span class="line">       man [-?V]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       man  is  the  system&#x27;s  manual pager.  Each page argument given to man is normally the name of a program, utility or</span><br><span class="line">       function.  The manual page associated with each of these arguments is then found and displayed.  A section, if  pro‐</span><br><span class="line">       vided,  will  direct  man to look only in that section of the manual.  The default action is to search in all of the</span><br><span class="line">       available sections following a pre-defined order (&quot;1 n l 8 3 2 3posix 3pm 3perl 5 4 9 6 7&quot; by default, unless  over‐</span><br><span class="line">       ridden  by the SECTION directive in /etc/manpath.config), and to show only the first page found, even if page exists</span><br><span class="line">       in several sections.</span><br><span class="line"></span><br><span class="line">       The table below shows the section numbers of the manual followed by the types of pages they contain.</span><br><span class="line"></span><br><span class="line">       1   Executable programs or shell commands</span><br><span class="line">       2   System calls (functions provided by the kernel)</span><br><span class="line">       3   Library calls (functions within program libraries)</span><br><span class="line">       4   Special files (usually found in /dev)</span><br><span class="line">       5   File formats and conventions eg /etc/passwd</span><br><span class="line">       6   Games</span><br><span class="line"> Manual page man(1) line 1 (press h for help or q to quit)</span><br></pre></td></tr></table></figure>
<h2 id="知道命令名称，如何快速查找其功能？"><a href="#知道命令名称，如何快速查找其功能？" class="headerlink" title="知道命令名称，如何快速查找其功能？"></a>知道命令名称，如何快速查找其功能？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# man -f man</span><br><span class="line">man (1)              - an interface to the on-line reference manuals</span><br><span class="line">man (7)              - macros to format man pages</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# whatis man</span><br><span class="line">man (1)              - an interface to the on-line reference manuals</span><br><span class="line">man (7)              - macros to format man pages</span><br></pre></td></tr></table></figure>
<h2 id="知道命令的功能，如何查找命令名称？"><a href="#知道命令的功能，如何查找命令名称？" class="headerlink" title="知道命令的功能，如何查找命令名称？"></a>知道命令的功能，如何查找命令名称？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man -k list</span><br><span class="line">apropos -e list</span><br><span class="line"># 以上两个命令都会输出很多匹配 `list` 的结果，输出的结果可能不全是想要的，但是，当你一时忘记了命令的全名，不妨试一试，说不定看到提示，你就想起来了呢。</span><br><span class="line"># man -k list | grep list == apropos -e list</span><br></pre></td></tr></table></figure>
<h2 id="读取命令的特定手册页面"><a href="#读取命令的特定手册页面" class="headerlink" title="读取命令的特定手册页面"></a>读取命令的特定手册页面</h2><p><code>man [1-8]</code></p>
<p><a href="http://zheming.wang/blog/2011/02/17/65C9E90A-8D99-46DA-AC8D-F4D4EC825CD8/">这 ‘1-8’ 是什么意思？</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@atompi:~# man 5 passwd</span><br><span class="line">PASSWD(5)                                       File Formats and Conversions                                      PASSWD(5)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       passwd - the password file</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       /etc/passwd contains one line for each user account, with seven fields delimited by colons (“:”). These fields are:</span><br><span class="line"></span><br><span class="line">       ·   login name</span><br><span class="line"></span><br><span class="line">       ·   optional encrypted password</span><br><span class="line"></span><br><span class="line">       ·   numerical user ID</span><br><span class="line"></span><br><span class="line">       ·   numerical group ID</span><br><span class="line"></span><br><span class="line">       ·   user name or comment field</span><br><span class="line"></span><br><span class="line">       ·   user home directory</span><br><span class="line"></span><br><span class="line">       ·   optional user command interpreter</span><br><span class="line"></span><br><span class="line">       The encrypted password field may be blank, in which case no password is required to authenticate as the specified</span><br><span class="line">       login name. However, some applications which read the /etc/passwd file may decide not to permit any access at all if</span><br><span class="line">       the password field is blank. If the password field is a lower-case “x”, then the encrypted password is actually</span><br><span class="line">       stored in the shadow(5) file instead; there must be a corresponding line in the /etc/shadow file, or else the user</span><br><span class="line">       account is invalid. If the password field is any other string, then it will be treated as an encrypted password, as</span><br><span class="line">       specified by crypt(3).</span><br><span class="line"></span><br><span class="line">       The comment field is used by various system utilities, such as finger(1).</span><br><span class="line"></span><br><span class="line">       The home directory field provides the name of the initial working directory. The login program uses this information</span><br><span class="line">       to set the value of the $HOME environmental variable.</span><br><span class="line"></span><br><span class="line">       The command interpreter field provides the name of the user&#x27;s command language interpreter, or the name of the</span><br><span class="line"> Manual page passwd(5) line 1 (press h for help or q to quit)</span><br></pre></td></tr></table></figure>
<h2 id="提供几个有助于理解-man-的链接："><a href="#提供几个有助于理解-man-的链接：" class="headerlink" title="提供几个有助于理解 man 的链接："></a>提供几个有助于理解 man 的链接：</h2><p><a href="https://www.linux.org/docs/">https://www.linux.org/docs/</a></p>
<p><a href="https://linux.die.net/man/">https://linux.die.net/man/</a></p>
<p><a href="http://www.linfo.org/man.html">http://www.linfo.org/man.html</a></p>
<p><a href="http://man7.org/linux/man-pages/">http://man7.org/linux/man-pages/</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个 Linux 命令（9） -- info</title>
    <url>/2018/01/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-9/</url>
    <content><![CDATA[<h2 id="自行-Google-吧"><a href="#自行-Google-吧" class="headerlink" title="自行 Google 吧"></a>自行 Google 吧</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;我个人不喜欢使用 info ，如果要被迫使用 info ，那么我会在 Google 中搜索。&quot;</span><br><span class="line">                                                    --Scott Granneman</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
